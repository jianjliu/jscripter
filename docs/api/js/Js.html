<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_25) on Thu Sep 15 00:19:44 CST 2011 -->
<TITLE>
Js (JScripter(JS) Standard 1.0 API & Re-compilation Specification)
</TITLE>

<META NAME="date" CONTENT="2011-09-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Js (JScripter(JS) Standard 1.0 API & Re-compilation Specification)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Js.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
JScripter(JS) Standard 1.0 API & Re-compilation Specification</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../js/Initializer.html" title="class in js"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../js/JsApplet.html" title="class in js"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?js/Js.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Js.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_classes_inherited_from_class_js.Function">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
js</FONT>
<BR>
Class Js</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../js/Disposable.html" title="class in js">js.Disposable</A>
      <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../js/Var.html" title="class in js">js.Var</A>&lt;<A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt;&gt;
          <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../js/Function.html" title="class in js">js.Function</A>&lt;java.lang.Void&gt;
              <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>js.Js</B>
</PRE>
<HR>
<DL>
<DT><PRE>public abstract class <B>Js</B><DT>extends <A HREF="../js/Function.html" title="class in js">Function</A>&lt;java.lang.Void&gt;</DL>
</PRE>

<P>
<p>An <b>opaque</b> class providing basic utilities with its static methods.</p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD><a href="mailto:jianjunliu@126.com">J.J.Liu (Jianjun Liu)</a> at <a href="http://www.jscripter.org" target="_blank">http://www.jscripter.org</a></DD>
<DT><B>JavaScript:</B></DT>
  <DD><b>Opaque</b> types can be resolved but no class objects for them can be 
 generated into the target codes. Re-compilers must exit with error on the operations of 
 accessing that kind of class objects.</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_js.Function"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class js.<A HREF="../js/Function.html" title="class in js">Function</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Function.Arguments.html" title="class in js">Function.Arguments</A>, <A HREF="../js/Function.Call.html" title="class in js">Function.Call</A>&lt;<A HREF="../js/Function.Call.html" title="type parameter in Function.Call">T</A>&gt;</CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_js.Var"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class js.<A HREF="../js/Var.html" title="class in js">Var</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Var.Generic.html" title="class in js">Var.Generic</A>&lt;<A HREF="../js/Var.Generic.html" title="type parameter in Var.Generic">T</A>&gt;, <A HREF="../js/Var.Member.html" title="class in js">Var.Member</A>&lt;<A HREF="../js/Var.Member.html" title="type parameter in Var.Member">T</A>&gt;, <A HREF="../js/Var.Members.html" title="class in js">Var.Members</A>, <A HREF="../js/Var.Mid.html" title="class in js">Var.Mid</A></CODE></TD>
</TR>
</TABLE>
&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#activeX(java.lang.String)">activeX</A></B>(java.lang.String&nbsp;cls)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an OLE Automation (ActiveX) object for Internet Explorer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Character, java.lang.Character)">add</A></B>(java.lang.Character&nbsp;var,
    java.lang.Character&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Character, java.lang.Number)">add</A></B>(java.lang.Character&nbsp;var,
    java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Character, js.NumberLike)">add</A></B>(java.lang.Character&nbsp;var,
    <A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Character, js.Var)">add</A></B>(java.lang.Character&nbsp;var,
    <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Number, java.lang.Character)">add</A></B>(java.lang.Number&nbsp;var,
    java.lang.Character&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.NumberLike, java.lang.Character)">add</A></B>(<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
    java.lang.Character&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.NumberLike, java.lang.Number)">add</A></B>(<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
    java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.NumberLike, js.NumberLike)">add</A></B>(<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
    <A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.NumberLike, js.Var)">add</A></B>(<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
    <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Number, java.lang.Number)">add</A></B>(java.lang.Number&nbsp;var,
    java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Number, js.NumberLike)">add</A></B>(java.lang.Number&nbsp;var,
    <A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Number, js.Var)">add</A></B>(java.lang.Number&nbsp;var,
    <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Object, java.lang.Object)">add</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Object, java.lang.String)">add</A></B>(java.lang.Object&nbsp;var,
    java.lang.String&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.Object, js.StringLike)">add</A></B>(java.lang.Object&nbsp;var,
    <A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.StringLike, java.lang.Object)">add</A></B>(<A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.StringLike, java.lang.String)">add</A></B>(<A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;var,
    java.lang.String&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.StringLike, js.StringLike)">add</A></B>(<A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;var,
    <A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.String, java.lang.Object)">add</A></B>(java.lang.String&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.String, java.lang.String)">add</A></B>(java.lang.String&nbsp;var,
    java.lang.String&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(java.lang.String, js.StringLike)">add</A></B>(java.lang.String&nbsp;var,
    <A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.Var, java.lang.Character)">add</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;var,
    java.lang.Character&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.Var, java.lang.Number)">add</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;var,
    java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.Var, js.NumberLike)">add</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;var,
    <A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#add(js.Var, js.Var)">add</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;var,
    <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#alert(java.lang.Object)">alert</A></B>(java.lang.Object&nbsp;message)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Displays a simple message in a dialog box, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(java.lang.Boolean, js.core.JsBoolean)">and</A></B>(java.lang.Boolean&nbsp;var,
    <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(java.lang.Character, js.core.JsNumber)">and</A></B>(java.lang.Character&nbsp;var,
    <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.core.JsBoolean, java.lang.Boolean)">and</A></B>(<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;var,
    java.lang.Boolean&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.core.JsBoolean, js.Var)">and</A></B>(<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;var,
    <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Boolean&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.core.JsNumber, java.lang.Character)">and</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
    java.lang.Character&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.core.JsNumber, java.lang.Number)">and</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
    java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.core.JsNumber, js.Value)">and</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
    <A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Character&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.core.JsNumber, js.Var)">and</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
    <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.core.JsString, java.lang.String)">and</A></B>(<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;var,
    java.lang.String&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.core.JsString, js.Var)">and</A></B>(<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;var,
    <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.String&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(java.lang.Number, js.core.JsNumber)">and</A></B>(java.lang.Number&nbsp;var,
    <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(java.lang.String, js.core.JsString)">and</A></B>(java.lang.String&nbsp;var,
    <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(T, T)">and</A></B>(T&nbsp;var,
    T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(T, T)">and</A></B>(T&nbsp;var,
    T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(T, js.Var)">and</A></B>(T&nbsp;var,
    <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(T, js.Var)">and</A></B>(T&nbsp;var,
    <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.Value, js.core.JsNumber)">and</A></B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Character&gt;&nbsp;var,
    <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.Var, js.core.JsNumber)">and</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
    <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.Var, T)">and</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
    T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.Var, T)">and</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
    T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.Var, js.Var)">and</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
    <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.Var, js.core.JsBoolean)">and</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Boolean&gt;&nbsp;var,
    <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#and(js.Var, js.core.JsString)">and</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.String&gt;&nbsp;var,
    <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#apply(js.ObjectLike, js.ObjectLike)">apply</A></B>(<A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A>&nbsp;o,
      <A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A>&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies all the properties of <tt>a</tt> to <tt>o</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#array()">array</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an empty array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Boolean&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#array(boolean[])">array</A></B>(boolean[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array-like representation of a boolean array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Byte&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#array(byte[])">array</A></B>(byte[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array-like representation of a byte array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Character&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#array(char[])">array</A></B>(char[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array-like representation of a char array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Double&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#array(double[])">array</A></B>(double[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array-like representation of a double array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Float&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#array(float[])">array</A></B>(float[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array-like representation of a float array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#array(int[])">array</A></B>(int[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array-like representation of an int array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Long&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#array(long[])">array</A></B>(long[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array-like representation of a long array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Short&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#array(short[])">array</A></B>(short[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array-like representation of a short array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#array(T[])">array</A></B>(T[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the array-like representation of a generic array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#band(java.lang.Object, java.lang.Object)">band</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bitwise-AND operation, resembling that of JavaScript, performs a boolean AND 
 operation on each bit of the integer arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(js.ArrayLike)">be</A></B>(<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;?&gt;&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(boolean)">be</A></B>(boolean&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(java.lang.Boolean)">be</A></B>(java.lang.Boolean&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(byte)">be</A></B>(byte&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(char)">be</A></B>(char&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(java.lang.Character)">be</A></B>(java.lang.Character&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(double)">be</A></B>(double&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(float)">be</A></B>(float&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(int)">be</A></B>(int&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(js.core.JsArray)">be</A></B>(<A HREF="../js/core/JsArray.html" title="class in js.core">JsArray</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(long)">be</A></B>(long&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(java.lang.Number)">be</A></B>(java.lang.Number&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(java.lang.Object)">be</A></B>(java.lang.Object&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(short)">be</A></B>(short&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(java.lang.String)">be</A></B>(java.lang.String&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#be(js.Var)">be</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;?&gt;&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#bnot(java.lang.Object)">bnot</A></B>(java.lang.Object&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bitwise-NOT operation, resembling that of JavaScript, operates by reversing all 
 bits in the operand.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#bor(java.lang.Object, java.lang.Object)">bor</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bitwise-OR operation, resembling that of JavaScript, performs a boolean OR operation 
 on each bit of the integer arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/Cases.html" title="interface in js">Cases</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#cases()">cases</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates and return a <tt>Cases</tt> cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#clearInterval(java.lang.Object)">clearInterval</A></B>(java.lang.Object&nbsp;intervalId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cancels periodic execution of code, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#clearTimeout(java.lang.Object)">clearTimeout</A></B>(java.lang.Object&nbsp;timeoutId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cancels a pending timeout operation, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#comma(java.lang.Object, T)">comma</A></B>(java.lang.Object&nbsp;var,
      T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comma operation, resembling the comma operator of JavaScript, evaluates the 
 first operand, evaluates the second operand, and then returns the value of the 
 second operand.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#cond(java.lang.Object, T, T)">cond</A></B>(java.lang.Object&nbsp;test,
     T&nbsp;var,
     T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#cond(java.lang.Object, T, T)">cond</A></B>(java.lang.Object&nbsp;test,
     T&nbsp;var,
     T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#cond(java.lang.Object, T, js.Var)">cond</A></B>(java.lang.Object&nbsp;test,
     T&nbsp;var,
     <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#cond(java.lang.Object, T, js.Var)">cond</A></B>(java.lang.Object&nbsp;test,
     T&nbsp;var,
     <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#cond(java.lang.Object, js.Var, T)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
     T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#cond(java.lang.Object, js.Var, T)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
     T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#cond(java.lang.Object, js.Var, js.Var)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
     <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#confirm(java.lang.Object)">confirm</A></B>(java.lang.Object&nbsp;question)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asks a yes-or-no question with a dialog box, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/LiveObject.html" title="interface in js">LiveObject</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#connect(java.lang.Object)">connect</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Connects to a Java object and returns a LiveConnect object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/LiveClass.html" title="interface in js">LiveClass</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#connect(java.lang.String, java.lang.String)">connect</A></B>(java.lang.String&nbsp;applet,
        java.lang.String&nbsp;cls)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Connects to a Java class in an applet and returns a LiveConnect class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsGlobal.html" title="class in js.core">JsGlobal</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#core()">core</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Opaquely gets the JavaScript Global object with the core support only.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/DateLike.html" title="interface in js">DateLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#date()">date</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a date object set to the current system date and time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/DateLike.html" title="interface in js">DateLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#date(java.lang.Number)">date</A></B>(java.lang.Number&nbsp;milliseconds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a date object from a numeric representation in milliseconds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/DateLike.html" title="interface in js">DateLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#date(java.lang.String)">date</A></B>(java.lang.String&nbsp;datestring)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a date object from a string representation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#debug()">debug</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Opaquely tells whether the current running environment is JS Simulation (debug mode) 
 or JavaScript (re-compiled).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#decodeURI(java.lang.Object)">decodeURI</A></B>(java.lang.Object&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decodes a string escaped with <A HREF="../js/Js.html#encodeURI(java.lang.Object)"><CODE>encodeURI(Object)</CODE></A>, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#decodeURIComponent(java.lang.Object)">decodeURIComponent</A></B>(java.lang.Object&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decodes a string escaped with <A HREF="../js/Js.html#encodeURIComponent(java.lang.Object)"><CODE>encodeURIComponent(Object)</CODE></A>, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#defined(java.lang.Object)">defined</A></B>(java.lang.Object&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a variable is defined.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#delete(js.ArrayLike, int)">delete</A></B>(<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;?&gt;&nbsp;var,
       int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete an array element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#delete(js.core.JsObject)">delete</A></B>(<A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Undefines a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#delete(js.core.JsObject, java.lang.Object)">delete</A></B>(<A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&nbsp;var,
       java.lang.Object&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Undefines a property.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#delete(js.ObjectLike, java.lang.Object)">delete</A></B>(<A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A>&nbsp;var,
       java.lang.Object&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Undefines a property.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#delete(js.Value)">delete</A></B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;?&gt;&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Undefines a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#delete(js.Var)">delete</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Undefines a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#delete(js.Var, java.lang.Object)">delete</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;var,
       java.lang.Object&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Undefines a property.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#div(java.lang.Object, java.lang.Object)">div</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Divides the first operand by the second, resembling the division operator 
 in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#encodeURI(java.lang.Object)">encodeURI</A></B>(java.lang.Object&nbsp;uri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encodes a URI by escaping certain characters, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#encodeURIComponent(java.lang.Object)">encodeURIComponent</A></B>(java.lang.Object&nbsp;uri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encodes a URI component by escaping certain characters, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#eq(java.lang.Object, java.lang.Object)">eq</A></B>(java.lang.Object&nbsp;var,
   java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#eqs(java.lang.Object, java.lang.Object)">eqs</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.RuntimeException</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#err(java.lang.Object)">err</A></B>(java.lang.Object&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Makes a variable runtime throwable, resembling JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#err(java.lang.RuntimeException)">err</A></B>(java.lang.RuntimeException&nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the value or object contained in a <tt>RuntimeException</tt> object 
 thrown by JS Simulation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#escape(java.lang.Object)">escape</A></B>(java.lang.Object&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encodes a string by replacing certain characters with escape sequences, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#eval(java.lang.Object)">eval</A></B>(java.lang.Object&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evaluates the argument string as JavaScript code and returns the result, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#function()">function</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an empty JavaScript function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#function(java.lang.String)">function</A></B>(java.lang.String&nbsp;body)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a JavaScript function that has no argument names.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#function(java.lang.String, java.lang.String)">function</A></B>(java.lang.String&nbsp;argname,
         java.lang.String&nbsp;body)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a JavaScript function with an argument name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#function(js.Vars, java.lang.String)">function</A></B>(<A HREF="../js/Vars.html" title="class in js">Vars</A>&lt;java.lang.String&gt;&nbsp;argnames,
         java.lang.String&nbsp;body)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a JavaScript function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#gt(java.lang.Object, java.lang.Object)">gt</A></B>(java.lang.Object&nbsp;var,
   java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater-than operation, resembling that of JavaScript, evaluates to <tt>true</tt> if 
 the first operand is greater than the second operand; otherwise it evaluates to 
 <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#gte(java.lang.Object, java.lang.Object)">gte</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater-than-or-equal operation, resembling that of JavaScript, evaluates to 
 <tt>true</tt> if the first operand is greater than or equal to the second operand; 
 otherwise it evaluates to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/user/JsXMLHttpRequest.html" title="class in js.user">JsXMLHttpRequest</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#http()">http</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an instance of XMLHttpRequest in Java version.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#in(java.lang.Object, java.lang.Object)">in</A></B>(java.lang.Object&nbsp;var,
   java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the first operand is the name of a property of the second, resembling 
 the <tt>in</tt> operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#init(js.Sim)">init</A></B>(<A HREF="../js/Sim.html" title="class in js">Sim</A>&nbsp;sim)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An <b>internal</b> method only called internally in <A HREF="../js/Js.html#init(js.Sim)"><CODE>init(Sim)</CODE></A> to 
 initialize JS Simulation and JS developers must follow this rule to ensure the 
 class <A HREF="../js/Sim.html" title="class in js"><CODE>Sim</CODE></A> and its subclasses invisible to JS re-compilers which start 
 processing at <A HREF="../js/JsApplet.html#onReady()"><CODE>JsApplet.onReady()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#instanceOf(java.lang.Object, java.lang.Object)">instanceOf</A></B>(java.lang.Object&nbsp;var,
           java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the first operand is an instance of the second, resembling the 
 <tt>instanceof</tt> operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#integer(java.lang.String)">integer</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates an integer literal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#isFinite(java.lang.Object)">isFinite</A></B>(java.lang.Object&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests whether a value is a finite number, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#isJavaObject(java.lang.Object)">isJavaObject</A></B>(java.lang.Object&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a variable represents a Java object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#isNaN(java.lang.Object)">isNaN</A></B>(java.lang.Object&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests whether a value is the not-a-number value, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#keys(js.ObjectLike)">keys</A></B>(<A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A>&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the list of the property names of an object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#ladd(java.lang.Object, java.lang.Object)">ladd</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds two 64-bit integers, casting the operands to <tt>long</tt> numbers if any 
 one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#land(java.lang.Object, java.lang.Object)">land</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit bitwise-AND operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, performs a boolean AND operation on each 
 bit of the 64-bit integers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#ldiv(java.lang.Object, java.lang.Object)">ldiv</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Divides the first 64-bit integer by the second 64-bit integer, casting the operands 
 to <tt>long</tt> numbers if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#leq(java.lang.Object, java.lang.Object)">leq</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two 64-bit integers are "equal", casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lgt(java.lang.Object, java.lang.Object)">lgt</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit greater-than operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the first 
 operand is greater than the second operand; otherwise it evaluates to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lgte(java.lang.Object, java.lang.Object)">lgte</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit greater-than-or-equal operation, casting the operands to <tt>long</tt> 
 numbers if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the 
 first operand is greater than or equal to the second operand; otherwise it evaluates 
 to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#llt(java.lang.Object, java.lang.Object)">llt</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit less-than operation, casting the operands to <tt>long</tt> numbers if 
 any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the first 
 operand is less than the second operand; otherwise it evaluates to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#llte(java.lang.Object, java.lang.Object)">llte</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit less-than-or-equal operation, casting the operands to <tt>long</tt> 
 numbers if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if 
 the first operand is less than or equal to the second operand; otherwise it evaluates 
 to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lmod(java.lang.Object, java.lang.Object)">lmod</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the first operand modulo the second operand, casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lmul(java.lang.Object, java.lang.Object)">lmul</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiplies the two 64-bit integer, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lneg(java.lang.Object)">lneg</A></B>(java.lang.Object&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs unary negation on a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lneq(java.lang.Object, java.lang.Object)">lneq</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two 64-bit integers are not "equal", casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lnot(java.lang.Object)">lnot</A></B>(java.lang.Object&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit bitwise-NOT operation, casting the operand to a <tt>long</tt> number 
 if it is not 64-bit, operates by reversing all bits in the 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lor(java.lang.Object, java.lang.Object)">lor</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit bitwise-OR operation, casting the operands to <tt>long</tt> numbers if 
 any one of them is not a 64-bit integer, performs a boolean OR operation on each bit 
 of the 64-bit integers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lshl(java.lang.Object, int)">lshl</A></B>(java.lang.Object&nbsp;var,
     int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit shift-left operation, casting the first operand to a <tt>long</tt> 
 number if it is not 64-bit, moves all bits in it to the left by the number of places 
 specified in the second operand, which should be an integer between 0 and 63.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lshr(java.lang.Object, int)">lshr</A></B>(java.lang.Object&nbsp;var,
     int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit shift-right operation, casting the first operand to a <tt>long</tt> 
 number if it is not 64-bit, moves all bits in it to the right by the number of 
 places specified in the second operand (an integer between 0 and 63).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lshru(java.lang.Object, int)">lshru</A></B>(java.lang.Object&nbsp;var,
      int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit shift-right-unsigned operation, casting the first operand to a 
 <tt>long</tt> number if it is not 64-bit, moves all bits in it to the right by the 
 number of places specified in the second operand (an integer between 0 and 63).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lsub(java.lang.Object, java.lang.Object)">lsub</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subtracts the second 64-bit integer from the first 64-bit integer, casting the 
 operands to <tt>long</tt> numbers if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lt(java.lang.Object, java.lang.Object)">lt</A></B>(java.lang.Object&nbsp;var,
   java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less-than operation, resembling that of JavaScript, evaluates to <tt>true</tt> if 
 the first operand is less than the second operand; otherwise it evaluates to 
 <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lte(java.lang.Object, java.lang.Object)">lte</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less-than-or-equal operation, resembling that of JavaScript, evaluates to 
 <tt>true</tt> if the first operand is less than or equal to the second operand; 
 otherwise it evaluates to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#lxor(java.lang.Object, java.lang.Object)">lxor</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit bitwise-XOR operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, performs a boolean exclusive OR operation 
 on each bit of the 64-bit integers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/MathLike.html" title="interface in js">MathLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#math()">math</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the math-like object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#mod(java.lang.Object, java.lang.Object)">mod</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the first operand modulo the second operand, resembling the modulo 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#mul(java.lang.Object, java.lang.Object)">mul</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiplies the two operands, resembling the multiplication operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#neg(java.lang.Object)">neg</A></B>(java.lang.Object&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs unary negation, resembling the unary minus operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#neq(java.lang.Object, java.lang.Object)">neq</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are not "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#neqs(java.lang.Object, java.lang.Object)">neqs</A></B>(java.lang.Object&nbsp;var,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are not "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#not(java.lang.Object)">not</A></B>(java.lang.Object&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inverts the boolean value of its operand, resembling the logical NOT operator 
 in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#number(java.lang.String)">number</A></B>(java.lang.String&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a number literal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#object()">object</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates and returns a newly created object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#object(java.lang.Object)">object</A></B>(java.lang.Object&nbsp;o)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts a value to an object and returns it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(java.lang.Boolean, js.core.JsBoolean)">or</A></B>(java.lang.Boolean&nbsp;var,
   <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(java.lang.Character, js.core.JsNumber)">or</A></B>(java.lang.Character&nbsp;var,
   <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.core.JsBoolean, java.lang.Boolean)">or</A></B>(<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;var,
   java.lang.Boolean&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.core.JsBoolean, js.Var)">or</A></B>(<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;var,
   <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Boolean&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.core.JsNumber, java.lang.Character)">or</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
   java.lang.Character&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.core.JsNumber, java.lang.Number)">or</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
   java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.core.JsNumber, js.Value)">or</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
   <A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Character&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.core.JsNumber, js.Var)">or</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
   <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.core.JsString, java.lang.String)">or</A></B>(<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;var,
   java.lang.String&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.core.JsString, js.Var)">or</A></B>(<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;var,
   <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.String&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(java.lang.Number, js.core.JsNumber)">or</A></B>(java.lang.Number&nbsp;var,
   <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(java.lang.String, js.core.JsString)">or</A></B>(java.lang.String&nbsp;var,
   <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(T, T)">or</A></B>(T&nbsp;var,
   T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(T, T)">or</A></B>(T&nbsp;var,
   T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(T, js.Var)">or</A></B>(T&nbsp;var,
   <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(T, js.Var)">or</A></B>(T&nbsp;var,
   <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.Value, js.core.JsNumber)">or</A></B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Character&gt;&nbsp;var,
   <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.Var, js.core.JsNumber)">or</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
   <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.Var, T)">or</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
   T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.Var, T)">or</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
   T&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.Var, js.Var)">or</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
   <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.Var, js.core.JsBoolean)">or</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Boolean&gt;&nbsp;var,
   <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#or(js.Var, js.core.JsString)">or</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.String&gt;&nbsp;var,
   <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#parseFloat(java.lang.Object)">parseFloat</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses a number from a string, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#parseInt(java.lang.Object)">parseInt</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses an integer from a string, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#parseInt(java.lang.Object, int)">parseInt</A></B>(java.lang.Object&nbsp;value,
         int&nbsp;radix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parses an integer from a string in a base specified, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#prompt(java.lang.Object)">prompt</A></B>(java.lang.Object&nbsp;message)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asks for simple string input with a dialog box, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#prompt(java.lang.Object, java.lang.Object)">prompt</A></B>(java.lang.Object&nbsp;message,
       java.lang.Object&nbsp;defaultInput)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Asks for simple string input with a dialog box, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/RegExpLike.html" title="interface in js">RegExpLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#re(java.lang.String)">re</A></B>(java.lang.String&nbsp;regex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a regular expression with the specified pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/RegExpLike.html" title="interface in js">RegExpLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#re(java.lang.String, java.lang.String)">re</A></B>(java.lang.String&nbsp;regex,
   java.lang.String&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a regular expression with the specified pattern and flags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#setInterval(js.core.JsFunction)">setInterval</A></B>(<A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;?&gt;&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes code at periodic intervals, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#setInterval(js.core.JsFunction, java.lang.Number)">setInterval</A></B>(<A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;?&gt;&nbsp;f,
            java.lang.Number&nbsp;interval)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes code at periodic intervals, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#setTimeout(js.core.JsFunction)">setTimeout</A></B>(<A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;?&gt;&nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes code after an amount of time elapses, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#setTimeout(js.core.JsFunction, java.lang.Number)">setTimeout</A></B>(<A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;?&gt;&nbsp;f,
           java.lang.Number&nbsp;delay)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes code after a specified amount of time elapses, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#shl(java.lang.Object, int)">shl</A></B>(java.lang.Object&nbsp;var,
    int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shift-left operation, resembling that of JavaScript, moves all bits in the first 
 operand to the left by the number of places specified in the second operand, which 
 should be an integer between 0 and 31.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#shr(java.lang.Object, int)">shr</A></B>(java.lang.Object&nbsp;var,
    int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shift-right operation, resembling that of JavaScript, moves all bits in the first 
 operand to the right by the number of places specified in the second operand (an 
 integer between 0 and 31).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#shru(java.lang.Object, int)">shru</A></B>(java.lang.Object&nbsp;var,
     int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shift-right-unsigned operation, resembling that of JavaScript, moves all bits in 
 the first operand to the right by the number of places specified in the second 
 operand (an integer between 0 and 31).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#sub(java.lang.Object, java.lang.Object)">sub</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subtracts the second operand from the first operand, resembling the modulo 
 operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#toString(java.lang.Object)">toString</A></B>(java.lang.Object&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string representation of a variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#typeof(java.lang.Object)">typeof</A></B>(java.lang.Object&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string indicating the data-type of the argument.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#undefined(java.lang.Object)">undefined</A></B>(java.lang.Object&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a variable is undefined.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#unescape(java.lang.Object)">unescape</A></B>(java.lang.Object&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decodes a string encoded with <A HREF="../js/Js.html#escape(java.lang.Object)"><CODE>escape(Object)</CODE></A>, 
 simulating the JavaScript global function of the same name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(js.ArrayLike)">valueOf</A></B>(<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;T&gt;&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.Boolean)">valueOf</A></B>(java.lang.Boolean&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.Byte)">valueOf</A></B>(java.lang.Byte&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.Character)">valueOf</A></B>(java.lang.Character&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(js.DateLike)">valueOf</A></B>(<A HREF="../js/DateLike.html" title="interface in js">DateLike</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.Double)">valueOf</A></B>(java.lang.Double&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.Float)">valueOf</A></B>(java.lang.Float&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(js.Function)">valueOf</A></B>(<A HREF="../js/Function.html" title="class in js">Function</A>&lt;T&gt;&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.Integer)">valueOf</A></B>(java.lang.Integer&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(js.core.JsBoolean)">valueOf</A></B>(<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(js.core.JsNumber)">valueOf</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(js.core.JsString)">valueOf</A></B>(<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.Long)">valueOf</A></B>(java.lang.Long&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.Number)">valueOf</A></B>(java.lang.Number&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends java.lang.Number&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(js.NumberLike)">valueOf</A></B>(<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;T&gt;&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.Object)">valueOf</A></B>(java.lang.Object&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.Short)">valueOf</A></B>(java.lang.Short&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(java.lang.String)">valueOf</A></B>(java.lang.String&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(js.StringLike)">valueOf</A></B>(<A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(T)">valueOf</A></B>(T&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#valueOf(js.Var)">valueOf</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;T&gt;&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the argument, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../js/user/JsWin.html" title="class in js.user">JsWin</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#win()">win</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Opaquely gets the JavaScript Global object with the client-side support.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Js.html#xor(java.lang.Object, java.lang.Object)">xor</A></B>(java.lang.Object&nbsp;var,
    java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bitwise-XOR operation, resembling that of JavaScript, performs a boolean exclusive 
 OR operation on each bit of the integer arguments.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Function"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../js/Function.html" title="class in js">Function</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Function.html#apply(java.lang.Object)">apply</A>, <A HREF="../js/Function.html#apply(java.lang.Object, java.lang.Object)">apply</A>, <A HREF="../js/Function.html#call(java.lang.Object)">call</A>, <A HREF="../js/Function.html#call(java.lang.Object, java.lang.Object)">call</A>, <A HREF="../js/Function.html#call(java.lang.Object, js.Vars)">call</A>, <A HREF="../js/Function.html#construct(java.lang.Object)">construct</A>, <A HREF="../js/Function.html#create()">create</A>, <A HREF="../js/Function.html#create(java.lang.Object)">create</A>, <A HREF="../js/Function.html#create(js.Vars)">create</A>, <A HREF="../js/Function.html#function(java.lang.Object, js.Function.Call)">function</A>, <A HREF="../js/Function.html#invoke()">invoke</A>, <A HREF="../js/Function.html#invoke(java.lang.Object)">invoke</A>, <A HREF="../js/Function.html#invoke(js.Vars)">invoke</A>, <A HREF="../js/Function.html#toString()">toString</A>, <A HREF="../js/Function.html#typeof()">typeof</A>, <A HREF="../js/Function.html#undefined()">undefined</A>, <A HREF="../js/Function.html#valueOf()">valueOf</A>, <A HREF="../js/Function.html#var()">var</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Var"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../js/Var.html" title="class in js">Var</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Var.html#equals(java.lang.Object)">equals</A>, <A HREF="../js/Var.html#hashCode()">hashCode</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsArray)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsBoolean)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsDate)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsFunction)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsNumber)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsRegExp)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsString)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.Var.Generic)">var</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Disposable"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../js/Disposable.html" title="class in js">Disposable</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Disposable.html#finalize()">finalize</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="init(js.Sim)"><!-- --></A><H3>
init</H3>
<PRE>
public static final void <B>init</B>(<A HREF="../js/Sim.html" title="class in js">Sim</A>&nbsp;sim)</PRE>
<DL>
<DD><p>An <b>internal</b> method only called internally in <A HREF="../js/Js.html#init(js.Sim)"><CODE>init(Sim)</CODE></A> to 
 initialize JS Simulation and JS developers must follow this rule to ensure the 
 class <A HREF="../js/Sim.html" title="class in js"><CODE>Sim</CODE></A> and its subclasses invisible to JS re-compilers which start 
 processing at <A HREF="../js/JsApplet.html#onReady()"><CODE>JsApplet.onReady()</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must report error on the invocation to an <b>internal</b> method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="debug()"><!-- --></A><H3>
debug</H3>
<PRE>
public static final boolean <B>debug</B>()</PRE>
<DL>
<DD><p>Opaquely tells whether the current running environment is JS Simulation (debug mode) 
 or JavaScript (re-compiled).</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> if the current program is running with JS Simulation 
 (in debug mode); <tt>false</tt> otherwise.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method and simply 
 replace it with a boolean <tt>false</tt> value.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="core()"><!-- --></A><H3>
core</H3>
<PRE>
public static final <A HREF="../js/core/JsGlobal.html" title="class in js.core">JsGlobal</A> <B>core</B>()</PRE>
<DL>
<DD><p>Opaquely gets the JavaScript Global object with the core support only.</p>
 <p>This method exists for the efficiency of small tests.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The JavaScript Global object with the core support only.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#win()"><CODE>win()</CODE></A>, 
<A HREF="../jsx/client/Global.html" title="class in jsx.client"><CODE>Global</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method and simply 
 replace it with the expression: 
 <pre>window</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="win()"><!-- --></A><H3>
win</H3>
<PRE>
public static final <A HREF="../js/user/JsWin.html" title="class in js.user">JsWin</A> <B>win</B>()</PRE>
<DL>
<DD><p>Opaquely gets the JavaScript Global object with the client-side support.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The JavaScript Global object with the client-side support.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#core()"><CODE>core()</CODE></A>, 
<A HREF="../jsx/client/Client.html" title="class in jsx.client"><CODE>Client</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method and simply 
 replace it with the expression: 
 <pre>window</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="alert(java.lang.Object)"><!-- --></A><H3>
alert</H3>
<PRE>
public static final void <B>alert</B>(java.lang.Object&nbsp;message)</PRE>
<DL>
<DD><p>Displays a simple message in a dialog box, 
 simulating the JavaScript global function of the same name.</p>
 <p>In JavaScript, this method displays the specified <tt>message</tt> to the 
 user in a dialog box. The dialog box contains an OK button the user can click to 
 dismiss it. The dialog box is typically modal, and the call to this function 
 typically blocks until the dialog is dismissed.</p>
 <p>Perhaps the most common use of this method is to display error messages when the 
 user's input to some form element is invalid in some way. The alert dialog box can 
 inform the user of the problem and explain what needs to be corrected to avoid the 
 problem in the future</p>
 <p>The appearance of the dialog box is platform-dependent, but it generally contains 
 graphics that indicate an error, warning, or alert message of some kind. While it can 
 display any desired message, the alert graphics of the dialog box mean that this 
 method is not appropriate for simple informational messages like "Welcome to my blog"</p>
 <p>Note that the <tt>message</tt> displayed in the dialog box is a string of 
 plain text, not formatted HTML. You can use the newline character "\n" in your strings 
 to break your message across multiple lines. You can also do some rudimentary 
 formatting using spaces and can approximate horizontal rules with underscore characters, 
 but the results depend greatly on the font used in the dialog box and thus are 
 system-dependent.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>message</CODE> - The plain-text (not HTML) string to display in a dialog box popped up 
 over the current window.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../jsx/client/Global.html#alert(java.lang.Object)"><CODE>Global.alert(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#alert(java.lang.Object)"><CODE>Global.alert(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="confirm(java.lang.Object)"><!-- --></A><H3>
confirm</H3>
<PRE>
public static final boolean <B>confirm</B>(java.lang.Object&nbsp;question)</PRE>
<DL>
<DD><p>Asks a yes-or-no question with a dialog box, 
 simulating the JavaScript global function of the same name.</p>
 <p>In JavaScript, this method displays the specified question in a dialog box. The 
 dialog box contains OK and Cancel buttons that the user can use to answer the 
 question. If the user clicks the OK button, it returns <tt>true</tt>. If the 
 user clicks Cancel, it returns <tt>false</tt>.</p>
 <p>The dialog box that is displayed by the this method is modal. That is, it blocks 
 all user input to the main browser window until the user dismisses the dialog box 
 by clicking on the OK or Cancel buttons. Since this method returns a value depending 
 on the user's response to the dialog box, JavaScript execution pauses in the call to 
 this method, and subsequent statements are not executed until the user responds to 
 the dialog box.</p>
 <p>There is no way to change the labels that appear in the buttons of the dialog box 
 (to make them read Yes and No, for example). Therefore, you should take care to 
 phrase your question or message so that OK and Cancel are suitable responses.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>question</CODE> - The plain-text (not HTML) string to be displayed in the dialog box. 
 It should generally express a question you want the user to answer.
<DT><B>Returns:</B><DD><tt>true</tt> if the user clicks the OK button; <tt>false</tt> if 
 the user clicks the Cancel button.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../jsx/client/Global.html#confirm(java.lang.Object)"><CODE>Global.confirm(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#confirm(java.lang.Object)"><CODE>Global.confirm(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="prompt(java.lang.Object)"><!-- --></A><H3>
prompt</H3>
<PRE>
public static final java.lang.String <B>prompt</B>(java.lang.Object&nbsp;message)</PRE>
<DL>
<DD><p>Asks for simple string input with a dialog box, 
 simulating the JavaScript global function of the same name.</p>
 <p>This method displays text input field and OK and Cancel buttons in a dialog box. 
 Platform-dependent graphics in the dialog box help indicate to the user that an 
 input is desired.</p>
 <p>If the user clicks the Cancel button, the method returns <tt>null</tt>. If 
 the user clicks the OK button, it returns the text currently displayed in the 
 input field.</p>
 <p>The dialog box that is displayed by this method is modal. That is, it blocks all 
 user input to the main browser window until the user dismisses the dialog box by 
 clicking on the OK or Cancel buttons. Since this method returns a value depending 
 on the user's response to the dialog box, JavaScript execution pauses in the call 
 to this method, and subsequent statements are not executed until the user responds 
 to the dialog box.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>message</CODE> - The plain-text (not HTML) string to be displayed in the dialog box. 
 It should ask the user to enter the information you want.
<DT><B>Returns:</B><DD>The string entered by the user, the empty string if the user did not enter 
 a string, or <tt>null</tt> if the user clicked Cancel.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#prompt(java.lang.Object, java.lang.Object)"><CODE>prompt(Object, Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#prompt(java.lang.Object)"><CODE>Global.prompt(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#prompt(java.lang.Object)"><CODE>Global.prompt(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="prompt(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
prompt</H3>
<PRE>
public static final java.lang.String <B>prompt</B>(java.lang.Object&nbsp;message,
                                            java.lang.Object&nbsp;defaultInput)</PRE>
<DL>
<DD><p>Asks for simple string input with a dialog box, 
 simulating the JavaScript global function of the same name.</p>
 <p>This method displays the specified message in a dialog box that also contains a 
 text input field and OK and Cancel buttons. Platform-dependent graphics in the 
 dialog box help indicate to the user that an input is desired.</p>
 <p>If the user clicks the Cancel button, the method returns <tt>null</tt>. If 
 the user clicks the OK button, it returns the text currently displayed in the 
 input field.</p>
 <p>The dialog box that is displayed by this method is modal. That is, it blocks all 
 user input to the main browser window until the user dismisses the dialog box by 
 clicking on the OK or Cancel buttons. Since this method returns a value depending 
 on the user's response to the dialog box, JavaScript execution pauses in the call 
 to this method, and subsequent statements are not executed until the user responds 
 to the dialog box.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>message</CODE> - The plain-text (not HTML) string to be displayed in the dialog box. 
 It should ask the user to enter the information you want.<DD><CODE>defaultInput</CODE> - A string that is displayed as the default input in the dialog 
 box. Pass the empty string ("") to make the method display an empty input box.
<DT><B>Returns:</B><DD>The string entered by the user, the empty string if the user did not enter 
 a string, or <tt>null</tt> if the user clicked Cancel.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#prompt(java.lang.Object)"><CODE>prompt(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#prompt(java.lang.Object, java.lang.Object)"><CODE>Global.prompt(Object, Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#prompt(java.lang.Object, java.lang.Object)"><CODE>Global.prompt(Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearInterval(java.lang.Object)"><!-- --></A><H3>
clearInterval</H3>
<PRE>
public static final void <B>clearInterval</B>(java.lang.Object&nbsp;intervalId)</PRE>
<DL>
<DD><p>Cancels periodic execution of code, 
 simulating the JavaScript global function of the same name.</p>
 <p>This method stops the repeated execution of code that was started by a call to 
 <A HREF="../js/Js.html#setInterval(js.core.JsFunction, java.lang.Number)"><CODE>setInterval(JsFunction, Number)</CODE></A>. <tt>intervalId</tt> must be the value 
 that was returned by a call to <A HREF="../js/Js.html#setInterval(js.core.JsFunction, java.lang.Number)"><CODE>setInterval(JsFunction, Number)</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>intervalId</CODE> - The value returned by the corresponding call to <A HREF="../js/Js.html#setInterval(js.core.JsFunction, java.lang.Number)"><CODE>setInterval(JsFunction, Number)</CODE></A>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#setInterval(js.core.JsFunction, java.lang.Number)"><CODE>setInterval(JsFunction, Number)</CODE></A>, 
<A HREF="../jsx/client/Global.html#clearInterval(java.lang.Object)"><CODE>Global.clearInterval(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#clearInterval(java.lang.Object)"><CODE>Global.clearInterval(Object)</CODE></A>, 
<A HREF="../jsx/Interval.html" title="class in jsx"><CODE>Interval</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearTimeout(java.lang.Object)"><!-- --></A><H3>
clearTimeout</H3>
<PRE>
public static final void <B>clearTimeout</B>(java.lang.Object&nbsp;timeoutId)</PRE>
<DL>
<DD><p>Cancels a pending timeout operation, 
 simulating the JavaScript global function of the same name.</p>
 <p>This method cancels the execution of code that has been deferred with the 
 <A HREF="../js/Js.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>setTimeout(JsFunction, Number)</CODE></A> method. The <tt>timeoutId</tt> argument 
 is a value returned by the call to <A HREF="../js/Js.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>setTimeout(JsFunction, Number)</CODE></A> and 
 identifies which deferred code to cancel.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeoutId</CODE> - A value returned by <A HREF="../js/Js.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>setTimeout(JsFunction, Number)</CODE></A> that 
 identifies the timeout to be canceled.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#setTimeout(js.core.JsFunction)"><CODE>setTimeout(JsFunction)</CODE></A>, 
<A HREF="../js/Js.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>setTimeout(JsFunction, Number)</CODE></A>, 
<A HREF="../jsx/client/Global.html#clearTimeout(java.lang.Object)"><CODE>Global.clearTimeout(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#clearTimeout(java.lang.Object)"><CODE>Global.clearTimeout(Object)</CODE></A>, 
<A HREF="../jsx/Timeout.html" title="class in jsx"><CODE>Timeout</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setInterval(js.core.JsFunction, java.lang.Number)"><!-- --></A><H3>
setInterval</H3>
<PRE>
public static final java.lang.Object <B>setInterval</B>(<A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;?&gt;&nbsp;f,
                                                 java.lang.Number&nbsp;interval)</PRE>
<DL>
<DD><p>Executes code at periodic intervals, 
 simulating the JavaScript global function of the same name.</p>
 <p>Note that the specified function is executed in the context of the Window object, 
 that is, the Window object is the value of the <tt>this</tt> keyword of the 
 executing context of the function. This is <tt>true</tt> even if the call to 
 <A HREF="../js/Js.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>setTimeout(JsFunction, Number)</CODE></A> occurred within a function with a longer 
 scope chain.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - A function to be periodically invoked.<DD><CODE>interval</CODE> - The interval, in milliseconds, between invocations of the function.
<DT><B>Returns:</B><DD>A value that can be passed to <A HREF="../js/Js.html#clearInterval(java.lang.Object)"><CODE>clearInterval(Object)</CODE></A> method to 
 cancel the periodic execution of the function.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#setInterval(js.core.JsFunction)"><CODE>setInterval(JsFunction)</CODE></A>, 
<A HREF="../js/Js.html#clearInterval(java.lang.Object)"><CODE>clearInterval(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setInterval(js.core.JsFunction)"><CODE>Global.setInterval(JsFunction)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setInterval(js.core.JsFunction, java.lang.Number)"><CODE>Global.setInterval(JsFunction, Number)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setInterval(js.core.JsFunction)"><CODE>Global.setInterval(JsFunction)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setInterval(js.core.JsFunction, java.lang.Number)"><CODE>Global.setInterval(JsFunction, Number)</CODE></A>, 
<A HREF="../jsx/Interval.html" title="class in jsx"><CODE>Interval</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setInterval(js.core.JsFunction)"><!-- --></A><H3>
setInterval</H3>
<PRE>
public static final java.lang.Object <B>setInterval</B>(<A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;?&gt;&nbsp;f)</PRE>
<DL>
<DD><p>Executes code at periodic intervals, 
 simulating the JavaScript global function of the same name.</p>
 <p>Note that the specified function is executed in the context of the Window object, 
 that is, the Window object is the value of the <tt>this</tt> keyword of the 
 executing context of the function. This is <tt>true</tt> even if the call to 
 <A HREF="../js/Js.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>setTimeout(JsFunction, Number)</CODE></A> occurred within a function with a longer 
 scope chain.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - A function to be periodically invoked.
<DT><B>Returns:</B><DD>A value that can be passed to <A HREF="../js/Js.html#clearInterval(java.lang.Object)"><CODE>clearInterval(Object)</CODE></A> method to 
 cancel the periodic execution of the function.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#setInterval(js.core.JsFunction, java.lang.Number)"><CODE>setInterval(JsFunction, Number)</CODE></A>, 
<A HREF="../js/Js.html#clearInterval(java.lang.Object)"><CODE>clearInterval(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setInterval(js.core.JsFunction)"><CODE>Global.setInterval(JsFunction)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setInterval(js.core.JsFunction, java.lang.Number)"><CODE>Global.setInterval(JsFunction, Number)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setInterval(js.core.JsFunction)"><CODE>Global.setInterval(JsFunction)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setInterval(js.core.JsFunction, java.lang.Number)"><CODE>Global.setInterval(JsFunction, Number)</CODE></A>, 
<A HREF="../jsx/Interval.html" title="class in jsx"><CODE>Interval</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript invocation:
 <pre>setInterval(f, 10)</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTimeout(js.core.JsFunction, java.lang.Number)"><!-- --></A><H3>
setTimeout</H3>
<PRE>
public static final java.lang.Object <B>setTimeout</B>(<A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;?&gt;&nbsp;f,
                                                java.lang.Number&nbsp;delay)</PRE>
<DL>
<DD><p>Executes code after a specified amount of time elapses, 
 simulating the JavaScript global function of the same name.</p>
 <p>Note that this method executes the specified function only once. The function is 
 executed in the context of the Window object, that is, the Window object is the 
 value of the <tt>this</tt> keyword of the executing context of the function. 
 This is <tt>true</tt> even if the call to <A HREF="../js/Js.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>setTimeout(JsFunction, Number)</CODE></A> 
 occurred within a function with a longer scope chain.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - A function to be invoked after the <tt>delay</tt> has elapsed.<DD><CODE>delay</CODE> - The amount of time, in milliseconds, before the function should be executed.
<DT><B>Returns:</B><DD>A value that can be passed to the <A HREF="../js/Js.html#clearTimeout(java.lang.Object)"><CODE>clearTimeout(Object)</CODE></A> method to 
 cancel the execution of the function.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#setTimeout(js.core.JsFunction)"><CODE>setTimeout(JsFunction)</CODE></A>, 
<A HREF="../js/Js.html#clearTimeout(java.lang.Object)"><CODE>clearTimeout(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setTimeout(js.core.JsFunction)"><CODE>Global.setTimeout(JsFunction)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>Global.setTimeout(JsFunction, Number)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setTimeout(js.core.JsFunction)"><CODE>Global.setTimeout(JsFunction)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>Global.setTimeout(JsFunction, Number)</CODE></A>, 
<A HREF="../jsx/Timeout.html" title="class in jsx"><CODE>Timeout</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTimeout(js.core.JsFunction)"><!-- --></A><H3>
setTimeout</H3>
<PRE>
public static final java.lang.Object <B>setTimeout</B>(<A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;?&gt;&nbsp;f)</PRE>
<DL>
<DD><p>Executes code after an amount of time elapses, 
 simulating the JavaScript global function of the same name.</p>
 <p>Note that this method executes the specified function only once. The function is 
 executed in the context of the Window object, that is, the Window object is the 
 value of the <tt>this</tt> keyword of the executing context of the function. 
 This is <tt>true</tt> even if the call to <A HREF="../js/Js.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>setTimeout(JsFunction, Number)</CODE></A> 
 occurred within a function with a longer scope chain.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>f</CODE> - A function to be invoked after the <tt>delay</tt> has elapsed.
<DT><B>Returns:</B><DD>A value that can be passed to the <A HREF="../js/Js.html#clearTimeout(java.lang.Object)"><CODE>clearTimeout(Object)</CODE></A> method to 
 cancel the execution of the function.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>setTimeout(JsFunction, Number)</CODE></A>, 
<A HREF="../js/Js.html#clearTimeout(java.lang.Object)"><CODE>clearTimeout(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setTimeout(js.core.JsFunction)"><CODE>Global.setTimeout(JsFunction)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>Global.setTimeout(JsFunction, Number)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setTimeout(js.core.JsFunction)"><CODE>Global.setTimeout(JsFunction)</CODE></A>, 
<A HREF="../jsx/client/Global.html#setTimeout(js.core.JsFunction, java.lang.Number)"><CODE>Global.setTimeout(JsFunction, Number)</CODE></A>, 
<A HREF="../jsx/Timeout.html" title="class in jsx"><CODE>Timeout</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript invocation:
 <pre>setTimeout(f, 10)</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="decodeURI(java.lang.Object)"><!-- --></A><H3>
decodeURI</H3>
<PRE>
public static final java.lang.String <B>decodeURI</B>(java.lang.Object&nbsp;s)</PRE>
<DL>
<DD><p>Decodes a string escaped with <A HREF="../js/Js.html#encodeURI(java.lang.Object)"><CODE>encodeURI(Object)</CODE></A>, 
 simulating the JavaScript global function of the same name.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - A string that contains an encoded URI or other text to be decoded.
<DT><B>Returns:</B><DD>A copy of <tt>s</tt>, with any hexadecimal escape sequences replaced with 
 the characters they represent.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>URIError</tt> if one or more of the 
 escape sequences in <tt>s</tt> is malformed and cannot be correctly decoded. See 
 <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>err(Object)</CODE></A> and <A HREF="../js/core/JsURIError.html" title="class in js.core"><CODE>JsURIError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#encodeURI(java.lang.Object)"><CODE>encodeURI(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#decodeURI(java.lang.Object)"><CODE>Global.decodeURI(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#decodeURI(java.lang.Object)"><CODE>Global.decodeURI(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="decodeURIComponent(java.lang.Object)"><!-- --></A><H3>
decodeURIComponent</H3>
<PRE>
public static final java.lang.String <B>decodeURIComponent</B>(java.lang.Object&nbsp;s)</PRE>
<DL>
<DD><p>Decodes a string escaped with <A HREF="../js/Js.html#encodeURIComponent(java.lang.Object)"><CODE>encodeURIComponent(Object)</CODE></A>, 
 simulating the JavaScript global function of the same name.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - A string that contains an encoded URI component or other text to be decoded.
<DT><B>Returns:</B><DD>A copy of <tt>s</tt>, with any hexadecimal escape sequences replaced 
 with the characters they represent.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>URIError</tt> if one or more of the 
 escape sequences in <tt>s</tt> is malformed and cannot be correctly decoded. See 
 <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>err(Object)</CODE></A> and <A HREF="../js/core/JsURIError.html" title="class in js.core"><CODE>JsURIError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#encodeURIComponent(java.lang.Object)"><CODE>encodeURIComponent(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#decodeURIComponent(java.lang.Object)"><CODE>Global.decodeURIComponent(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#decodeURIComponent(java.lang.Object)"><CODE>Global.decodeURIComponent(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="encodeURI(java.lang.Object)"><!-- --></A><H3>
encodeURI</H3>
<PRE>
public static final java.lang.String <B>encodeURI</B>(java.lang.Object&nbsp;uri)</PRE>
<DL>
<DD><p>Encodes a URI by escaping certain characters, 
 simulating the JavaScript global function of the same name.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>uri</CODE> - A string that contains the URI or other text to be encoded.
<DT><B>Returns:</B><DD>A copy of <tt>uri</tt>, with any hexadecimal escape sequences replaced 
 with the characters they represent..
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>URIError</tt> if <tt>s</tt> 
 contains malformed unicode surrogate pairs and cannot be encoded. See 
 <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>err(Object)</CODE></A> and <A HREF="../js/core/JsURIError.html" title="class in js.core"><CODE>JsURIError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#decodeURI(java.lang.Object)"><CODE>decodeURI(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#encodeURI(java.lang.Object)"><CODE>Global.encodeURI(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#encodeURI(java.lang.Object)"><CODE>Global.encodeURI(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="encodeURIComponent(java.lang.Object)"><!-- --></A><H3>
encodeURIComponent</H3>
<PRE>
public static final java.lang.String <B>encodeURIComponent</B>(java.lang.Object&nbsp;uri)</PRE>
<DL>
<DD><p>Encodes a URI component by escaping certain characters, 
 simulating the JavaScript global function of the same name.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>uri</CODE> - A string that contains a portion of a URI or other text to be encoded.
<DT><B>Returns:</B><DD>A copy of <tt>uri</tt>, with certain characters replaced by hexadecimal escape sequences.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>URIError</tt> if <tt>s</tt> 
 contains malformed unicode surrogate pairs and cannot be encoded. See 
 <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>err(Object)</CODE></A> and <A HREF="../js/core/JsURIError.html" title="class in js.core"><CODE>JsURIError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#decodeURIComponent(java.lang.Object)"><CODE>decodeURIComponent(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#encodeURIComponent(java.lang.Object)"><CODE>Global.encodeURIComponent(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#encodeURIComponent(java.lang.Object)"><CODE>Global.encodeURIComponent(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="escape(java.lang.Object)"><!-- --></A><H3>
escape</H3>
<PRE>
public static final java.lang.String <B>escape</B>(java.lang.Object&nbsp;s)</PRE>
<DL>
<DD><p>Encodes a string by replacing certain characters with escape sequences, 
 simulating the JavaScript global function of the same name.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The string that is to be "escaped" or encoded.
<DT><B>Returns:</B><DD>An encoded copy of <tt>s</tt> in which certain characters have been 
 replaced by hexadecimal escape sequences.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#unescape(java.lang.Object)"><CODE>unescape(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#escape(java.lang.Object)"><CODE>Global.escape(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#escape(java.lang.Object)"><CODE>Global.escape(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="unescape(java.lang.Object)"><!-- --></A><H3>
unescape</H3>
<PRE>
public static final java.lang.String <B>unescape</B>(java.lang.Object&nbsp;s)</PRE>
<DL>
<DD><p>Decodes a string encoded with <A HREF="../js/Js.html#escape(java.lang.Object)"><CODE>escape(Object)</CODE></A>, 
 simulating the JavaScript global function of the same name.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The string that is to be decoded or "unescaped".
<DT><B>Returns:</B><DD>A decoded copy of <tt>s</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#escape(java.lang.Object)"><CODE>escape(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#unescape(java.lang.Object)"><CODE>Global.unescape(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#unescape(java.lang.Object)"><CODE>Global.unescape(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="eval(java.lang.Object)"><!-- --></A><H3>
eval</H3>
<PRE>
public static final java.lang.Object <B>eval</B>(java.lang.Object&nbsp;s)</PRE>
<DL>
<DD><p>Evaluates the argument string as JavaScript code and returns the result, 
 simulating the JavaScript global function of the same name.</p>
 <p>In JavaScript, <tt>eval()</tt> is a global method that evaluates a string of 
 JavaScript code in the current lexical scope. If the code contains an expression, 
 eval evaluates the expression and returns its value. If the code contains a 
 JavaScript statement or statements, it executes those statements and returns the 
 value, if any, returned by the last statement. If the code does not return any 
 value, <tt>eval()</tt> returns undefined. Finally, if code throws an exception, 
 <tt>eval()</tt> passes that exception on to the caller.</p>
 <p>The global function <tt>eval()</tt> provides a very powerful capability to 
 the JavaScript language, but its use is infrequent in real-world programs. 
 Obvious uses are to write programs that act as recursive JavaScript interpreters 
 and to write programs that dynamically generate and evaluate JavaScript code.</p>
 <p>Most JavaScript functions and methods that expect string arguments accept 
 arguments of other types as well and simply convert those argument values to 
 strings before proceeding. <tt>eval()</tt> does not behave like this. If the 
 code argument is not a primitive string, it is simply returned unchanged. Be 
 careful, therefore, that you do not inadvertently pass a String object to 
 <tt>eval()</tt> when you intended to pass a primitive string value.</p>
 <p>For purposes of implementation efficiency, the ECMAScript v3 standard places 
 an unusual restriction on the use of <tt>eval()</tt>. An ECMAScript implementation 
 is allowed to throw an <tt>EvalError</tt> exception if you attempt to overwrite 
 the <tt>eval</tt> property or if you assign the <tt>eval()</tt> method to another 
 property and attempt to invoke it through that property.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - A string of JavaScript code.
<DT><B>Returns:</B><DD>The return value of the evaluated code, if any.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>SyntaxError</tt> if the argument string 
 does not contain legal JavaScript, a <tt>EvalError</tt> if the <tt>eval</tt> function 
 was called illegally, through an identifier other than "eval", or other JavaScript error 
 generated by the code passed. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>err(Object)</CODE></A>, <A HREF="../js/core/JsSyntaxError.html" title="class in js.core"><CODE>JsSyntaxError</CODE></A>, 
 <A HREF="../js/core/JsEvalError.html" title="class in js.core"><CODE>JsEvalError</CODE></A>, and <A HREF="../js/core/JsError.html" title="class in js.core"><CODE>JsError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isFinite(java.lang.Object)"><!-- --></A><H3>
isFinite</H3>
<PRE>
public static final boolean <B>isFinite</B>(java.lang.Object&nbsp;v)</PRE>
<DL>
<DD><p>Tests whether a value is a finite number, 
 simulating the JavaScript global function of the same name.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The number to be tested.
<DT><B>Returns:</B><DD><tt>true</tt> if <tt>v</tt> is (or can be converted to) a finite 
 number, or <tt>false</tt> if <tt>v</tt> is <tt>NaN</tt> (not a number) 
 or positive or negative infinity.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../jsx/client/Global.html#isFinite(java.lang.Object)"><CODE>Global.isFinite(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#isFinite(java.lang.Object)"><CODE>Global.isFinite(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isNaN(java.lang.Object)"><!-- --></A><H3>
isNaN</H3>
<PRE>
public static final boolean <B>isNaN</B>(java.lang.Object&nbsp;v)</PRE>
<DL>
<DD><p>Tests whether a value is the not-a-number value, 
 simulating the JavaScript global function of the same name.</p>
 <p>In JavaScript, This function tests its argument to determine whether it is the 
 value <tt>NaN</tt>, which represents an illegal number (such as the result of 
 division by zero). This function is required because comparing a <tt>NaN</tt> 
 with any value, including itself, always returns <tt>false</tt>, so it is not 
 possible to test for <tt>NaN</tt> with the == or === operators.</p>
 <p>A common use in JavaScript of this function is to test the results of <A HREF="../js/Js.html#parseFloat(java.lang.Object)"><CODE>parseFloat(Object)</CODE></A> 
 and <A HREF="../js/Js.html#parseInt(java.lang.Object)"><CODE>parseInt(Object)</CODE></A> to determine if they represent legal numbers. You can 
 also use <A HREF="../js/Js.html#isNaN(java.lang.Object)"><CODE>isNaN(Object)</CODE></A> to check for arithmetic errors, such as division by 
 zero</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The value to be tested.
<DT><B>Returns:</B><DD><tt>true</tt> if <tt>v</tt> is (or can be converted to) the special 
 not-a-number value; <tt>false</tt> if <tt>v</tt> is any other value.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../jsx/client/Global.html#isNaN(java.lang.Object)"><CODE>Global.isNaN(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#isNaN(java.lang.Object)"><CODE>Global.isNaN(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="parseInt(java.lang.Object)"><!-- --></A><H3>
parseInt</H3>
<PRE>
public static final java.lang.Integer <B>parseInt</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Parses an integer from a string, 
 simulating the JavaScript global function of the same name.</p>
 <p>In JavaScript, this function parses and returns the first number (with an 
 optional leading minus sign) that occurs in <tt>value</tt>. Parsing stops, and 
 the value is returned, when it encounters a character in <tt>value</tt> that is 
 not a valid digit for the specified radix. If <tt>value</tt> does not begin with 
 a number that it can parse, the function returns the not-a-number value <tt>NaN</tt>. 
 Use the <A HREF="../js/Js.html#isNaN(java.lang.Object)"><CODE>isNaN(Object)</CODE></A> function to test for this return value.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - The string to be parsed.
<DT><B>Returns:</B><DD>The parsed number, or <tt>NaN</tt> if <tt>value</tt> does not begin with 
 a valid integer. In JavaScript 1.0, this function returns 0 instead of <tt>NaN</tt> 
 when it cannot parse <tt>value</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#parseFloat(java.lang.Object)"><CODE>parseFloat(Object)</CODE></A>, 
<A HREF="../js/Js.html#parseInt(java.lang.Object, int)"><CODE>parseInt(Object, int)</CODE></A>, 
<A HREF="../jsx/client/Global.html#parseInt(java.lang.Object)"><CODE>Global.parseInt(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#parseInt(java.lang.Object)"><CODE>Global.parseInt(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="parseInt(java.lang.Object, int)"><!-- --></A><H3>
parseInt</H3>
<PRE>
public static final java.lang.Integer <B>parseInt</B>(java.lang.Object&nbsp;value,
                                               int&nbsp;radix)</PRE>
<DL>
<DD><p>Parses an integer from a string in a base specified, 
 simulating the JavaScript global function of the same name.</p>
 <p>In JavaScript, this function parses and returns the first number (with an 
 optional leading minus sign) that occurs in <tt>value</tt>. Parsing stops, and 
 the value is returned, when it encounters a character in <tt>value</tt> that is 
 not a valid digit for the specified radix. If <tt>value</tt> does not begin with 
 a number that it can parse, the function returns the not-a-number value <tt>NaN</tt>. 
 Use the <A HREF="../js/Js.html#isNaN(java.lang.Object)"><CODE>isNaN(Object)</CODE></A> function to test for this return value.</p>
 <p>The <tt>radix</tt> argument specifies the base of the number to be parsed. 
 Specifying 10 makes this function parse a decimal number. The value 8 specifies that 
 an octal number (using digits 0 through 7) is to be parsed. The value 16 specifies 
 a hexadecimal value, using digits 0 through 9 and letters A through F. <tt>radix</tt> 
 can be any value between 2 and 36.</p>
 <p>If <tt>radix</tt> is 0 or is undefined, this function tries to determine the 
 radix of the number from <tt>value</tt>. If <tt>value</tt> begins (after an 
 optional minus sign) with 0x, it parses the remainder of <tt>value</tt> as a 
 hexadecimal number. If <tt>value</tt> begins with a 0, the ECMAScript v3 standard 
 allows an implementation of this function to interpret the following characters as 
 an octal number or as a decimal number. Otherwise, if <tt>value</tt> begins with 
 a digit from 1 through 9, it parses it as a decimal number</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - The string to be parsed.<DD><CODE>radix</CODE> - An optional integer argument that represents the radix (or base) of the 
 number to be parsed. If this argument is undefined or is 0, the number is parsed in 
 base 10 or in base 16 if it begins with 0x or 0X. If this argument is less than 2 or 
 greater than 36, <tt>NaN</tt> is returned.
<DT><B>Returns:</B><DD>The parsed number, or <tt>NaN</tt> if <tt>value</tt> does not begin with 
 a valid integer. In JavaScript 1.0, this function returns 0 instead of <tt>NaN</tt> 
 when it cannot parse <tt>value</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#parseInt(java.lang.Object)"><CODE>parseInt(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#parseInt(java.lang.Object, int)"><CODE>Global.parseInt(Object, int)</CODE></A>, 
<A HREF="../jsx/client/Global.html#parseInt(java.lang.Object, int)"><CODE>Global.parseInt(Object, int)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="parseFloat(java.lang.Object)"><!-- --></A><H3>
parseFloat</H3>
<PRE>
public static final java.lang.Double <B>parseFloat</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Parses a number from a string, 
 simulating the JavaScript global function of the same name.</p>
 <p>In JavaScript, this function parses and returns the first number that occurs in 
 <tt>value</tt>. Parsing stops, and the value is returned, when it encounters a 
 character in <tt>value</tt> that is not a valid part of the number. If <tt>value</tt> 
 does not begin with a number that it can parse, the function returns the not-a-number 
 value <tt>NaN</tt>. Test for this return value with the <A HREF="../js/Js.html#isNaN(java.lang.Object)"><CODE>isNaN(Object)</CODE></A> 
 function. If you want to parse only the integer portion of a number, use <A HREF="../js/Js.html#parseInt(java.lang.Object)"><CODE>parseInt(Object)</CODE></A> 
 or <A HREF="../js/Js.html#parseInt(java.lang.Object, int)"><CODE>parseInt(Object, int)</CODE></A> instead of this one.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - The string to be parsed and converted to a number.
<DT><B>Returns:</B><DD>The parsed number, or <tt>NaN</tt> if <tt>value</tt> does not begin 
 with a valid number. In JavaScript 1.0, this function returns 0 instead of <tt>NaN</tt> 
 when <tt>value</tt> cannot be parsed as a number.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#parseInt(java.lang.Object)"><CODE>parseInt(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#parseFloat(java.lang.Object)"><CODE>Global.parseFloat(Object)</CODE></A>, 
<A HREF="../jsx/client/Global.html#parseFloat(java.lang.Object)"><CODE>Global.parseFloat(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the static invocation of this method directly into 
 a JavaScript invocation on the default object (<tt>window</tt>) without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cases()"><!-- --></A><H3>
cases</H3>
<PRE>
public static final <A HREF="../js/Cases.html" title="interface in js">Cases</A> <B>cases</B>()</PRE>
<DL>
<DD><p>Creates and return a <tt>Cases</tt> cache.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The newly created <tt>Cases</tt> cache.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must, on the static invocation of this method, create a new 
 re-compile time <tt>Cases</tt> cache, without generating any JavaScript statement 
 in the target codes.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="keys(js.ObjectLike)"><!-- --></A><H3>
keys</H3>
<PRE>
public static final <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.String&gt; <B>keys</B>(<A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A>&nbsp;o)</PRE>
<DL>
<DD><p>Gets the list of the property names of an object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o</CODE> - The object.
<DT><B>Returns:</B><DD>The list of the property names of the object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript invocation:
 <pre>keys(o)</pre>
 of a common JavaScript function like:
 <pre>function keys(o) {
  var keys = [];
  for (k in o) {
    keys.put(k);
  }
  return keys;
}</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="apply(js.ObjectLike, js.ObjectLike)"><!-- --></A><H3>
apply</H3>
<PRE>
public static final <A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A> <B>apply</B>(<A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A>&nbsp;o,
                                     <A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A>&nbsp;a)</PRE>
<DL>
<DD><p>Copies all the properties of <tt>a</tt> to <tt>o</tt>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o</CODE> - The object that the properties being copied to.<DD><CODE>a</CODE> - The object that the properties being copied from.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace this static invocation of this method with the 
 JavaScript invocation:
 <pre>copy(o, a)</pre>
 of a common JavaScript function like:
 <pre>function copy(o, a) {
  for (k in o) {
    o[k] = a[k];
  }
  return o;
}</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="function()"><!-- --></A><H3>
function</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt; <B>function</B>()</PRE>
<DL>
<DD><p>Creates an empty JavaScript function.</p>
 <p>A function is a fundamental data-type in JavaScript. Note that although functions 
 may be created with this method, this is not efficient, and the preferred way to 
 define functions, in most cases, is to extend <A HREF="../js/Function.html" title="class in js"><CODE>Function</CODE></A>.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>A newly created empty function.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#function(java.lang.String)"><CODE>function(String)</CODE></A>, 
<A HREF="../js/Js.html#function(java.lang.String, java.lang.String)"><CODE>function(String, String)</CODE></A>, 
<A HREF="../js/Js.html#function(js.Vars, java.lang.String)"><CODE>function(Vars, String)</CODE></A>, 
<A HREF="../js/Function.html" title="class in js"><CODE>Function</CODE></A>, 
<A HREF="../js/core/JsGlobal.Function.html#create()"><CODE>JsGlobal.Function.create()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript invocation:
 <pre>new Function()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="function(java.lang.String)"><!-- --></A><H3>
function</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt; <B>function</B>(java.lang.String&nbsp;body)</PRE>
<DL>
<DD><p>Creates a JavaScript function that has no argument names.</p>
 <p>A function is a fundamental data-type in JavaScript. Note that although functions 
 may be created with this method, this is not efficient, and the preferred way to 
 define functions, in most cases, is to extend <A HREF="../js/Function.html" title="class in js"><CODE>Function</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>body</CODE> - A string that specifies the body of the function.
<DT><B>Returns:</B><DD>A newly created function. Invoking it executes the JavaScript code specified 
 by <tt>body</tt>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>SyntaxError</tt> if there was a 
 JavaScript syntax error in one of the value of <tt>body</tt>. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>err(Object)</CODE></A> 
 and <A HREF="../js/core/JsSyntaxError.html" title="class in js.core"><CODE>JsSyntaxError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#function()"><CODE>function()</CODE></A>, 
<A HREF="../js/Js.html#function(java.lang.String)"><CODE>function(String)</CODE></A>, 
<A HREF="../js/Js.html#function(java.lang.String, java.lang.String)"><CODE>function(String, String)</CODE></A>, 
<A HREF="../js/Function.html" title="class in js"><CODE>Function</CODE></A>, 
<A HREF="../js/core/JsGlobal.Function.html#create(java.lang.String)"><CODE>JsGlobal.Function.create(String)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Function.html#create(js.Vars, java.lang.String)"><CODE>JsGlobal.Function.create(Vars, String)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript invocation:
 <pre>new Function(body)</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="function(java.lang.String, java.lang.String)"><!-- --></A><H3>
function</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt; <B>function</B>(java.lang.String&nbsp;argname,
                                               java.lang.String&nbsp;body)</PRE>
<DL>
<DD><p>Creates a JavaScript function with an argument name.</p>
 <p>A function is a fundamental data-type in JavaScript. Note that although functions 
 may be created with this method, this is not efficient, and the preferred way to 
 define functions, in most cases, is to extend <A HREF="../js/Function.html" title="class in js"><CODE>Function</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>argname</CODE> - A string literal, naming an argument of the function being created.<DD><CODE>body</CODE> - A string that specifies the body of the function.
<DT><B>Returns:</B><DD>A newly created function. Invoking it executes the JavaScript code specified 
 by <tt>body</tt>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>SyntaxError</tt> if there was a 
 JavaScript syntax error in one of the value of the variable arguments or <tt>body</tt>. 
 See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>err(Object)</CODE></A> and <A HREF="../js/core/JsSyntaxError.html" title="class in js.core"><CODE>JsSyntaxError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#function()"><CODE>function()</CODE></A>, 
<A HREF="../js/Js.html#function(java.lang.String)"><CODE>function(String)</CODE></A>, 
<A HREF="../js/Js.html#function(js.Vars, java.lang.String)"><CODE>function(Vars, String)</CODE></A>, 
<A HREF="../js/Function.html" title="class in js"><CODE>Function</CODE></A>, 
<A HREF="../js/core/JsGlobal.Function.html#create(java.lang.String, java.lang.String)"><CODE>JsGlobal.Function.create(String, String)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Function.html#create(js.Vars, java.lang.String)"><CODE>JsGlobal.Function.create(Vars, String)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript invocation:
 <pre>new Function(argname, body)</pre>
 where <tt>argname</tt> must be a string literal and converted into an argument name.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="function(js.Vars, java.lang.String)"><!-- --></A><H3>
function</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt; <B>function</B>(<A HREF="../js/Vars.html" title="class in js">Vars</A>&lt;java.lang.String&gt;&nbsp;argnames,
                                               java.lang.String&nbsp;body)</PRE>
<DL>
<DD><p>Creates a JavaScript function.</p>
 <p>A function is a fundamental data-type in JavaScript. Note that although functions 
 may be created with this method, this is not efficient, and the preferred way to 
 define functions, in most cases, is to extend <A HREF="../js/Function.html" title="class in js"><CODE>Function</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>argnames</CODE> - A list of the argument values, each naming one or more arguments of the 
 function being created.<DD><CODE>body</CODE> - A string that specifies the body of the function.
<DT><B>Returns:</B><DD>A newly created function. Invoking it executes the JavaScript code specified 
 by <tt>body</tt>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>SyntaxError</tt> if there was a 
 JavaScript syntax error in one of the value of the variable arguments and <tt>body</tt>. 
 See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>err(Object)</CODE></A> and <A HREF="../js/core/JsSyntaxError.html" title="class in js.core"><CODE>JsSyntaxError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#function()"><CODE>function()</CODE></A>, 
<A HREF="../js/Js.html#function(java.lang.String)"><CODE>function(String)</CODE></A>, 
<A HREF="../js/Js.html#function(java.lang.String, java.lang.String)"><CODE>function(String, String)</CODE></A>, 
<A HREF="../js/Function.html" title="class in js"><CODE>Function</CODE></A>, 
<A HREF="../js/core/JsGlobal.Function.html#create(js.Vars, java.lang.String)"><CODE>JsGlobal.Function.create(Vars, String)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript invocation:
 <pre>new Function(argnames, body)</pre>
 where <tt>argnames</tt> must be a list of string literals and expanded into 
 comma-separated argument names.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="integer(java.lang.String)"><!-- --></A><H3>
integer</H3>
<PRE>
public static final int <B>integer</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><p>Creates an integer literal.</p>
 <p>This method is used to create formatted integer literal in re-compiled JavaScript 
 code. A re-compiler leaves the literal as it is without even parsing check but JS 
 Simulations parse it to an integer and throws RuntimeException if it is malformatted.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The literal text of an integer.
<DT><B>Returns:</B><DD>The integer literal.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript invocation:
 <pre>s</pre>
 where <tt>s</tt> must be a string literals and converted into an integer literal.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="number(java.lang.String)"><!-- --></A><H3>
number</H3>
<PRE>
public static final java.lang.Number <B>number</B>(java.lang.String&nbsp;s)</PRE>
<DL>
<DD><p>Creates a number literal.</p>
 <p>This method is used to create formatted number literal in re-compiled JavaScript 
 code. A re-compiler leaves the literal as it is without even parsing check but JS 
 Simulations parse it to a number and throws RuntimeException if it is malformatted.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The literal text of a number.
<DT><B>Returns:</B><DD>The numberer literal.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript invocation:
 <pre>s</pre>
 where <tt>s</tt> must be a string literal and converted into a number literal.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="array()"><!-- --></A><H3>
array</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;T&gt; <B>array</B>()</PRE>
<DL>
<DD><p>Creates an empty array.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The empty array.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#array(T[])"><CODE>array(Object[])</CODE></A>, 
<A HREF="../js/Js.html#array(boolean[])"><CODE>array(boolean[])</CODE></A>, 
<A HREF="../js/Js.html#array(byte[])"><CODE>array(byte[])</CODE></A>, 
<A HREF="../js/Js.html#array(char[])"><CODE>array(char[])</CODE></A>, 
<A HREF="../js/Js.html#array(short[])"><CODE>array(short[])</CODE></A>, 
<A HREF="../js/Js.html#array(int[])"><CODE>array(int[])</CODE></A>, 
<A HREF="../js/Js.html#array(long[])"><CODE>array(long[])</CODE></A>, 
<A HREF="../js/Js.html#array(float[])"><CODE>array(float[])</CODE></A>, 
<A HREF="../js/Js.html#array(double[])"><CODE>array(double[])</CODE></A>, 
<A HREF="../js/Vars.html#var()"><CODE>Vars.var()</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray()"><CODE>JsArray.JsArray()</CODE></A>, 
<A HREF="../js/core/JsGlobal.Array.html#create()"><CODE>JsGlobal.Array.create()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript invocation:
 <pre>[]</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="array(java.lang.Object[])"><!-- --></A><A NAME="array(T[])"><!-- --></A><H3>
array</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;T&gt; <B>array</B>(T[]&nbsp;a)</PRE>
<DL>
<DD><p>Gets the array-like representation of a generic array.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - A generic array
<DT><B>Returns:</B><DD>The array-like representation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#array(boolean[])"><CODE>array(boolean[])</CODE></A>, 
<A HREF="../js/Js.html#array(byte[])"><CODE>array(byte[])</CODE></A>, 
<A HREF="../js/Js.html#array(char[])"><CODE>array(char[])</CODE></A>, 
<A HREF="../js/Js.html#array(short[])"><CODE>array(short[])</CODE></A>, 
<A HREF="../js/Js.html#array(int[])"><CODE>array(int[])</CODE></A>, 
<A HREF="../js/Js.html#array(long[])"><CODE>array(long[])</CODE></A>, 
<A HREF="../js/Js.html#array(float[])"><CODE>array(float[])</CODE></A>, 
<A HREF="../js/Js.html#array(double[])"><CODE>array(double[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(js.core.JsObject)"><CODE>JsArray.JsArray(js.core.JsObject)</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(T[])"><CODE>JsArray.JsArray(Object[])</CODE></A>, 
<A HREF="../js/core/JsGlobal.Array.html#create(java.lang.Object)"><CODE>JsGlobal.Array.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="array(boolean[])"><!-- --></A><H3>
array</H3>
<PRE>
public static final <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Boolean&gt; <B>array</B>(boolean[]&nbsp;a)</PRE>
<DL>
<DD><p>Gets the array-like representation of a boolean array.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - A boolean array
<DT><B>Returns:</B><DD>The array-like representation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#array(T[])"><CODE>array(Object[])</CODE></A>, 
<A HREF="../js/Js.html#array(byte[])"><CODE>array(byte[])</CODE></A>, 
<A HREF="../js/Js.html#array(char[])"><CODE>array(char[])</CODE></A>, 
<A HREF="../js/Js.html#array(short[])"><CODE>array(short[])</CODE></A>, 
<A HREF="../js/Js.html#array(int[])"><CODE>array(int[])</CODE></A>, 
<A HREF="../js/Js.html#array(long[])"><CODE>array(long[])</CODE></A>, 
<A HREF="../js/Js.html#array(float[])"><CODE>array(float[])</CODE></A>, 
<A HREF="../js/Js.html#array(double[])"><CODE>array(double[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(boolean[])"><CODE>JsArray.JsArray(boolean[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(js.core.JsObject)"><CODE>JsArray.JsArray(js.core.JsObject)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Array.html#create(java.lang.Object)"><CODE>JsGlobal.Array.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="array(byte[])"><!-- --></A><H3>
array</H3>
<PRE>
public static final <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Byte&gt; <B>array</B>(byte[]&nbsp;a)</PRE>
<DL>
<DD><p>Gets the array-like representation of a byte array.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - A byte array
<DT><B>Returns:</B><DD>The array-like representation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#array(T[])"><CODE>array(Object[])</CODE></A>, 
<A HREF="../js/Js.html#array(boolean[])"><CODE>array(boolean[])</CODE></A>, 
<A HREF="../js/Js.html#array(char[])"><CODE>array(char[])</CODE></A>, 
<A HREF="../js/Js.html#array(short[])"><CODE>array(short[])</CODE></A>, 
<A HREF="../js/Js.html#array(int[])"><CODE>array(int[])</CODE></A>, 
<A HREF="../js/Js.html#array(long[])"><CODE>array(long[])</CODE></A>, 
<A HREF="../js/Js.html#array(float[])"><CODE>array(float[])</CODE></A>, 
<A HREF="../js/Js.html#array(double[])"><CODE>array(double[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(byte[])"><CODE>JsArray.JsArray(byte[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(js.core.JsObject)"><CODE>JsArray.JsArray(js.core.JsObject)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Array.html#create(java.lang.Object)"><CODE>JsGlobal.Array.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="array(char[])"><!-- --></A><H3>
array</H3>
<PRE>
public static final <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Character&gt; <B>array</B>(char[]&nbsp;a)</PRE>
<DL>
<DD><p>Gets the array-like representation of a char array.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - A char array
<DT><B>Returns:</B><DD>The array-like representation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#array(T[])"><CODE>array(Object[])</CODE></A>, 
<A HREF="../js/Js.html#array(boolean[])"><CODE>array(boolean[])</CODE></A>, 
<A HREF="../js/Js.html#array(byte[])"><CODE>array(byte[])</CODE></A>, 
<A HREF="../js/Js.html#array(short[])"><CODE>array(short[])</CODE></A>, 
<A HREF="../js/Js.html#array(int[])"><CODE>array(int[])</CODE></A>, 
<A HREF="../js/Js.html#array(long[])"><CODE>array(long[])</CODE></A>, 
<A HREF="../js/Js.html#array(float[])"><CODE>array(float[])</CODE></A>, 
<A HREF="../js/Js.html#array(double[])"><CODE>array(double[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(char[])"><CODE>JsArray.JsArray(char[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(js.core.JsObject)"><CODE>JsArray.JsArray(js.core.JsObject)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Array.html#create(java.lang.Object)"><CODE>JsGlobal.Array.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="array(short[])"><!-- --></A><H3>
array</H3>
<PRE>
public static final <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Short&gt; <B>array</B>(short[]&nbsp;a)</PRE>
<DL>
<DD><p>Gets the array-like representation of a short array.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - A short array
<DT><B>Returns:</B><DD>The array-like representation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#array(T[])"><CODE>array(Object[])</CODE></A>, 
<A HREF="../js/Js.html#array(boolean[])"><CODE>array(boolean[])</CODE></A>, 
<A HREF="../js/Js.html#array(byte[])"><CODE>array(byte[])</CODE></A>, 
<A HREF="../js/Js.html#array(char[])"><CODE>array(char[])</CODE></A>, 
<A HREF="../js/Js.html#array(int[])"><CODE>array(int[])</CODE></A>, 
<A HREF="../js/Js.html#array(long[])"><CODE>array(long[])</CODE></A>, 
<A HREF="../js/Js.html#array(float[])"><CODE>array(float[])</CODE></A>, 
<A HREF="../js/Js.html#array(double[])"><CODE>array(double[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(short[])"><CODE>JsArray.JsArray(short[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(js.core.JsObject)"><CODE>JsArray.JsArray(js.core.JsObject)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Array.html#create(java.lang.Object)"><CODE>JsGlobal.Array.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="array(int[])"><!-- --></A><H3>
array</H3>
<PRE>
public static final <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Integer&gt; <B>array</B>(int[]&nbsp;a)</PRE>
<DL>
<DD><p>Gets the array-like representation of an int array.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - An int array
<DT><B>Returns:</B><DD>The array-like representation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#array(T[])"><CODE>array(Object[])</CODE></A>, 
<A HREF="../js/Js.html#array(boolean[])"><CODE>array(boolean[])</CODE></A>, 
<A HREF="../js/Js.html#array(byte[])"><CODE>array(byte[])</CODE></A>, 
<A HREF="../js/Js.html#array(char[])"><CODE>array(char[])</CODE></A>, 
<A HREF="../js/Js.html#array(short[])"><CODE>array(short[])</CODE></A>, 
<A HREF="../js/Js.html#array(long[])"><CODE>array(long[])</CODE></A>, 
<A HREF="../js/Js.html#array(float[])"><CODE>array(float[])</CODE></A>, 
<A HREF="../js/Js.html#array(double[])"><CODE>array(double[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(int[])"><CODE>JsArray.JsArray(int[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(js.core.JsObject)"><CODE>JsArray.JsArray(js.core.JsObject)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Array.html#create(java.lang.Object)"><CODE>JsGlobal.Array.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="array(long[])"><!-- --></A><H3>
array</H3>
<PRE>
public static final <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Long&gt; <B>array</B>(long[]&nbsp;a)</PRE>
<DL>
<DD><p>Gets the array-like representation of a long array.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - A long array
<DT><B>Returns:</B><DD>The array-like representation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#array(T[])"><CODE>array(Object[])</CODE></A>, 
<A HREF="../js/Js.html#array(boolean[])"><CODE>array(boolean[])</CODE></A>, 
<A HREF="../js/Js.html#array(byte[])"><CODE>array(byte[])</CODE></A>, 
<A HREF="../js/Js.html#array(char[])"><CODE>array(char[])</CODE></A>, 
<A HREF="../js/Js.html#array(short[])"><CODE>array(short[])</CODE></A>, 
<A HREF="../js/Js.html#array(int[])"><CODE>array(int[])</CODE></A>, 
<A HREF="../js/Js.html#array(float[])"><CODE>array(float[])</CODE></A>, 
<A HREF="../js/Js.html#array(double[])"><CODE>array(double[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(long[])"><CODE>JsArray.JsArray(long[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(js.core.JsObject)"><CODE>JsArray.JsArray(js.core.JsObject)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Array.html#create(java.lang.Object)"><CODE>JsGlobal.Array.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="array(float[])"><!-- --></A><H3>
array</H3>
<PRE>
public static final <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Float&gt; <B>array</B>(float[]&nbsp;a)</PRE>
<DL>
<DD><p>Gets the array-like representation of a float array.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - A float array
<DT><B>Returns:</B><DD>The array-like representation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#array(T[])"><CODE>array(Object[])</CODE></A>, 
<A HREF="../js/Js.html#array(boolean[])"><CODE>array(boolean[])</CODE></A>, 
<A HREF="../js/Js.html#array(byte[])"><CODE>array(byte[])</CODE></A>, 
<A HREF="../js/Js.html#array(char[])"><CODE>array(char[])</CODE></A>, 
<A HREF="../js/Js.html#array(short[])"><CODE>array(short[])</CODE></A>, 
<A HREF="../js/Js.html#array(int[])"><CODE>array(int[])</CODE></A>, 
<A HREF="../js/Js.html#array(long[])"><CODE>array(long[])</CODE></A>, 
<A HREF="../js/Js.html#array(double[])"><CODE>array(double[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(float[])"><CODE>JsArray.JsArray(float[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(js.core.JsObject)"><CODE>JsArray.JsArray(js.core.JsObject)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Array.html#create(java.lang.Object)"><CODE>JsGlobal.Array.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="array(double[])"><!-- --></A><H3>
array</H3>
<PRE>
public static final <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;java.lang.Double&gt; <B>array</B>(double[]&nbsp;a)</PRE>
<DL>
<DD><p>Gets the array-like representation of a double array.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - A double array
<DT><B>Returns:</B><DD>The array-like representation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#array(T[])"><CODE>array(Object[])</CODE></A>, 
<A HREF="../js/Js.html#array(boolean[])"><CODE>array(boolean[])</CODE></A>, 
<A HREF="../js/Js.html#array(byte[])"><CODE>array(byte[])</CODE></A>, 
<A HREF="../js/Js.html#array(char[])"><CODE>array(char[])</CODE></A>, 
<A HREF="../js/Js.html#array(short[])"><CODE>array(short[])</CODE></A>, 
<A HREF="../js/Js.html#array(int[])"><CODE>array(int[])</CODE></A>, 
<A HREF="../js/Js.html#array(long[])"><CODE>array(long[])</CODE></A>, 
<A HREF="../js/Js.html#array(float[])"><CODE>array(float[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(double[])"><CODE>JsArray.JsArray(double[])</CODE></A>, 
<A HREF="../js/core/JsArray.html#JsArray(js.core.JsObject)"><CODE>JsArray.JsArray(js.core.JsObject)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Array.html#create(java.lang.Object)"><CODE>JsGlobal.Array.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="date()"><!-- --></A><H3>
date</H3>
<PRE>
public static final <A HREF="../js/DateLike.html" title="interface in js">DateLike</A> <B>date</B>()</PRE>
<DL>
<DD><p>Creates a date object set to the current system date and time.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The newly created date object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#date(java.lang.Number)"><CODE>date(Number)</CODE></A>, 
<A HREF="../js/Js.html#date(java.lang.String)"><CODE>date(String)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Date.html#create()"><CODE>JsGlobal.Date.create()</CODE></A>, 
<A HREF="../js/core/JsGlobal.Date.html#create(js.Vars)"><CODE>JsGlobal.Date.create(Vars)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>new Date()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="date(java.lang.Number)"><!-- --></A><H3>
date</H3>
<PRE>
public static final <A HREF="../js/DateLike.html" title="interface in js">DateLike</A> <B>date</B>(java.lang.Number&nbsp;milliseconds)</PRE>
<DL>
<DD><p>Creates a date object from a numeric representation in milliseconds.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>milliseconds</CODE> - A numeric representation of date in milliseconds.
<DT><B>Returns:</B><DD>The newly created date object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#date()"><CODE>date()</CODE></A>, 
<A HREF="../js/Js.html#date(java.lang.String)"><CODE>date(String)</CODE></A>, 
<A HREF="../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate.JsDate(Number)</CODE></A>, 
<A HREF="../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate.JsDate(NumberLike)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Date.html#create(java.lang.Number)"><CODE>JsGlobal.Date.create(Number)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Date.html#create(js.NumberLike)"><CODE>JsGlobal.Date.create(NumberLike)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Date.html#create(js.Vars)"><CODE>JsGlobal.Date.create(Vars)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>new Date(milliseconds)</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="date(java.lang.String)"><!-- --></A><H3>
date</H3>
<PRE>
public static final <A HREF="../js/DateLike.html" title="interface in js">DateLike</A> <B>date</B>(java.lang.String&nbsp;datestring)</PRE>
<DL>
<DD><p>Creates a date object from a string representation.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>datestring</CODE> - A string representation of date.
<DT><B>Returns:</B><DD>The newly created date object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#date()"><CODE>date()</CODE></A>, 
<A HREF="../js/Js.html#date(java.lang.Number)"><CODE>date(Number)</CODE></A>, 
<A HREF="../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate.JsDate(String)</CODE></A>, 
<A HREF="../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate.JsDate(StringLike)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Date.html#create(java.lang.Object)"><CODE>JsGlobal.Date.create(Object)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Date.html#create(js.Vars)"><CODE>JsGlobal.Date.create(Vars)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>new Date(datestring)</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="math()"><!-- --></A><H3>
math</H3>
<PRE>
public static final <A HREF="../js/MathLike.html" title="interface in js">MathLike</A> <B>math</B>()</PRE>
<DL>
<DD><p>Returns the math-like object.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The math-like object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/core/JsGlobal.Math.html" title="class in js.core"><CODE>JsGlobal.Math</CODE></A>, 
<A HREF="../jsx/core/Maths.html" title="class in jsx.core"><CODE>Maths</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>Math</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="object()"><!-- --></A><H3>
object</H3>
<PRE>
public static final <A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A> <B>object</B>()</PRE>
<DL>
<DD><p>Creates and returns a newly created object.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The newly created object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#object(java.lang.Object)"><CODE>object(Object)</CODE></A>, 
<A HREF="../js/Initializer.html#var()"><CODE>Initializer.var()</CODE></A>, 
<A HREF="../js/core/JsObject.html#JsObject()"><CODE>JsObject.JsObject()</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#create()"><CODE>JsGlobal.Object.create()</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#invoke()"><CODE>JsGlobal.Object.invoke()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>{}</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="object(java.lang.Object)"><!-- --></A><H3>
object</H3>
<PRE>
public static final <A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A> <B>object</B>(java.lang.Object&nbsp;o)</PRE>
<DL>
<DD><p>Converts a value to an object and returns it.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>o</CODE> - A value to be converted to object. If this argument is a primitive value, 
 this method creates a corresponding object for it. Otherwise, the method returns 
 the object itself.
<DT><B>Returns:</B><DD>The converted or created object. If the argument is a primitive value, 
 this method returns a corresponding object for it. Otherwise, the method returns 
 the object argument itself.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#object()"><CODE>object()</CODE></A>, 
<A HREF="../js/core/JsObject.html#JsObject(js.core.JsObject)"><CODE>JsObject.JsObject(JsObject)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#create(java.lang.Boolean)"><CODE>JsGlobal.Object.create(Boolean)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#create(js.core.JsBoolean)"><CODE>JsGlobal.Object.create(JsBoolean)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#create(js.Value)"><CODE>JsGlobal.Object.create(Value)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#create(java.lang.Number)"><CODE>JsGlobal.Object.create(Number)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#create(js.NumberLike)"><CODE>JsGlobal.Object.create(NumberLike)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#create(java.lang.String)"><CODE>JsGlobal.Object.create(String)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#create(js.StringLike)"><CODE>JsGlobal.Object.create(StringLike)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#invoke(java.lang.Boolean)"><CODE>JsGlobal.Object.invoke(Boolean)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#invoke(js.core.JsBoolean)"><CODE>JsGlobal.Object.invoke(JsBoolean)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#invoke(js.Value)"><CODE>JsGlobal.Object.invoke(Value)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#invoke(java.lang.Number)"><CODE>JsGlobal.Object.invoke(Number)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#invoke(js.NumberLike)"><CODE>JsGlobal.Object.invoke(NumberLike)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#invoke(java.lang.String)"><CODE>JsGlobal.Object.invoke(String)</CODE></A>, 
<A HREF="../js/core/JsGlobal.Object.html#invoke(js.StringLike)"><CODE>JsGlobal.Object.invoke(StringLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>Object(o)</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="re(java.lang.String)"><!-- --></A><H3>
re</H3>
<PRE>
public static final <A HREF="../js/RegExpLike.html" title="interface in js">RegExpLike</A> <B>re</B>(java.lang.String&nbsp;regex)</PRE>
<DL>
<DD><p>Creates a regular expression with the specified pattern.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regex</CODE> - A string that specifies the pattern of the regular expression.
<DT><B>Returns:</B><DD>A new regular expression object, with the specified pattern.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>SyntaxError</tt> If <tt>regex</tt> 
 is not a legal regular expression. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>err(Object)</CODE></A> and <A HREF="../js/core/JsSyntaxError.html" title="class in js.core"><CODE>JsSyntaxError</CODE></A> 
 for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#re(java.lang.String, java.lang.String)"><CODE>re(String, String)</CODE></A>, 
<A HREF="../js/core/JsRegExp.html#JsRegExp(java.lang.String)"><CODE>JsRegExp.JsRegExp(String)</CODE></A>, 
<A HREF="../js/core/JsGlobal.RegExp.html#create(java.lang.Object)"><CODE>JsGlobal.RegExp.create(Object)</CODE></A>, 
<A HREF="../js/core/JsGlobal.RegExp.html#create(js.Vars)"><CODE>JsGlobal.RegExp.create(Vars)</CODE></A>, 
<A HREF="../js/core/JsGlobal.RegExp.html#invoke(java.lang.Object)"><CODE>JsGlobal.RegExp.invoke(Object)</CODE></A>, 
<A HREF="../js/core/JsGlobal.RegExp.html#invoke(js.Vars)"><CODE>JsGlobal.RegExp.invoke(Vars)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>RegExp(regex)</pre>
 or if <tt>regex</tt> is a string literal,
 <pre>/regex/</pre>
 where <tt>regex</tt> is converted to a literal text.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="re(java.lang.String, java.lang.String)"><!-- --></A><H3>
re</H3>
<PRE>
public static final <A HREF="../js/RegExpLike.html" title="interface in js">RegExpLike</A> <B>re</B>(java.lang.String&nbsp;regex,
                                  java.lang.String&nbsp;flags)</PRE>
<DL>
<DD><p>Creates a regular expression with the specified pattern and flags.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regex</CODE> - A string that specifies the pattern of the regular expression.<DD><CODE>flags</CODE> - An optional string containing any of the "g", "i", and "m" attributes 
 that specify global, case-insensitive, and multiline matches, respectively. The "m" 
 attribute is not available prior to ECMAScript standardization.
<DT><B>Returns:</B><DD>A new regular expression object, with the specified pattern and flags.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>SyntaxError</tt> If <tt>regex</tt> 
 is not a legal regular expression, or if <tt>flags</tt> contains characters other than 
 "g", "i", and "m". See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>err(Object)</CODE></A> and <A HREF="../js/core/JsSyntaxError.html" title="class in js.core"><CODE>JsSyntaxError</CODE></A> for 
 JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#re(java.lang.String)"><CODE>re(String)</CODE></A>, 
<A HREF="../js/core/JsRegExp.html#JsRegExp(java.lang.String, java.lang.String)"><CODE>JsRegExp.JsRegExp(String, String)</CODE></A>, 
<A HREF="../js/core/JsGlobal.RegExp.html#create(java.lang.Object, java.lang.Object)"><CODE>JsGlobal.RegExp.create(Object, Object)</CODE></A>, 
<A HREF="../js/core/JsGlobal.RegExp.html#create(js.Vars)"><CODE>JsGlobal.RegExp.create(Vars)</CODE></A>, 
<A HREF="../js/core/JsGlobal.RegExp.html#invoke(java.lang.Object, java.lang.Object)"><CODE>JsGlobal.RegExp.invoke(Object, Object)</CODE></A>, 
<A HREF="../js/core/JsGlobal.RegExp.html#invoke(js.Vars)"><CODE>JsGlobal.RegExp.invoke(Vars)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace this static invocation with the JavaScript expression:
 <pre>RegExp(regex, flags)</pre>
 or if <tt>regex</tt> and <tt>flags</tt> are both string literals, 
 <pre>/regex/flags</pre>
 where <tt>regex</tt> and <tt>flags</tt> are converted to literal texts.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="http()"><!-- --></A><H3>
http</H3>
<PRE>
public static final <A HREF="../js/user/JsXMLHttpRequest.html" title="class in js.user">JsXMLHttpRequest</A> <B>http</B>()</PRE>
<DL>
<DD><p>Returns an instance of XMLHttpRequest in Java version.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The instance of XMLHttpRequest in Java version.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/dom/DOM.XMLHttpRequest.html#create()"><CODE>DOM.XMLHttpRequest.create()</CODE></A>, 
<A HREF="../js/core/JsFunction.html#invoke()"><CODE>JsFunction.invoke()</CODE></A>, 
<A HREF="../jsx/http/Http.html#create()"><CODE>Http.create()</CODE></A>, 
<A HREF="../jsx/http/Http.html#create2()"><CODE>Http.create2()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>new XMLHttpRequest()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="activeX(java.lang.String)"><!-- --></A><H3>
activeX</H3>
<PRE>
public static final <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A> <B>activeX</B>(java.lang.String&nbsp;cls)</PRE>
<DL>
<DD><p>Creates an OLE Automation (ActiveX) object for Internet Explorer.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cls</CODE> - The class of the OLE Automation (ActiveX) object being created.
<DT><B>Returns:</B><DD>The newly created OLE Automation (ActiveX) object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/dom/DOM.ActiveXObject.html#create(java.lang.Object)"><CODE>DOM.ActiveXObject.create(Object)</CODE></A>, 
<A HREF="../js/dom/DOM.ActiveXObject.html#create(java.lang.String)"><CODE>DOM.ActiveXObject.create(String)</CODE></A>, 
<A HREF="../js/dom/DOM.ActiveXObject.html#create(js.Vars)"><CODE>DOM.ActiveXObject.create(Vars)</CODE></A>, 
<A HREF="../jsx/http/Http.html#create()"><CODE>Http.create()</CODE></A>, 
<A HREF="../jsx/http/Http.html#create2()"><CODE>Http.create2()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>new ActiveXObject(cls)</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="connect(java.lang.String, java.lang.String)"><!-- --></A><H3>
connect</H3>
<PRE>
public static final <A HREF="../js/LiveClass.html" title="interface in js">LiveClass</A> <B>connect</B>(java.lang.String&nbsp;applet,
                                      java.lang.String&nbsp;cls)</PRE>
<DL>
<DD><p>Connects to a Java class in an applet and returns a LiveConnect class.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>applet</CODE> - The applet ID where the Java class is to be connected to.<DD><CODE>cls</CODE> - The Java class to be connected to.
<DT><B>Returns:</B><DD>The LiveConnect class connected to the Java class.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#connect(java.lang.Object)"><CODE>connect(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>applet.cls</pre>
 where <tt>applet</tt> and <tt>cls</tt> must be both string literals and converted 
 into identifiers.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="connect(java.lang.Object)"><!-- --></A><H3>
connect</H3>
<PRE>
public static final <A HREF="../js/LiveObject.html" title="interface in js">LiveObject</A> <B>connect</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD><p>Connects to a Java object and returns a LiveConnect object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - The Java object to be connected to.
<DT><B>Returns:</B><DD>The LiveConnect object connected to the Java object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Js.html#connect(java.lang.String, java.lang.String)"><CODE>connect(String, String)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace this static invocation with the JavaScript expression:
 <pre>obj</pre>
 where <tt>obj</tt> must be a string literal and converted to an identifier.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="err(java.lang.Object)"><!-- --></A><H3>
err</H3>
<PRE>
public static final java.lang.RuntimeException <B>err</B>(java.lang.Object&nbsp;v)</PRE>
<DL>
<DD><p>Makes a variable runtime throwable, resembling JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>A <tt>RuntimeException</tt> wrapping the value or object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="err(java.lang.RuntimeException)"><!-- --></A><H3>
err</H3>
<PRE>
public static final java.lang.Object <B>err</B>(java.lang.RuntimeException&nbsp;e)</PRE>
<DL>
<DD><p>Gets the value or object contained in a <tt>RuntimeException</tt> object 
 thrown by JS Simulation.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>e</CODE> - The <tt>RuntimeException</tt> object thrown by JS Simulation.
<DT><B>Returns:</B><DD>The value or object contained in the <tt>RuntimeException</tt> object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="undefined(java.lang.Object)"><!-- --></A><H3>
undefined</H3>
<PRE>
public static final boolean <B>undefined</B>(java.lang.Object&nbsp;v)</PRE>
<DL>
<DD><p>Checks if a variable is undefined.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if <tt>v</tt> is undefined; <tt>false</tt>, otherwise.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v===undefined</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="defined(java.lang.Object)"><!-- --></A><H3>
defined</H3>
<PRE>
public static final boolean <B>defined</B>(java.lang.Object&nbsp;v)</PRE>
<DL>
<DD><p>Checks if a variable is defined.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if <tt>v</tt> is defined; <tt>false</tt>, otherwise.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v!==undefined</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isJavaObject(java.lang.Object)"><!-- --></A><H3>
isJavaObject</H3>
<PRE>
public static final boolean <B>isJavaObject</B>(java.lang.Object&nbsp;v)</PRE>
<DL>
<DD><p>Checks if a variable represents a Java object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if <tt>v</tt> is Java; <tt>false</tt>, otherwise.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v instanceof JavaObject</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(java.lang.Object)"><!-- --></A><H3>
toString</H3>
<PRE>
public static final java.lang.String <B>toString</B>(java.lang.Object&nbsp;v)</PRE>
<DL>
<DD><p>Returns a string representation of a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The string representation of the value or object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>"" + v</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(boolean)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(boolean&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(java.lang.Boolean)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(java.lang.Boolean&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(java.lang.Character)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(java.lang.Character&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(char)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(char&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(java.lang.Number)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(java.lang.Number&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(byte)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(byte&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(short)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(short&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(int)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(int&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(long)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(long&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(float)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(float&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(double)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(double&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(java.lang.String)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(java.lang.String&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(js.ArrayLike)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;?&gt;&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(js.core.JsArray)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(<A HREF="../js/core/JsArray.html" title="class in js.core">JsArray</A>&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(js.Var)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;?&gt;&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be(java.lang.Object)"><!-- --></A><H3>
be</H3>
<PRE>
public static final boolean <B>be</B>(java.lang.Object&nbsp;v)</PRE>
<DL>
<DD><p>Logically evaluates a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - The variable.
<DT><B>Returns:</B><DD>The logical value of the variable.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the static invocation of this method, that is, 
 replacing it with its only argument.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="typeof(java.lang.Object)"><!-- --></A><H3>
typeof</H3>
<PRE>
public static final java.lang.String <B>typeof</B>(java.lang.Object&nbsp;v)</PRE>
<DL>
<DD><p>Returns a string indicating the data-type of the argument.</p>
 <p>Simulating the JavaScript <tt>typeof</tt> operator and <tt>typeof()</tt> 
 function, this invocation evaluates to "number", "string", or "boolean" if the  
 argument is a number, string, or boolean value. It evaluates to "object" for objects 
 and arrays. It evaluates to "function" for function instance and to "undefined" if 
 the argument is undefined.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>A string indicating the data-type of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>typeof v</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.Boolean)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Boolean <B>valueOf</B>(java.lang.Boolean&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.Number)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Number <B>valueOf</B>(java.lang.Number&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.Byte)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Byte <B>valueOf</B>(java.lang.Byte&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.Character)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Short <B>valueOf</B>(java.lang.Character&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.Short)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Short <B>valueOf</B>(java.lang.Short&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.Integer)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Integer <B>valueOf</B>(java.lang.Integer&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.Long)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Long <B>valueOf</B>(java.lang.Long&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.Float)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Float <B>valueOf</B>(java.lang.Float&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.Double)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Double <B>valueOf</B>(java.lang.Double&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.String)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.String <B>valueOf</B>(java.lang.String&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(js.ArrayLike)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;T&gt; <B>valueOf</B>(<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;T&gt;&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(js.core.JsObject)"><!-- --></A><A NAME="valueOf(T)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final &lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; T <B>valueOf</B>(T&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(js.core.JsBoolean)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Boolean <B>valueOf</B>(<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(js.DateLike)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Number <B>valueOf</B>(<A HREF="../js/DateLike.html" title="interface in js">DateLike</A>&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(js.Function)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final &lt;T&gt; <A HREF="../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;T&gt; <B>valueOf</B>(<A HREF="../js/Function.html" title="class in js">Function</A>&lt;T&gt;&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(js.NumberLike)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final &lt;T extends java.lang.Number&gt; T <B>valueOf</B>(<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;T&gt;&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(js.core.JsNumber)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Number <B>valueOf</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(js.StringLike)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.String <B>valueOf</B>(<A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(js.core.JsString)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.String <B>valueOf</B>(<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(js.Var)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final &lt;T&gt; T <B>valueOf</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;T&gt;&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf(java.lang.Object)"><!-- --></A><H3>
valueOf</H3>
<PRE>
public static final java.lang.Object <B>valueOf</B>(java.lang.Object&nbsp;v)</PRE>
<DL>
<DD><p>Returns the primitive value associated with the argument, if there is one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Any value or object.
<DT><B>Returns:</B><DD>The primitive string value associated with the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>v.valueOf()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete(js.Value)"><!-- --></A><H3>
delete</H3>
<PRE>
public static final boolean <B>delete</B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;?&gt;&nbsp;var)</PRE>
<DL>
<DD><p>Undefines a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The variable to delete.
<DT><B>Returns:</B><DD><tt>true</tt> if the deletion is successful; Otherwise, <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>delete var</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete(js.Var)"><!-- --></A><H3>
delete</H3>
<PRE>
public static final boolean <B>delete</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;var)</PRE>
<DL>
<DD><p>Undefines a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The variable to delete.
<DT><B>Returns:</B><DD><tt>true</tt> if the deletion is successful; Otherwise, <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>delete var</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete(js.core.JsObject)"><!-- --></A><H3>
delete</H3>
<PRE>
public static final boolean <B>delete</B>(<A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&nbsp;var)</PRE>
<DL>
<DD><p>Undefines a variable.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The variable to delete.
<DT><B>Returns:</B><DD><tt>true</tt> if the deletion is successful; Otherwise, <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>delete var</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete(js.Var, java.lang.Object)"><!-- --></A><H3>
delete</H3>
<PRE>
public static final boolean <B>delete</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;var,
                                   java.lang.Object&nbsp;p)</PRE>
<DL>
<DD><p>Undefines a property.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The variable to delete a property from.<DD><CODE>p</CODE> - The property to delete.
<DT><B>Returns:</B><DD><tt>true</tt> if the deletion is successful; Otherwise, <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>delete var[p]</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete(js.ObjectLike, java.lang.Object)"><!-- --></A><H3>
delete</H3>
<PRE>
public static final boolean <B>delete</B>(<A HREF="../js/ObjectLike.html" title="interface in js">ObjectLike</A>&nbsp;var,
                                   java.lang.Object&nbsp;p)</PRE>
<DL>
<DD><p>Undefines a property.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The variable to delete a property from.<DD><CODE>p</CODE> - The property to delete.
<DT><B>Returns:</B><DD><tt>true</tt> if the deletion is successful; Otherwise, <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>delete var[p]</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete(js.core.JsObject, java.lang.Object)"><!-- --></A><H3>
delete</H3>
<PRE>
public static final boolean <B>delete</B>(<A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&nbsp;var,
                                   java.lang.Object&nbsp;p)</PRE>
<DL>
<DD><p>Undefines a property.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The variable to delete a property from.<DD><CODE>p</CODE> - The property to delete.
<DT><B>Returns:</B><DD><tt>true</tt> if the deletion is successful; Otherwise, <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>delete var[p]</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="delete(js.ArrayLike, int)"><!-- --></A><H3>
delete</H3>
<PRE>
public static final boolean <B>delete</B>(<A HREF="../js/ArrayLike.html" title="interface in js">ArrayLike</A>&lt;?&gt;&nbsp;var,
                                   int&nbsp;i)</PRE>
<DL>
<DD><p>Delete an array element.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The array to delete an element from.<DD><CODE>i</CODE> - The array index of the element to delete.
<DT><B>Returns:</B><DD><tt>true</tt> if the deletion is successful; Otherwise, <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>delete var[i]</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="neg(java.lang.Object)"><!-- --></A><H3>
neg</H3>
<PRE>
public static final java.lang.Number <B>neg</B>(java.lang.Object&nbsp;var)</PRE>
<DL>
<DD><p>Performs unary negation, resembling the unary minus operator in JavaScript.</p>
 <p>This operation converts a positive value to an equivalently negative value, and 
 vice versa. If the operand is not a number, it attempts to convert it to one.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The negation of the numeric value.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>-var</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="mul(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
mul</H3>
<PRE>
public static final java.lang.Number <B>mul</B>(java.lang.Object&nbsp;var,
                                         java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Multiplies the two operands, resembling the multiplication operator in JavaScript.</p>
 <p>If used with non-numeric operands, this operation attempts to convert them to 
 numbers.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The product of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var * other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="div(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
div</H3>
<PRE>
public static final java.lang.Number <B>div</B>(java.lang.Object&nbsp;var,
                                         java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Divides the first operand by the second, resembling the division operator 
 in JavaScript.</p>
 <p>Used with non-numeric operands, this operation attempts to convert them to 
 numbers. If you are used to programming languages that distinguish between integer 
 and floating-point numbers, you might expect to get an integer result when you 
 divide one integer by another. In JavaScript, however, all numbers are floating-point, 
 so all division operations have floating-point results. Division by zero yields positive 
 or negative infinity, while <tt>0/0</tt> evaluates to <tt>NaN</tt>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The quotient of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var / other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="mod(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
mod</H3>
<PRE>
public static final java.lang.Number <B>mod</B>(java.lang.Object&nbsp;var,
                                         java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Computes the first operand modulo the second operand, resembling the modulo 
 operator in JavaScript.</p>
 <p>The operation returns the remainder when the first operand is divided by the 
 second operand a certain number of times. If used with non-numeric operands, the 
 operation attempts to convert them to numbers. The sign of the result is the same 
 as the sign of the first operand.</p>
 <p>This operation is typically used with integer operands, it also works for 
 floating-point values.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The remainder.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var % other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="sub(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
sub</H3>
<PRE>
public static final java.lang.Number <B>sub</B>(java.lang.Object&nbsp;var,
                                         java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Subtracts the second operand from the first operand, resembling the modulo 
 operator in JavaScript.</p>
 <p>If used with non-numeric operands, this operation attempts to convert them to 
 numbers.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The difference between the operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var - other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Object <B>add</B>(java.lang.Object&nbsp;var,
                                         java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Object, java.lang.String)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.String <B>add</B>(java.lang.Object&nbsp;var,
                                         java.lang.String&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Object, js.StringLike)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.String <B>add</B>(java.lang.Object&nbsp;var,
                                         <A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.String, java.lang.Object)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.String <B>add</B>(java.lang.String&nbsp;var,
                                         java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.String, java.lang.String)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.String <B>add</B>(java.lang.String&nbsp;var,
                                         java.lang.String&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.String, js.StringLike)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.String <B>add</B>(java.lang.String&nbsp;var,
                                         <A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.StringLike, java.lang.Object)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.String <B>add</B>(<A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;var,
                                         java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.StringLike, java.lang.String)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.String <B>add</B>(<A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;var,
                                         java.lang.String&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.StringLike, js.StringLike)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.String <B>add</B>(<A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;var,
                                         <A HREF="../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Character, java.lang.Character)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(java.lang.Character&nbsp;var,
                                         java.lang.Character&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Character, js.Var)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(java.lang.Character&nbsp;var,
                                         <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Character, java.lang.Number)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(java.lang.Character&nbsp;var,
                                         java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Character, js.NumberLike)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(java.lang.Character&nbsp;var,
                                         <A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.Var, java.lang.Character)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;var,
                                         java.lang.Character&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.Var, js.Var)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;var,
                                         <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.Var, java.lang.Number)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;var,
                                         java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.Var, js.NumberLike)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;var,
                                         <A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Number, java.lang.Character)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(java.lang.Number&nbsp;var,
                                         java.lang.Character&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Number, js.Var)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(java.lang.Number&nbsp;var,
                                         <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Number, java.lang.Number)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(java.lang.Number&nbsp;var,
                                         java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Number, js.NumberLike)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(java.lang.Number&nbsp;var,
                                         <A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.NumberLike, java.lang.Character)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
                                         java.lang.Character&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.NumberLike, js.Var)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
                                         <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Character&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.NumberLike, java.lang.Number)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
                                         java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.NumberLike, js.NumberLike)"><!-- --></A><H3>
add</H3>
<PRE>
public static final java.lang.Number <B>add</B>(<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
                                         <A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Adds numeric operands or concatenates string operands, resembling the addition 
 operator in JavaScript.</p>
 <p>If one operand is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var + other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="in(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
in</H3>
<PRE>
public static final boolean <B>in</B>(java.lang.Object&nbsp;var,
                               java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks if the first operand is the name of a property of the second, resembling 
 the <tt>in</tt> operator in JavaScript.</p>
 <p>This operation converts the first operand to a string and expects the second 
 operand be an object (or array).</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any value that is or can be converted to a string.<DD><CODE>other</CODE> - Any object or array.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is the name of a property of the 
 second operand; <tt>false</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var in other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="instanceOf(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
instanceOf</H3>
<PRE>
public static final boolean <B>instanceOf</B>(java.lang.Object&nbsp;var,
                                       java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks if the first operand is an instance of the second, resembling the 
 <tt>instanceof</tt> operator in JavaScript.</p>
 <p>This operation expects the first operand be an object and the second be a class 
 of objects. In JavaScript, classes of objects are defined by the constructor function 
 that initializes them.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any value or object.<DD><CODE>other</CODE> - A constructor function.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is an instance of the second; 
 <tt>false</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var instanceof other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="shl(java.lang.Object, int)"><!-- --></A><H3>
shl</H3>
<PRE>
public static final int <B>shl</B>(java.lang.Object&nbsp;var,
                            int&nbsp;n)</PRE>
<DL>
<DD><p>Shift-left operation, resembling that of JavaScript, moves all bits in the first 
 operand to the left by the number of places specified in the second operand, which 
 should be an integer between 0 and 31.</p>
 <p>A zero is used for the new first bit, and the value of the 32nd bit is lost. 
 Shifting a value left by one position is equivalent to multiplying by 2, shifting 
 two positions is equivalent to multiplying by 4, etc.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd. The shift operation requires a right-side operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A numeric value.<DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted integer number.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var << n</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="shr(java.lang.Object, int)"><!-- --></A><H3>
shr</H3>
<PRE>
public static final int <B>shr</B>(java.lang.Object&nbsp;var,
                            int&nbsp;n)</PRE>
<DL>
<DD><p>Shift-right operation, resembling that of JavaScript, moves all bits in the first 
 operand to the right by the number of places specified in the second operand (an 
 integer between 0 and 31). Bits that are shifted off the right are lost. The bits 
 filled in on the left depend on the sign bit of the original operand, in order to 
 preserve the sign of the result. If the first operand is positive, the result has 
 zeros placed in the high bits; if the first operand is negative, the result has ones 
 placed in the high bits.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd. The shift operation requires a right-side operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A numeric value.<DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted integer number.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var >> n</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="shru(java.lang.Object, int)"><!-- --></A><H3>
shru</H3>
<PRE>
public static final int <B>shru</B>(java.lang.Object&nbsp;var,
                             int&nbsp;n)</PRE>
<DL>
<DD><p>Shift-right-unsigned operation, resembling that of JavaScript, moves all bits in 
 the first operand to the right by the number of places specified in the second 
 operand (an integer between 0 and 31). Bits that are shifted off the right are lost. 
 The result has zeros placed in the high bits.</p>
 <p>This operation is just like <A HREF="../js/Js.html#shr(java.lang.Object, int)"><CODE>shr(Object, int)</CODE></A>, except that the bits shifted 
 in on the left are always zero, regardless of the sign of the first operand.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd. The shift operation requires a right-side operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A numeric value.<DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted integer number.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var >>> n</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="bnot(java.lang.Object)"><!-- --></A><H3>
bnot</H3>
<PRE>
public static final int <B>bnot</B>(java.lang.Object&nbsp;var)</PRE>
<DL>
<DD><p>Bitwise-NOT operation, resembling that of JavaScript, operates by reversing all 
 bits in the operand.</p>
 <p>Because of the way signed integers are represented in JavaScript, applying this 
 operation to a value is equivalent to changing its sign and subtracting 1.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-NOT of the operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>~var</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="band(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
band</H3>
<PRE>
public static final int <B>band</B>(java.lang.Object&nbsp;var,
                             java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Bitwise-AND operation, resembling that of JavaScript, performs a boolean AND 
 operation on each bit of the integer arguments. A bit is set in the result only if 
 the corresponding bit is set in both operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A numeric value.<DD><CODE>other</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var & other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="bor(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
bor</H3>
<PRE>
public static final int <B>bor</B>(java.lang.Object&nbsp;var,
                            java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Bitwise-OR operation, resembling that of JavaScript, performs a boolean OR operation 
 on each bit of the integer arguments. A bit is set in the result if the corresponding 
 bit is set in one or both of the operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A numeric value.<DD><CODE>other</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var | other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="xor(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
xor</H3>
<PRE>
public static final int <B>xor</B>(java.lang.Object&nbsp;var,
                            java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Bitwise-XOR operation, resembling that of JavaScript, performs a boolean exclusive 
 OR operation on each bit of the integer arguments. Exclusive OR means that either 
 operand one is <tt>true</tt> or operand two is <tt>true</tt>, but not both. A bit is 
 set in this operation's result if a corresponding bit is set in one (but not both) 
 of the two operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A numeric value.<DD><CODE>other</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-exclusive-OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var ^ other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lt(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lt</H3>
<PRE>
public static final boolean <B>lt</B>(java.lang.Object&nbsp;var,
                               java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Less-than operation, resembling that of JavaScript, evaluates to <tt>true</tt> if 
 the first operand is less than the second operand; otherwise it evaluates to 
 <tt>false</tt>.</p>
 <p>The operands of this operation may be of any type. Comparison can be performed 
 only on numbers and strings, however, so operands that are not numbers or strings 
 are converted. Comparison and conversion occur as follows:</p>
 <ul>
 <li>If both operands are numbers, or if both convert to numbers, they are compared 
 numerically.</li>
 <li>If both operands are strings or convert to strings, they are compared as 
 strings.</li>
 <li>If one operand is or converts to a string, and one is or converts to a number, 
 the operation attempts to convert the string to a number and performs a numerical 
 comparison. If the string does not represent a number, it converts to <tt>NaN</tt>, 
 and the comparison is <tt>false</tt>. In JavaScript 1.1, the string-to-number 
 conversion causes an error instead of yielding <tt>NaN</tt>.</li>
 <li>If an object can be converted to either a number or a string, JavaScript performs 
 the numerical conversion. This means, for example, that Date objects are compared 
 numerically, and it is meaningful to compare two dates to see whether one is earlier 
 than the other.</li>
 <li>If the operands of the comparison operations cannot both be successfully converted 
 to numbers or to strings, these operations always return <tt>false</tt>.</li>
 <li>If either operand is or converts to <tt>NaN</tt>, the comparison operation always 
 yields <tt>false</tt>.</li>
 </ul>
 <p>Keep in mind that string comparison is done on a strict character-by-character 
 basis using the numerical value of each character from the Unicode encoding. Although 
 in some cases the Unicode standard allows equivalent strings to be encoded using 
 different sequences of characters, the JavaScript comparison operations do not 
 detect these encoding differences; they assume that all strings are expressed in 
 normalized form. Note in particular that string comparison is case-sensitive, and 
 in the Unicode encoding (at least for the ASCII subset), all capital letters are 
 "less than" all lowercase letters. This rule can cause confusing results if you do 
 not expect it.</p>
 <p>For a more robust string-comparison algorithm, see the <A HREF="../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> 
 method, which also takes locale-specific definitions of alphabetical order into account. 
 For case-insensitive comparisons, you must first convert the strings to all lowercase or 
 all uppercase using <A HREF="../js/StringLike.html#toLowerCase()"><CODE>StringLike.toLowerCase()</CODE></A> or <A HREF="../js/StringLike.html#toUpperCase()"><CODE>StringLike.toUpperCase()</CODE></A>.</p>
 <p>The less-than-or-equal and greater-than-or-equal operations do not rely on the 
 equality or identity operations for determining whether two values are "equal." 
 Instead, the less-than-or-equal operator is simply defined as "not greater than", 
 and the greater-than-or-equal operator is defined as "not less than". The one 
 exception occurs when either operand is (or converts to) <tt>NaN</tt>, in which case 
 all comparison operations return <tt>false</tt>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is less than the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var < other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="gt(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
gt</H3>
<PRE>
public static final boolean <B>gt</B>(java.lang.Object&nbsp;var,
                               java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Greater-than operation, resembling that of JavaScript, evaluates to <tt>true</tt> if 
 the first operand is greater than the second operand; otherwise it evaluates to 
 <tt>false</tt>.</p>
 <p>The operands of this operation may be of any type. Comparison can be performed 
 only on numbers and strings, however, so operands that are not numbers or strings 
 are converted. Comparison and conversion occur as follows:</p>
 <ul>
 <li>If both operands are numbers, or if both convert to numbers, they are compared 
 numerically.</li>
 <li>If both operands are strings or convert to strings, they are compared as 
 strings.</li>
 <li>If one operand is or converts to a string, and one is or converts to a number, 
 the operation attempts to convert the string to a number and performs a numerical 
 comparison. If the string does not represent a number, it converts to <tt>NaN</tt>, 
 and the comparison is <tt>false</tt>. In JavaScript 1.1, the string-to-number 
 conversion causes an error instead of yielding <tt>NaN</tt>.</li>
 <li>If an object can be converted to either a number or a string, JavaScript performs 
 the numerical conversion. This means, for example, that Date objects are compared 
 numerically, and it is meaningful to compare two dates to see whether one is earlier 
 than the other.</li>
 <li>If the operands of the comparison operations cannot both be successfully converted 
 to numbers or to strings, these operations always return <tt>false</tt>.</li>
 <li>If either operand is or converts to <tt>NaN</tt>, the comparison operation always 
 yields <tt>false</tt>.</li>
 </ul>
 <p>Keep in mind that string comparison is done on a strict character-by-character 
 basis using the numerical value of each character from the Unicode encoding. Although 
 in some cases the Unicode standard allows equivalent strings to be encoded using 
 different sequences of characters, the JavaScript comparison operations do not 
 detect these encoding differences; they assume that all strings are expressed in 
 normalized form. Note in particular that string comparison is case-sensitive, and 
 in the Unicode encoding (at least for the ASCII subset), all capital letters are 
 "less than" all lowercase letters. This rule can cause confusing results if you do 
 not expect it.</p>
 <p>For a more robust string-comparison algorithm, see the <A HREF="../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> 
 method, which also takes locale-specific definitions of alphabetical order into account. 
 For case-insensitive comparisons, you must first convert the strings to all lowercase or 
 all uppercase using <A HREF="../js/StringLike.html#toLowerCase()"><CODE>StringLike.toLowerCase()</CODE></A> or <A HREF="../js/StringLike.html#toUpperCase()"><CODE>StringLike.toUpperCase()</CODE></A>.</p>
 <p>The less-than-or-equal and greater-than-or-equal operations do not rely on the 
 equality or identity operations for determining whether two values are "equal." 
 Instead, the less-than-or-equal operator is simply defined as "not greater than", 
 and the greater-than-or-equal operator is defined as "not less than". The one 
 exception occurs when either operand is (or converts to) <tt>NaN</tt>, in which case 
 all comparison operations return <tt>false</tt>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is greater than the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var > other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lte(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lte</H3>
<PRE>
public static final boolean <B>lte</B>(java.lang.Object&nbsp;var,
                                java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Less-than-or-equal operation, resembling that of JavaScript, evaluates to 
 <tt>true</tt> if the first operand is less than or equal to the second operand; 
 otherwise it evaluates to <tt>false</tt>.</p>
 <p>The operands of this operation may be of any type. Comparison can be performed 
 only on numbers and strings, however, so operands that are not numbers or strings 
 are converted. Comparison and conversion occur as follows:</p>
 <ul>
 <li>If both operands are numbers, or if both convert to numbers, they are compared 
 numerically.</li>
 <li>If both operands are strings or convert to strings, they are compared as 
 strings.</li>
 <li>If one operand is or converts to a string, and one is or converts to a number, 
 the operation attempts to convert the string to a number and performs a numerical 
 comparison. If the string does not represent a number, it converts to <tt>NaN</tt>, 
 and the comparison is <tt>false</tt>. In JavaScript 1.1, the string-to-number 
 conversion causes an error instead of yielding <tt>NaN</tt>.</li>
 <li>If an object can be converted to either a number or a string, JavaScript performs 
 the numerical conversion. This means, for example, that Date objects are compared 
 numerically, and it is meaningful to compare two dates to see whether one is earlier 
 than the other.</li>
 <li>If the operands of the comparison operations cannot both be successfully converted 
 to numbers or to strings, these operations always return <tt>false</tt>.</li>
 <li>If either operand is or converts to <tt>NaN</tt>, the comparison operation always 
 yields <tt>false</tt>.</li>
 </ul>
 <p>Keep in mind that string comparison is done on a strict character-by-character 
 basis using the numerical value of each character from the Unicode encoding. Although 
 in some cases the Unicode standard allows equivalent strings to be encoded using 
 different sequences of characters, the JavaScript comparison operations do not 
 detect these encoding differences; they assume that all strings are expressed in 
 normalized form. Note in particular that string comparison is case-sensitive, and 
 in the Unicode encoding (at least for the ASCII subset), all capital letters are 
 "less than" all lowercase letters. This rule can cause confusing results if you do 
 not expect it.</p>
 <p>For a more robust string-comparison algorithm, see the <A HREF="../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> 
 method, which also takes locale-specific definitions of alphabetical order into account. 
 For case-insensitive comparisons, you must first convert the strings to all lowercase or 
 all uppercase using <A HREF="../js/StringLike.html#toLowerCase()"><CODE>StringLike.toLowerCase()</CODE></A> or <A HREF="../js/StringLike.html#toUpperCase()"><CODE>StringLike.toUpperCase()</CODE></A>.</p>
 <p>The less-than-or-equal and greater-than-or-equal operations do not rely on the 
 equality or identity operations for determining whether two values are "equal." 
 Instead, the less-than-or-equal operator is simply defined as "not greater than", 
 and the greater-than-or-equal operator is defined as "not less than". The one 
 exception occurs when either operand is (or converts to) <tt>NaN</tt>, in which case 
 all comparison operations return <tt>false</tt>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is less than or equal to the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var <= other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="gte(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
gte</H3>
<PRE>
public static final boolean <B>gte</B>(java.lang.Object&nbsp;var,
                                java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Greater-than-or-equal operation, resembling that of JavaScript, evaluates to 
 <tt>true</tt> if the first operand is greater than or equal to the second operand; 
 otherwise it evaluates to <tt>false</tt>.</p>
 <p>The operands of this operation may be of any type. Comparison can be performed 
 only on numbers and strings, however, so operands that are not numbers or strings 
 are converted. Comparison and conversion occur as follows:</p>
 <ul>
 <li>If both operands are numbers, or if both convert to numbers, they are compared 
 numerically.</li>
 <li>If both operands are strings or convert to strings, they are compared as 
 strings.</li>
 <li>If one operand is or converts to a string, and one is or converts to a number, 
 the operation attempts to convert the string to a number and performs a numerical 
 comparison. If the string does not represent a number, it converts to <tt>NaN</tt>, 
 and the comparison is <tt>false</tt>. In JavaScript 1.1, the string-to-number 
 conversion causes an error instead of yielding <tt>NaN</tt>.</li>
 <li>If an object can be converted to either a number or a string, JavaScript performs 
 the numerical conversion. This means, for example, that Date objects are compared 
 numerically, and it is meaningful to compare two dates to see whether one is earlier 
 than the other.</li>
 <li>If the operands of the comparison operations cannot both be successfully converted 
 to numbers or to strings, these operations always return <tt>false</tt>.</li>
 <li>If either operand is or converts to <tt>NaN</tt>, the comparison operation always 
 yields <tt>false</tt>.</li>
 </ul>
 <p>Keep in mind that string comparison is done on a strict character-by-character 
 basis using the numerical value of each character from the Unicode encoding. Although 
 in some cases the Unicode standard allows equivalent strings to be encoded using 
 different sequences of characters, the JavaScript comparison operations do not 
 detect these encoding differences; they assume that all strings are expressed in 
 normalized form. Note in particular that string comparison is case-sensitive, and 
 in the Unicode encoding (at least for the ASCII subset), all capital letters are 
 "less than" all lowercase letters. This rule can cause confusing results if you do 
 not expect it.</p>
 <p>For a more robust string-comparison algorithm, see the <A HREF="../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> 
 method, which also takes locale-specific definitions of alphabetical order into account. 
 For case-insensitive comparisons, you must first convert the strings to all lowercase or 
 all uppercase using <A HREF="../js/StringLike.html#toLowerCase()"><CODE>StringLike.toLowerCase()</CODE></A> or <A HREF="../js/StringLike.html#toUpperCase()"><CODE>StringLike.toUpperCase()</CODE></A>.</p>
 <p>The less-than-or-equal and greater-than-or-equal operations do not rely on the 
 equality or identity operations for determining whether two values are "equal." 
 Instead, the less-than-or-equal operator is simply defined as "not greater than", 
 and the greater-than-or-equal operator is defined as "not less than". The one 
 exception occurs when either operand is (or converts to) <tt>NaN</tt>, in which case 
 all comparison operations return <tt>false</tt>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is greater than or equal to the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var >= other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="eq(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
eq</H3>
<PRE>
public static final boolean <B>eq</B>(java.lang.Object&nbsp;var,
                               java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are equal according to the 
 equality operation:
 <ul>
 <li>If the two values have the same type, test them for identity. If the values are 
 identical, they are equal; if they are not identical, they are not equal.</li>
 <li>If the two values do not have the same type, they may still be equal. Use the 
 following rules and type conversions to check for equality:</li>
 <ul>
 <li>If one value is null and the other is undefined, they are equal.</li>
 <li>If one value is a number and the other is a string, convert the string to a 
 number and try the comparison again, using the converted value.</li>
 <li>If either value is <tt>true</tt>, convert it to 1 and try the comparison 
 again. If either value is <tt>false</tt>, convert it to 0 and try the comparison 
 again.</li>
 <li>If one value is an object and the other is a number or string, convert the 
 object to a primitive and try the comparison again. An object is converted to a 
 primitive value by either its <tt>toString()</tt> method or its <tt>valueOf()</tt> 
 method. The built-in classes of core JavaScript attempt <tt>valueOf()</tt> 
 conversion before <tt>toString()</tt> conversion, except for the Date class, 
 which performs <tt>toString()</tt> conversion. Objects that are not part of core 
 JavaScript may convert themselves to primitive values in an implementation-defined 
 way.</li>
 <li>Any other combinations of values are not equal.</li>
 </ul>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any value or object.<DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand equals the second; <tt>false</tt>, 
 otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var == other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="eqs(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
eqs</H3>
<PRE>
public static final boolean <B>eqs</B>(java.lang.Object&nbsp;var,
                                java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are identical according to the identity operation:
 <ul>
 <li>If the two values have different types, they are not identical.</li>
 <li>If both values are numbers and have the same value, they are identical, unless 
 either or both values are <tt>NaN</tt>, in which case they are not identical. 
 The <tt>NaN</tt> value is never identical to any other value, including itself! 
 To check whether a value is <tt>NaN</tt>, use the global <A HREF="../js/Js.html#isNaN(java.lang.Object)"><CODE>isNaN(Object)</CODE></A> 
 function.</li>
 <li>If both values are strings and contain exactly the same characters in the same 
 positions, they are identical. If the strings differ in length or content, they are 
 not identical. Note that in some cases, the Unicode standard allows more than one 
 way to encode the same string. For efficiency, however, JavaScript's string 
 comparison compares strictly on a character-by-character basis, and it assumes that 
 all strings have been converted to a "normalized form" before they are compared. 
 See the <A HREF="../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> for another way to compare strings.</li>
 <li>If both values are the boolean value <tt>true</tt> or both are the boolean 
 value <tt>false</tt>, they are identical.</li>
 <li>If both values refer to the same object, array, or function, they are identical. 
 If they refer to different objects (or arrays or functions) they are not identical, 
 even if both objects have identical properties or both arrays have identical elements.</li>
 <li>If both values are null or both values are undefined, they are identical.</li>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any value or object.<DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is identical to the second; 
 <tt>false</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var === other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="neq(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
neq</H3>
<PRE>
public static final boolean <B>neq</B>(java.lang.Object&nbsp;var,
                                java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are not "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are equal according to the 
 equality operation:
 <ul>
 <li>If the two values have the same type, test them for identity. If the values are 
 identical, they are equal; if they are not identical, they are not equal.</li>
 <li>If the two values do not have the same type, they may still be equal. Use the 
 following rules and type conversions to check for equality:</li>
 <ul>
 <li>If one value is null and the other is undefined, they are equal.</li>
 <li>If one value is a number and the other is a string, convert the string to a 
 number and try the comparison again, using the converted value.</li>
 <li>If either value is <tt>true</tt>, convert it to 1 and try the comparison 
 again. If either value is <tt>false</tt>, convert it to 0 and try the comparison 
 again.</li>
 <li>If one value is an object and the other is a number or string, convert the 
 object to a primitive and try the comparison again. An object is converted to a 
 primitive value by either its <tt>toString()</tt> method or its <tt>valueOf()</tt> 
 method. The built-in classes of core JavaScript attempt <tt>valueOf()</tt> 
 conversion before <tt>toString()</tt> conversion, except for the Date class, 
 which performs <tt>toString()</tt> conversion. Objects that are not part of core 
 JavaScript may convert themselves to primitive values in an implementation-defined 
 way.</li>
 <li>Any other combinations of values are not equal.</li>
 </ul>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any value or object.<DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>false</tt> if the first operand equals the second; <tt>true</tt>, 
 otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var != other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="neqs(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
neqs</H3>
<PRE>
public static final boolean <B>neqs</B>(java.lang.Object&nbsp;var,
                                 java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are not "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are identical according to the identity operation:
 <ul>
 <li>If the two values have different types, they are not identical.</li>
 <li>If both values are numbers and have the same value, they are identical, unless 
 either or both values are <tt>NaN</tt>, in which case they are not identical. 
 The <tt>NaN</tt> value is never identical to any other value, including itself! 
 To check whether a value is <tt>NaN</tt>, use the global <A HREF="../js/Js.html#isNaN(java.lang.Object)"><CODE>isNaN(Object)</CODE></A> 
 function.</li>
 <li>If both values are strings and contain exactly the same characters in the same 
 positions, they are identical. If the strings differ in length or content, they are 
 not identical. Note that in some cases, the Unicode standard allows more than one 
 way to encode the same string. For efficiency, however, JavaScript's string 
 comparison compares strictly on a character-by-character basis, and it assumes that 
 all strings have been converted to a "normalized form" before they are compared. 
 See the <A HREF="../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> for another way to compare strings.</li>
 <li>If both values are the boolean value <tt>true</tt> or both are the boolean 
 value <tt>false</tt>, they are identical.</li>
 <li>If both values refer to the same object, array, or function, they are identical. 
 If they refer to different objects (or arrays or functions) they are not identical, 
 even if both objects have identical properties or both arrays have identical elements.</li>
 <li>If both values are null or both values are undefined, they are identical.</li>
 </ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any value or object.<DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>false</tt> if the first operand is identical to the second; 
 <tt>true</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var !== other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="not(java.lang.Object)"><!-- --></A><H3>
not</H3>
<PRE>
public static final boolean <B>not</B>(java.lang.Object&nbsp;var)</PRE>
<DL>
<DD><p>Inverts the boolean value of its operand, resembling the logical NOT operator 
 in JavaScript.</p>
 <p>This operation converts its operand to a boolean value using the following rules 
 if necessary before inverting the converted value.</p>
 <ul>
 <li>If a number is used where a boolean value is expected, the number is converted 
 to <tt>true</tt> unless the number is 0 or NaN, which are converted to <tt>false</tt>.</li>
 <li>If a string is used where a boolean value is expected, it is converted to <tt>true</tt> 
 except for the empty string, which is converted to <tt>false</tt>.</li>
 <li><tt>null</tt> and the undefined value convert to <tt>false</tt>, and any 
 non-null object, array, or function converts to <tt>true</tt>.
 </ul>
 <p>You can convert any value <tt>x</tt> to its equivalent boolean value by applying 
 this operation twice: <tt>Js.not(Js.not(x))</tt></p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical NOT operator of the 
 Java language like this:
 <pre>!Js.be(var)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.
<DT><B>Returns:</B><DD>The inverted boolean value.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>!var</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="and(T, T)"><!-- --></A><H3>
and</H3>
<PRE>
public static final &lt;T&gt; T <B>and</B>(T&nbsp;var,
                              T&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Var,java.lang.Object)"><!-- --></A><A NAME="and(js.Var, T)"><!-- --></A><H3>
and</H3>
<PRE>
public static final &lt;T&gt; T <B>and</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
                              T&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.Object,js.Var)"><!-- --></A><A NAME="and(T, js.Var)"><!-- --></A><H3>
and</H3>
<PRE>
public static final &lt;T&gt; T <B>and</B>(T&nbsp;var,
                              <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.Boolean, js.core.JsBoolean)"><!-- --></A><H3>
and</H3>
<PRE>
public static final <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A> <B>and</B>(java.lang.Boolean&nbsp;var,
                                  <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Var, js.core.JsBoolean)"><!-- --></A><H3>
and</H3>
<PRE>
public static final <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A> <B>and</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Boolean&gt;&nbsp;var,
                                  <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsBoolean, java.lang.Boolean)"><!-- --></A><H3>
and</H3>
<PRE>
public static final java.lang.Boolean <B>and</B>(<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;var,
                                          java.lang.Boolean&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsBoolean, js.Var)"><!-- --></A><H3>
and</H3>
<PRE>
public static final java.lang.Boolean <B>and</B>(<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;var,
                                          <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Boolean&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.Character, js.core.JsNumber)"><!-- --></A><H3>
and</H3>
<PRE>
public static final <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A> <B>and</B>(java.lang.Character&nbsp;var,
                                 <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.Number, js.core.JsNumber)"><!-- --></A><H3>
and</H3>
<PRE>
public static final <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A> <B>and</B>(java.lang.Number&nbsp;var,
                                 <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Var, js.core.JsNumber)"><!-- --></A><H3>
and</H3>
<PRE>
public static final <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A> <B>and</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
                                 <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Value, js.core.JsNumber)"><!-- --></A><H3>
and</H3>
<PRE>
public static final <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A> <B>and</B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Character&gt;&nbsp;var,
                                 <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsNumber, java.lang.Character)"><!-- --></A><H3>
and</H3>
<PRE>
public static final java.lang.Number <B>and</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
                                         java.lang.Character&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsNumber, java.lang.Number)"><!-- --></A><H3>
and</H3>
<PRE>
public static final java.lang.Number <B>and</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
                                         java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsNumber, js.Var)"><!-- --></A><H3>
and</H3>
<PRE>
public static final java.lang.Number <B>and</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
                                         <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsNumber, js.Value)"><!-- --></A><H3>
and</H3>
<PRE>
public static final java.lang.Number <B>and</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
                                         <A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Character&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.String, js.core.JsString)"><!-- --></A><H3>
and</H3>
<PRE>
public static final <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A> <B>and</B>(java.lang.String&nbsp;var,
                                 <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Var, js.core.JsString)"><!-- --></A><H3>
and</H3>
<PRE>
public static final <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A> <B>and</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.String&gt;&nbsp;var,
                                 <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsString, java.lang.String)"><!-- --></A><H3>
and</H3>
<PRE>
public static final java.lang.String <B>and</B>(<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;var,
                                         java.lang.String&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsString, js.Var)"><!-- --></A><H3>
and</H3>
<PRE>
public static final java.lang.String <B>and</B>(<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;var,
                                         <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.String&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="or(T, T)"><!-- --></A><H3>
or</H3>
<PRE>
public static final &lt;T&gt; T <B>or</B>(T&nbsp;var,
                             T&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Var,java.lang.Object)"><!-- --></A><A NAME="or(js.Var, T)"><!-- --></A><H3>
or</H3>
<PRE>
public static final &lt;T&gt; T <B>or</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
                             T&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.Object,js.Var)"><!-- --></A><A NAME="or(T, js.Var)"><!-- --></A><H3>
or</H3>
<PRE>
public static final &lt;T&gt; T <B>or</B>(T&nbsp;var,
                             <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsBoolean, java.lang.Boolean)"><!-- --></A><H3>
or</H3>
<PRE>
public static final <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A> <B>or</B>(<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;var,
                                 java.lang.Boolean&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsBoolean, js.Var)"><!-- --></A><H3>
or</H3>
<PRE>
public static final <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A> <B>or</B>(<A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;var,
                                 <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Boolean&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.Boolean, js.core.JsBoolean)"><!-- --></A><H3>
or</H3>
<PRE>
public static final java.lang.Boolean <B>or</B>(java.lang.Boolean&nbsp;var,
                                         <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Var, js.core.JsBoolean)"><!-- --></A><H3>
or</H3>
<PRE>
public static final java.lang.Boolean <B>or</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.Boolean&gt;&nbsp;var,
                                         <A HREF="../js/core/JsBoolean.html" title="class in js.core">JsBoolean</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsNumber, java.lang.Character)"><!-- --></A><H3>
or</H3>
<PRE>
public static final <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A> <B>or</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
                                java.lang.Character&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsNumber, java.lang.Number)"><!-- --></A><H3>
or</H3>
<PRE>
public static final <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A> <B>or</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
                                java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsNumber, js.Var)"><!-- --></A><H3>
or</H3>
<PRE>
public static final <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A> <B>or</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
                                <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsNumber, js.Value)"><!-- --></A><H3>
or</H3>
<PRE>
public static final <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A> <B>or</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;var,
                                <A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Character&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.Number, js.core.JsNumber)"><!-- --></A><H3>
or</H3>
<PRE>
public static final java.lang.Number <B>or</B>(java.lang.Number&nbsp;var,
                                        <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.Character, js.core.JsNumber)"><!-- --></A><H3>
or</H3>
<PRE>
public static final java.lang.Number <B>or</B>(java.lang.Character&nbsp;var,
                                        <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Var, js.core.JsNumber)"><!-- --></A><H3>
or</H3>
<PRE>
public static final java.lang.Number <B>or</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends java.lang.Number&gt;&nbsp;var,
                                        <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Value, js.core.JsNumber)"><!-- --></A><H3>
or</H3>
<PRE>
public static final java.lang.Number <B>or</B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Character&gt;&nbsp;var,
                                        <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsString, java.lang.String)"><!-- --></A><H3>
or</H3>
<PRE>
public static final <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A> <B>or</B>(<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;var,
                                java.lang.String&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsString, js.Var)"><!-- --></A><H3>
or</H3>
<PRE>
public static final <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A> <B>or</B>(<A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;var,
                                <A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.String&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.String, js.core.JsString)"><!-- --></A><H3>
or</H3>
<PRE>
public static final java.lang.String <B>or</B>(java.lang.String&nbsp;var,
                                        <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Var, js.core.JsString)"><!-- --></A><H3>
or</H3>
<PRE>
public static final java.lang.String <B>or</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;java.lang.String&gt;&nbsp;var,
                                        <A HREF="../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object,java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="cond(java.lang.Object, T, T)"><!-- --></A><H3>
cond</H3>
<PRE>
public static final &lt;T&gt; T <B>cond</B>(java.lang.Object&nbsp;test,
                               T&nbsp;var,
                               T&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>test ? var : other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object,js.Var,java.lang.Object)"><!-- --></A><A NAME="cond(java.lang.Object, js.Var, T)"><!-- --></A><H3>
cond</H3>
<PRE>
public static final &lt;T&gt; T <B>cond</B>(java.lang.Object&nbsp;test,
                               <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
                               T&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>test ? var : other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object,java.lang.Object,js.Var)"><!-- --></A><A NAME="cond(java.lang.Object, T, js.Var)"><!-- --></A><H3>
cond</H3>
<PRE>
public static final &lt;T&gt; T <B>cond</B>(java.lang.Object&nbsp;test,
                               T&nbsp;var,
                               <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>test ? var : other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsObject,js.core.JsObject)"><!-- --></A><A NAME="and(T, T)"><!-- --></A><H3>
and</H3>
<PRE>
public static final &lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; T <B>and</B>(T&nbsp;var,
                                               T&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Var,js.core.JsObject)"><!-- --></A><A NAME="and(js.Var, T)"><!-- --></A><H3>
and</H3>
<PRE>
public static final &lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; T <B>and</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
                                               T&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsObject,js.Var)"><!-- --></A><A NAME="and(T, js.Var)"><!-- --></A><H3>
and</H3>
<PRE>
public static final &lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; T <B>and</B>(T&nbsp;var,
                                               <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Var, js.Var)"><!-- --></A><H3>
and</H3>
<PRE>
public static final &lt;T&gt; T <B>and</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
                              <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var && other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsObject,js.core.JsObject)"><!-- --></A><A NAME="or(T, T)"><!-- --></A><H3>
or</H3>
<PRE>
public static final &lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; T <B>or</B>(T&nbsp;var,
                                              T&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Var,js.core.JsObject)"><!-- --></A><A NAME="or(js.Var, T)"><!-- --></A><H3>
or</H3>
<PRE>
public static final &lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; T <B>or</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
                                              T&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsObject,js.Var)"><!-- --></A><A NAME="or(T, js.Var)"><!-- --></A><H3>
or</H3>
<PRE>
public static final &lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; T <B>or</B>(T&nbsp;var,
                                              <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Var, js.Var)"><!-- --></A><H3>
or</H3>
<PRE>
public static final &lt;T&gt; T <B>or</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
                             <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Js.html#and(T, T)"><CODE>and(Object, Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var || other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object,js.core.JsObject,js.core.JsObject)"><!-- --></A><A NAME="cond(java.lang.Object, T, T)"><!-- --></A><H3>
cond</H3>
<PRE>
public static final &lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; T <B>cond</B>(java.lang.Object&nbsp;test,
                                                T&nbsp;var,
                                                T&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>test ? var : other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object,js.Var,js.core.JsObject)"><!-- --></A><A NAME="cond(java.lang.Object, js.Var, T)"><!-- --></A><H3>
cond</H3>
<PRE>
public static final &lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; T <B>cond</B>(java.lang.Object&nbsp;test,
                                                <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
                                                T&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>test ? var : other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object,js.core.JsObject,js.Var)"><!-- --></A><A NAME="cond(java.lang.Object, T, js.Var)"><!-- --></A><H3>
cond</H3>
<PRE>
public static final &lt;T extends <A HREF="../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; T <B>cond</B>(java.lang.Object&nbsp;test,
                                                T&nbsp;var,
                                                <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>test ? var : other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, js.Var, js.Var)"><!-- --></A><H3>
cond</H3>
<PRE>
public static final &lt;T&gt; T <B>cond</B>(java.lang.Object&nbsp;test,
                               <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;var,
                               <A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends T&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>test ? var : other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="comma(java.lang.Object,java.lang.Object)"><!-- --></A><A NAME="comma(java.lang.Object, T)"><!-- --></A><H3>
comma</H3>
<PRE>
public static final &lt;T&gt; T <B>comma</B>(java.lang.Object&nbsp;var,
                                T&nbsp;other)</PRE>
<DL>
<DD><p>Comma operation, resembling the comma operator of JavaScript, evaluates the 
 first operand, evaluates the second operand, and then returns the value of the 
 second operand.</p>
 <p>In JavaScript, this strange operator is useful only in a few limited circumstances, 
 primarily when you need to evaluate several independent expressions with side effects 
 in a situation where only a single expression is allowed. In practice, the comma 
 operator is really used only in conjunction with the <tt>for</tt> loop statement.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - A value or object.<DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the static invocation of this method with the 
 JavaScript expression:
 <pre>var, other</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lneg(java.lang.Object)"><!-- --></A><H3>
lneg</H3>
<PRE>
public static final long <B>lneg</B>(java.lang.Object&nbsp;var)</PRE>
<DL>
<DD><p>Performs unary negation on a 64-bit integer.</p>
 <p>This operation converts a positive value to an equivalently negative value, and 
 vice versa. If the operand is not a 64-bit integer, it attempts to convert it to one.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision. </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The negation of the 64-bit integer.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a negation operation on a long number, 
 such as the byte codes compiled from the following Java expression:  
 <pre>-((Number)var).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lnot(java.lang.Object)"><!-- --></A><H3>
lnot</H3>
<PRE>
public static final long <B>lnot</B>(java.lang.Object&nbsp;var)</PRE>
<DL>
<DD><p>The 64-bit bitwise-NOT operation, casting the operand to a <tt>long</tt> number 
 if it is not 64-bit, operates by reversing all bits in the 64-bit integer.</p>
 <p>Because of the way signed integers are represented in JavaScript, applying this 
 operation to a value is equivalent to changing its sign and subtracting 1.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The bitwise-NOT of the 64-bit integer.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a bitwise-NOT operation on a long number, 
 such as the byte codes compiled from the following Java expression:  
 <pre>~((Number)var).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ladd(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
ladd</H3>
<PRE>
public static final long <B>ladd</B>(java.lang.Object&nbsp;var,
                              java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Adds two 64-bit integers, casting the operands to <tt>long</tt> numbers if any 
 one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The sum of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of an addition operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() + ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lsub(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lsub</H3>
<PRE>
public static final long <B>lsub</B>(java.lang.Object&nbsp;var,
                              java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Subtracts the second 64-bit integer from the first 64-bit integer, casting the 
 operands to <tt>long</tt> numbers if any one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The difference between the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a subtraction operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() - ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lmul(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lmul</H3>
<PRE>
public static final long <B>lmul</B>(java.lang.Object&nbsp;var,
                              java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Multiplies the two 64-bit integer, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The product of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a multiplication operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() * ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ldiv(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
ldiv</H3>
<PRE>
public static final long <B>ldiv</B>(java.lang.Object&nbsp;var,
                              java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Divides the first 64-bit integer by the second 64-bit integer, casting the operands 
 to <tt>long</tt> numbers if any one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The quotient of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of an division operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() / ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lmod(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lmod</H3>
<PRE>
public static final long <B>lmod</B>(java.lang.Object&nbsp;var,
                              java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Computes the first operand modulo the second operand, casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</p>
 <p>The operation returns the remainder when the first operand is divided by the 
 second operand a certain number of times. The sign of the result is the same as the 
 sign of the first operand.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The remainder.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a modulo operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() % ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lshl(java.lang.Object, int)"><!-- --></A><H3>
lshl</H3>
<PRE>
public static final long <B>lshl</B>(java.lang.Object&nbsp;var,
                              int&nbsp;n)</PRE>
<DL>
<DD><p>The 64-bit shift-left operation, casting the first operand to a <tt>long</tt> 
 number if it is not 64-bit, moves all bits in it to the left by the number of places 
 specified in the second operand, which should be an integer between 0 and 63.</p>
 <p>A zero is used for the new first bit, and the value of the 64th bit is lost. 
 Shifting a value left by one position is equivalent to multiplying by 2, shifting 
 two positions is equivalent to multiplying by 4, etc.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted 64-bit integer.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a shift-left operation on a long number, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() << n</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lshr(java.lang.Object, int)"><!-- --></A><H3>
lshr</H3>
<PRE>
public static final long <B>lshr</B>(java.lang.Object&nbsp;var,
                              int&nbsp;n)</PRE>
<DL>
<DD><p>The 64-bit shift-right operation, casting the first operand to a <tt>long</tt> 
 number if it is not 64-bit, moves all bits in it to the right by the number of 
 places specified in the second operand (an integer between 0 and 63). Bits that are 
 shifted off the right are lost. The bits filled in on the left depend on the sign 
 bit of the original operand, in order to preserve the sign of the result. If the 
 first operand is positive, the result has zeros placed in the high bits; if the 
 first operand is negative, the result has ones placed in the high bits.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted 64-bit integer.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a shift-right operation on a long number, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() >> n</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lshru(java.lang.Object, int)"><!-- --></A><H3>
lshru</H3>
<PRE>
public static final long <B>lshru</B>(java.lang.Object&nbsp;var,
                               int&nbsp;n)</PRE>
<DL>
<DD><p>The 64-bit shift-right-unsigned operation, casting the first operand to a 
 <tt>long</tt> number if it is not 64-bit, moves all bits in it to the right by the 
 number of places specified in the second operand (an integer between 0 and 63). Bits 
 that are shifted off the right are lost. The result has zeros placed in the high 
 bits.</p>
 <p>This operation is just like <A HREF="../js/Js.html#lshr(java.lang.Object, int)"><CODE>lshr(Object, int)</CODE></A>, except that the bits shifted 
 in on the left are always zero, regardless of the sign of the first operand.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted 64-bit integer.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of an unsigned shift-right operation on a long number, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() >>> n</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="land(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
land</H3>
<PRE>
public static final long <B>land</B>(java.lang.Object&nbsp;var,
                              java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit bitwise-AND operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, performs a boolean AND operation on each 
 bit of the 64-bit integers. A bit is set in the result only if the corresponding 
 bit is set in both operands.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The bitwise-AND of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a bitwise AND operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() & ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lor(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lor</H3>
<PRE>
public static final long <B>lor</B>(java.lang.Object&nbsp;var,
                             java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit bitwise-OR operation, casting the operands to <tt>long</tt> numbers if 
 any one of them is not a 64-bit integer, performs a boolean OR operation on each bit 
 of the 64-bit integers. A bit is set in the result if the corresponding bit is set 
 in one or both of the operands.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The bitwise-OR of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a bitwise OR operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() | ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lxor(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lxor</H3>
<PRE>
public static final long <B>lxor</B>(java.lang.Object&nbsp;var,
                              java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit bitwise-XOR operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, performs a boolean exclusive OR operation 
 on each bit of the 64-bit integers. Exclusive OR means that either operand one is 
 <tt>true</tt> or operand two is <tt>true</tt>, but not both. A bit is set in this 
 operation's result if a corresponding bit is set in one (but not both) of the two 
 operands.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The bitwise-exclusive-OR of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a bitwise exclusive OR operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() ^ ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="llt(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
llt</H3>
<PRE>
public static final boolean <B>llt</B>(java.lang.Object&nbsp;var,
                                java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit less-than operation, casting the operands to <tt>long</tt> numbers if 
 any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the first 
 operand is less than the second operand; otherwise it evaluates to <tt>false</tt>.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is less than the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a less-than operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() < ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lgt(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lgt</H3>
<PRE>
public static final boolean <B>lgt</B>(java.lang.Object&nbsp;var,
                                java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit greater-than operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the first 
 operand is greater than the second operand; otherwise it evaluates to <tt>false</tt>.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is greater than the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a greater-than operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() > ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="llte(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
llte</H3>
<PRE>
public static final boolean <B>llte</B>(java.lang.Object&nbsp;var,
                                 java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit less-than-or-equal operation, casting the operands to <tt>long</tt> 
 numbers if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if 
 the first operand is less than or equal to the second operand; otherwise it evaluates 
 to <tt>false</tt>.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is less than or equal to the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a less-than-or-equal operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() <= ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lgte(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lgte</H3>
<PRE>
public static final boolean <B>lgte</B>(java.lang.Object&nbsp;var,
                                 java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit greater-than-or-equal operation, casting the operands to <tt>long</tt> 
 numbers if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the 
 first operand is greater than or equal to the second operand; otherwise it evaluates 
 to <tt>false</tt>.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is greater than or equal to the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a greater-than-or-equal operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() >= ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="leq(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
leq</H3>
<PRE>
public static final boolean <B>leq</B>(java.lang.Object&nbsp;var,
                                java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two 64-bit integers are "equal", casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand equals the second; <tt>false</tt>, 
 otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of an equality operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() == ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lneq(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lneq</H3>
<PRE>
public static final boolean <B>lneq</B>(java.lang.Object&nbsp;var,
                                 java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two 64-bit integers are not "equal", casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - Any numeric value.<DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>false</tt> if the first operand equals the second; <tt>true</tt>, 
 otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the static invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of an inequality operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)var).longValue() != ((Number)other).longValue()</pre></DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Js.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
JScripter(JS) Standard 1.0 API & Re-compilation Specification</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../js/Initializer.html" title="class in js"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../js/JsApplet.html" title="class in js"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?js/Js.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Js.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_classes_inherited_from_class_js.Function">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright &#169; 2008-2011 J.J.Liu (www.jscripter.org). All Rights Reserved.</i>
</BODY>
</HTML>
