<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_25) on Thu Sep 15 00:19:46 CST 2011 -->
<TITLE>
Value.Integer (JScripter(JS) Standard 1.0 API & Re-compilation Specification)
</TITLE>

<META NAME="date" CONTENT="2011-09-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Value.Integer (JScripter(JS) Standard 1.0 API & Re-compilation Specification)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Value.Integer.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
JScripter(JS) Standard 1.0 API & Re-compilation Specification</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../js/Value.Float.Member.html" title="class in js"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../js/Value.Integer.Member.html" title="class in js"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?js/Value.Integer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Value.Integer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
js</FONT>
<BR>
Class Value.Integer</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../js/Disposable.html" title="class in js">js.Disposable</A>
      <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../js/Var.html" title="class in js">js.Var</A>&lt;T&gt;
          <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../js/Value.html" title="class in js">js.Value</A>&lt;T&gt;
              <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../js/Value.Numerical.html" title="class in js">js.Value.Numerical</A>&lt;java.lang.Integer&gt;
                  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>js.Value.Integer</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;java.lang.Integer&gt;</DD>
</DL>
<DL>
<DT><B>Enclosing class:</B><DD><A HREF="../js/Value.html" title="class in js">Value</A>&lt;<A HREF="../js/Value.html" title="type parameter in Value">T</A>&gt;</DD>
</DL>
<HR>
<DL>
<DT><PRE>public static class <B>Value.Integer</B><DT>extends <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;java.lang.Integer&gt;<DT>implements <A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;java.lang.Integer&gt;</DL>
</PRE>

<P>
<p>An <b>opaque</b> class resembling JavaScript primitive integer number values.</p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD><a href="mailto:jianjunliu@126.com">J.J.Liu (Jianjun Liu)</a> at <a href="http://www.jscripter.org" target="_blank">http://www.jscripter.org</a></DD>
<DT><B>JavaScript:</B></DT>
  <DD><b>Opaque</b> types can be resolved but no class objects for them can be 
 generated into the target codes. Re-compilers must exit with error on the operations of 
 accessing that kind of class objects.</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.Member.html" title="class in js">Value.Integer.Member</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An <b>opaque</b> class representing members of its enclosing <b>opaque</b> type.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_js.Value"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class js.<A HREF="../js/Value.html" title="class in js">Value</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Value.Boolean.html" title="class in js">Value.Boolean</A>, <A HREF="../js/Value.Byte.html" title="class in js">Value.Byte</A>, <A HREF="../js/Value.Character.html" title="class in js">Value.Character</A>, <A HREF="../js/Value.Double.html" title="class in js">Value.Double</A>, <A HREF="../js/Value.Float.html" title="class in js">Value.Float</A>, <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>, <A HREF="../js/Value.Long.html" title="class in js">Value.Long</A>, <A HREF="../js/Value.Number.html" title="class in js">Value.Number</A>, <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;<A HREF="../js/Value.Numerical.html" title="type parameter in Value.Numerical">T</A>&gt;, <A HREF="../js/Value.Short.html" title="class in js">Value.Short</A>, <A HREF="../js/Value.String.html" title="class in js">Value.String</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_js.Var"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class js.<A HREF="../js/Var.html" title="class in js">Var</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Var.Generic.html" title="class in js">Var.Generic</A>&lt;<A HREF="../js/Var.Generic.html" title="type parameter in Var.Generic">T</A>&gt;, <A HREF="../js/Var.Members.html" title="class in js">Var.Members</A>, <A HREF="../js/Var.Mid.html" title="class in js">Var.Mid</A></CODE></TD>
</TR>
</TABLE>
&nbsp;

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../js/Value.Integer.html#Value.Integer(java.lang.Byte)">Value.Integer</A></B>(java.lang.Byte&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a primitive <tt>int</tt> instance from a primitive value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../js/Value.Integer.html#Value.Integer(java.lang.Character)">Value.Integer</A></B>(java.lang.Character&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a primitive <tt>int</tt> instance from a primitive value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../js/Value.Integer.html#Value.Integer(java.lang.Integer)">Value.Integer</A></B>(java.lang.Integer&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a primitive <tt>int</tt> instance from a primitive value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../js/Value.Integer.html#Value.Integer(java.lang.Number)">Value.Integer</A></B>(java.lang.Number&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a primitive <tt>int</tt> instance from a primitive value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../js/Value.Integer.html#Value.Integer(java.lang.Short)">Value.Integer</A></B>(java.lang.Short&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a primitive <tt>int</tt> instance from a primitive value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../js/Value.Integer.html#Value.Integer(js.Value.Byte)">Value.Integer</A></B>(<A HREF="../js/Value.Byte.html" title="class in js">Value.Byte</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a primitive <tt>int</tt> instance from a primitive value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../js/Value.Integer.html#Value.Integer(js.Value.Character)">Value.Integer</A></B>(<A HREF="../js/Value.Character.html" title="class in js">Value.Character</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a primitive <tt>int</tt> instance from a primitive value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../js/Value.Integer.html#Value.Integer(js.Value.Integer)">Value.Integer</A></B>(<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a primitive <tt>int</tt> instance from a primitive value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../js/Value.Integer.html#Value.Integer(js.Value.Short)">Value.Integer</A></B>(<A HREF="../js/Value.Short.html" title="class in js">Value.Short</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a primitive <tt>int</tt> instance from a primitive value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../js/Value.Integer.html#Value.Integer(js.Var)">Value.Integer</A></B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends java.lang.Number&gt;&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a primitive <tt>int</tt> instance from a primitive value.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#aadd(java.lang.Object)">aadd</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a numeric operand to the current primitive instance and returns the 
 numeric operand, resembling the assignment-with-addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#aand(java.lang.Object)">aand</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-bitwise-AND operation, resembling that of JavaScript, performs a boolean AND 
 operation on each bit of the integer arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#adiv(java.lang.Object)">adiv</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Divides, by a numeric operand, the current primitive instance and returns the 
 numeric operand, resembling the assignment-with-division operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#amod(java.lang.Object)">amod</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modulo operates a numeric operand onto the current primitive instance and 
 returns the numeric operand, resembling the assignment-with-modulo operator in 
 JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#amul(java.lang.Object)">amul</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiplies a numeric operand to the current primitive instance and returns the 
 numeric operand, resembling the assignment-with-multiplication operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#and(java.lang.Integer)">and</A></B>(java.lang.Integer&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#and(js.Value.Integer)">and</A></B>(<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#and(js.Value)">and</A></B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Integer&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#aor(java.lang.Object)">aor</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-bitwise-OR operation, resembling that of JavaScript, performs a boolean OR operation 
 on each bit of the integer arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#ashl(int)">ashl</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-shift-left operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the left by the number of places specified in the 
 second operand, which should be an integer between 0 and 31.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#ashr(int)">ashr</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-shift-right operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#ashru(int)">ashru</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-shift-right-unsigned operation, resembling that of JavaScript, moves all bits in 
 the current primitive instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#asub(java.lang.Object)">asub</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subtracts a numeric operand from the current primitive instance and returns the 
 numeric operand, resembling the assignment-with-subtraction operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#axor(java.lang.Object)">axor</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-bitwise-XOR operation, resembling that of JavaScript, performs a boolean exclusive 
 OR operation on each bit of the integer arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#cond(java.lang.Object, java.lang.Integer)">cond</A></B>(java.lang.Object&nbsp;test,
     java.lang.Integer&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#cond(java.lang.Object, js.Value.Integer)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#cond(java.lang.Object, js.Value)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Integer&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#dec()">dec</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decreases the current primitive instance by 1 and then returns the current 
 primitive instance, resembling the pre-decrement operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#decp()">decp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a copy of the current primitive instance and then decreases the 
 current primitive instance by 1, resembling the post-decrement operator in 
 JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#inc()">inc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increases the current primitive instance by 1 and then returns the current 
 primitive instance, resembling the pre-increment operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#incp()">incp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a copy of the current primitive instance and then increases the 
 current primitive instance by 1, resembling the post-increment operator in 
 JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#neg()">neg</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs unary negation, resembling the unary minus operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#or(java.lang.Integer)">or</A></B>(java.lang.Integer&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#or(js.Value.Integer)">or</A></B>(<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#or(js.Value)">or</A></B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Integer&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Integer.html#valueOf()">valueOf</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the current instance, if there is one.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Value.Numerical"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Value.Numerical.html#add(java.lang.Number)">add</A>, <A HREF="../js/Value.Numerical.html#add(js.Value)">add</A>, <A HREF="../js/Value.Numerical.html#and(java.lang.Character)">and</A>, <A HREF="../js/Value.Numerical.html#and(js.core.JsNumber)">and</A>, <A HREF="../js/Value.Numerical.html#and(java.lang.Number)">and</A>, <A HREF="../js/Value.Numerical.html#and(js.Value.Numerical)">and</A>, <A HREF="../js/Value.Numerical.html#cond(java.lang.Object, java.lang.Character)">cond</A>, <A HREF="../js/Value.Numerical.html#cond(java.lang.Object, java.lang.Number)">cond</A>, <A HREF="../js/Value.Numerical.html#cond(java.lang.Object, js.Value.Numerical)">cond</A>, <A HREF="../js/Value.Numerical.html#or(java.lang.Character)">or</A>, <A HREF="../js/Value.Numerical.html#or(js.core.JsNumber)">or</A>, <A HREF="../js/Value.Numerical.html#or(java.lang.Number)">or</A>, <A HREF="../js/Value.Numerical.html#or(js.Value.Numerical)">or</A>, <A HREF="../js/Value.Numerical.html#toExponential()">toExponential</A>, <A HREF="../js/Value.Numerical.html#toExponential(java.lang.Object)">toExponential</A>, <A HREF="../js/Value.Numerical.html#toFixed()">toFixed</A>, <A HREF="../js/Value.Numerical.html#toFixed(java.lang.Object)">toFixed</A>, <A HREF="../js/Value.Numerical.html#toLocaleString()">toLocaleString</A>, <A HREF="../js/Value.Numerical.html#toPrecision()">toPrecision</A>, <A HREF="../js/Value.Numerical.html#toPrecision(java.lang.Object)">toPrecision</A>, <A HREF="../js/Value.Numerical.html#toString(java.lang.Object)">toString</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Value"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../js/Value.html" title="class in js">Value</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Value.html#add(java.lang.Object)">add</A>, <A HREF="../js/Value.html#add(java.lang.String)">add</A>, <A HREF="../js/Value.html#add(js.Var)">add</A>, <A HREF="../js/Value.html#and(js.Var)">and</A>, <A HREF="../js/Value.html#band(java.lang.Object)">band</A>, <A HREF="../js/Value.html#be()">be</A>, <A HREF="../js/Value.html#bnot()">bnot</A>, <A HREF="../js/Value.html#bor(java.lang.Object)">bor</A>, <A HREF="../js/Value.html#cond(java.lang.Object, js.Var)">cond</A>, <A HREF="../js/Value.html#delete()">delete</A>, <A HREF="../js/Value.html#div(java.lang.Object)">div</A>, <A HREF="../js/Value.html#eq(java.lang.Object)">eq</A>, <A HREF="../js/Value.html#eqs(java.lang.Object)">eqs</A>, <A HREF="../js/Value.html#gt(java.lang.Object)">gt</A>, <A HREF="../js/Value.html#gte(java.lang.Object)">gte</A>, <A HREF="../js/Value.html#in(java.lang.Object)">in</A>, <A HREF="../js/Value.html#instanceOf(java.lang.Object)">instanceOf</A>, <A HREF="../js/Value.html#ladd(java.lang.Object)">ladd</A>, <A HREF="../js/Value.html#land(java.lang.Object)">land</A>, <A HREF="../js/Value.html#ldiv(java.lang.Object)">ldiv</A>, <A HREF="../js/Value.html#leq(java.lang.Object)">leq</A>, <A HREF="../js/Value.html#lgt(java.lang.Object)">lgt</A>, <A HREF="../js/Value.html#lgte(java.lang.Object)">lgte</A>, <A HREF="../js/Value.html#llt(java.lang.Object)">llt</A>, <A HREF="../js/Value.html#llte(java.lang.Object)">llte</A>, <A HREF="../js/Value.html#lmod(java.lang.Object)">lmod</A>, <A HREF="../js/Value.html#lmul(java.lang.Object)">lmul</A>, <A HREF="../js/Value.html#lneg()">lneg</A>, <A HREF="../js/Value.html#lneq(java.lang.Object)">lneq</A>, <A HREF="../js/Value.html#lnot()">lnot</A>, <A HREF="../js/Value.html#lor(java.lang.Object)">lor</A>, <A HREF="../js/Value.html#lshl(int)">lshl</A>, <A HREF="../js/Value.html#lshr(int)">lshr</A>, <A HREF="../js/Value.html#lshru(int)">lshru</A>, <A HREF="../js/Value.html#lsub(java.lang.Object)">lsub</A>, <A HREF="../js/Value.html#lt(java.lang.Object)">lt</A>, <A HREF="../js/Value.html#lte(java.lang.Object)">lte</A>, <A HREF="../js/Value.html#lxor(java.lang.Object)">lxor</A>, <A HREF="../js/Value.html#mod(java.lang.Object)">mod</A>, <A HREF="../js/Value.html#mul(java.lang.Object)">mul</A>, <A HREF="../js/Value.html#neq(java.lang.Object)">neq</A>, <A HREF="../js/Value.html#neqs(java.lang.Object)">neqs</A>, <A HREF="../js/Value.html#not()">not</A>, <A HREF="../js/Value.html#or(js.Var)">or</A>, <A HREF="../js/Value.html#shl(int)">shl</A>, <A HREF="../js/Value.html#shr(int)">shr</A>, <A HREF="../js/Value.html#shru(int)">shru</A>, <A HREF="../js/Value.html#sub(java.lang.Object)">sub</A>, <A HREF="../js/Value.html#var()">var</A>, <A HREF="../js/Value.html#var(T)">var</A>, <A HREF="../js/Value.html#var(js.Var)">var</A>, <A HREF="../js/Value.html#xor(java.lang.Object)">xor</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Var"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../js/Var.html" title="class in js">Var</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Var.html#equals(java.lang.Object)">equals</A>, <A HREF="../js/Var.html#hashCode()">hashCode</A>, <A HREF="../js/Var.html#toString()">toString</A>, <A HREF="../js/Var.html#typeof()">typeof</A>, <A HREF="../js/Var.html#undefined()">undefined</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsArray)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsBoolean)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsDate)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsFunction)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsNumber)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsRegExp)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsString)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.Var.Generic)">var</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Disposable"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../js/Disposable.html" title="class in js">Disposable</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Disposable.html#finalize()">finalize</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, getClass, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.NumberLike"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface js.<A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/NumberLike.html#toExponential()">toExponential</A>, <A HREF="../js/NumberLike.html#toExponential(java.lang.Object)">toExponential</A>, <A HREF="../js/NumberLike.html#toFixed()">toFixed</A>, <A HREF="../js/NumberLike.html#toFixed(java.lang.Object)">toFixed</A>, <A HREF="../js/NumberLike.html#toLocaleString()">toLocaleString</A>, <A HREF="../js/NumberLike.html#toPrecision()">toPrecision</A>, <A HREF="../js/NumberLike.html#toPrecision(java.lang.Object)">toPrecision</A>, <A HREF="../js/NumberLike.html#toString()">toString</A>, <A HREF="../js/NumberLike.html#toString(java.lang.Object)">toString</A>, <A HREF="../js/NumberLike.html#typeof()">typeof</A>, <A HREF="../js/NumberLike.html#undefined()">undefined</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Value.Integer(java.lang.Integer)"><!-- --></A><H3>
Value.Integer</H3>
<PRE>
public <B>Value.Integer</B>(java.lang.Integer&nbsp;value)</PRE>
<DL>
<DD><p>Constructs a primitive <tt>int</tt> instance from a primitive value.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="Value.Integer(js.Value.Integer)"><!-- --></A><H3>
Value.Integer</H3>
<PRE>
public <B>Value.Integer</B>(<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>&nbsp;value)</PRE>
<DL>
<DD><p>Constructs a primitive <tt>int</tt> instance from a primitive value.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="Value.Integer(java.lang.Byte)"><!-- --></A><H3>
Value.Integer</H3>
<PRE>
public <B>Value.Integer</B>(java.lang.Byte&nbsp;value)</PRE>
<DL>
<DD><p>Constructs a primitive <tt>int</tt> instance from a primitive value.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="Value.Integer(js.Value.Byte)"><!-- --></A><H3>
Value.Integer</H3>
<PRE>
public <B>Value.Integer</B>(<A HREF="../js/Value.Byte.html" title="class in js">Value.Byte</A>&nbsp;value)</PRE>
<DL>
<DD><p>Constructs a primitive <tt>int</tt> instance from a primitive value.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="Value.Integer(java.lang.Short)"><!-- --></A><H3>
Value.Integer</H3>
<PRE>
public <B>Value.Integer</B>(java.lang.Short&nbsp;value)</PRE>
<DL>
<DD><p>Constructs a primitive <tt>int</tt> instance from a primitive value.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="Value.Integer(js.Value.Short)"><!-- --></A><H3>
Value.Integer</H3>
<PRE>
public <B>Value.Integer</B>(<A HREF="../js/Value.Short.html" title="class in js">Value.Short</A>&nbsp;value)</PRE>
<DL>
<DD><p>Constructs a primitive <tt>int</tt> instance from a primitive value.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="Value.Integer(java.lang.Number)"><!-- --></A><H3>
Value.Integer</H3>
<PRE>
public <B>Value.Integer</B>(java.lang.Number&nbsp;value)</PRE>
<DL>
<DD><p>Constructs a primitive <tt>int</tt> instance from a primitive value.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="Value.Integer(js.Var)"><!-- --></A><H3>
Value.Integer</H3>
<PRE>
public <B>Value.Integer</B>(<A HREF="../js/Var.html" title="class in js">Var</A>&lt;? extends java.lang.Number&gt;&nbsp;value)</PRE>
<DL>
<DD><p>Constructs a primitive <tt>int</tt> instance from a primitive value.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="Value.Integer(java.lang.Character)"><!-- --></A><H3>
Value.Integer</H3>
<PRE>
public <B>Value.Integer</B>(java.lang.Character&nbsp;value)</PRE>
<DL>
<DD><p>Constructs a primitive <tt>int</tt> instance from a primitive value.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="Value.Integer(js.Value.Character)"><!-- --></A><H3>
Value.Integer</H3>
<PRE>
public <B>Value.Integer</B>(<A HREF="../js/Value.Character.html" title="class in js">Value.Character</A>&nbsp;value)</PRE>
<DL>
<DD><p>Constructs a primitive <tt>int</tt> instance from a primitive value.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="valueOf()"><!-- --></A><H3>
valueOf</H3>
<PRE>
public final java.lang.Integer <B>valueOf</B>()</PRE>
<DL>
<DD><p>Returns the primitive value associated with the current instance, if there is one.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../js/NumberLike.html#valueOf()">valueOf</A></CODE> in interface <CODE><A HREF="../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;java.lang.Integer&gt;</CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../js/Value.Numerical.html#valueOf()">valueOf</A></CODE> in class <CODE><A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;java.lang.Integer&gt;</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The primitive value associated with the current instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current instance without changing the method 
 name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="neg()"><!-- --></A><H3>
neg</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>neg</B>()</PRE>
<DL>
<DD><p>Performs unary negation, resembling the unary minus operator in JavaScript.</p>
 <p>This operation converts a positive value to an equivalently negative value, and 
 vice versa. If the operand is not a number, it attempts to convert it to one.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The negation of the current primitive instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>-p</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this 
 method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="inc()"><!-- --></A><H3>
inc</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>inc</B>()</PRE>
<DL>
<DD><p>Increases the current primitive instance by 1 and then returns the current 
 primitive instance, resembling the pre-increment operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The current primitive instance increased by 1.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>++p</pre>
 where <tt>p</tt> is the primitive value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="dec()"><!-- --></A><H3>
dec</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>dec</B>()</PRE>
<DL>
<DD><p>Decreases the current primitive instance by 1 and then returns the current 
 primitive instance, resembling the pre-decrement operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The current primitive instance increased by 1.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>--p</pre>
 where <tt>p</tt> is the primitive value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="incp()"><!-- --></A><H3>
incp</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>incp</B>()</PRE>
<DL>
<DD><p>Returns a copy of the current primitive instance and then increases the 
 current primitive instance by 1, resembling the post-increment operator in 
 JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A copy of the original primitive instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p++</pre>
 where <tt>p</tt> is the primitive value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="decp()"><!-- --></A><H3>
decp</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>decp</B>()</PRE>
<DL>
<DD><p>Returns a copy of the current primitive instance and then decreases the 
 current primitive instance by 1, resembling the post-decrement operator in 
 JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A copy of the undecremented primitive instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p--</pre>
 where <tt>p</tt> is the primitive value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="aadd(java.lang.Object)"><!-- --></A><H3>
aadd</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>aadd</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Adds a numeric operand to the current primitive instance and returns the 
 numeric operand, resembling the assignment-with-addition operator in JavaScript.</p>
 <p>If one value is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>Js.valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>Js.toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A value or object.
<DT><B>Returns:</B><DD>The <tt>int</tt> value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p += (int)value</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="asub(java.lang.Object)"><!-- --></A><H3>
asub</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>asub</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Subtracts a numeric operand from the current primitive instance and returns the 
 numeric operand, resembling the assignment-with-subtraction operator in JavaScript.</p>
 <p>If used with non-numeric values, this operation attempts to convert them to 
 numbers.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A value or object.
<DT><B>Returns:</B><DD>The <tt>int</tt> value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p += (int)value</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="amul(java.lang.Object)"><!-- --></A><H3>
amul</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>amul</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Multiplies a numeric operand to the current primitive instance and returns the 
 numeric operand, resembling the assignment-with-multiplication operator in JavaScript.</p>
 <p>If used with non-numeric values, this operation attempts to convert them to 
 numbers.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A value or object.
<DT><B>Returns:</B><DD>The <tt>int</tt> value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p *= (int)value</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="adiv(java.lang.Object)"><!-- --></A><H3>
adiv</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>adiv</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Divides, by a numeric operand, the current primitive instance and returns the 
 numeric operand, resembling the assignment-with-division operator in JavaScript.</p>
 <p>Used with non-numeric values, this operation attempts to convert them to 
 numbers. If you are used to programming languages that distinguish between integer 
 and floating-point numbers, you might expect to get an integer result when you 
 divide one integer by another. In JavaScript, however, all numbers are floating-point, 
 so all division operations have floating-point results. Division by zero yields positive 
 or negative infinity, while <tt>0/0</tt> evaluates to <tt>NaN</tt>.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A value or object.
<DT><B>Returns:</B><DD>The <tt>int</tt> value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p /= (int)value</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="amod(java.lang.Object)"><!-- --></A><H3>
amod</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>amod</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Modulo operates a numeric operand onto the current primitive instance and 
 returns the numeric operand, resembling the assignment-with-modulo operator in 
 JavaScript.</p>
 <p>The operation computes the remainder when the current primitive instance is 
 divided by the operand a certain number of times. If used with non-numeric values, 
 the operation attempts to convert them to numbers. The sign of the result is the 
 same as the sign of the current primitive instance.</p>
 <p>This operation is typically used with integer values, it also works for 
 floating-point values.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A value or object.
<DT><B>Returns:</B><DD>The <tt>int</tt> value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p %= (int)value</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ashl(int)"><!-- --></A><H3>
ashl</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>ashl</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>Assignment-with-shift-left operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the left by the number of places specified in the 
 second operand, which should be an integer between 0 and 31.</p>
 <p>A zero is used for the new first bit, and the value of the 32nd bit is lost. 
 Shifting a value left by one position is equivalent to multiplying by 2, shifting 
 two positions is equivalent to multiplying by 4, etc.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with values that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the values to 
 32-bit integers by dropping any fractional part of the value or any bits beyond 
 the 32nd. The shift operation requires a (right-side) operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted primitive instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p <<= n & 0x3f</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ashr(int)"><!-- --></A><H3>
ashr</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>ashr</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>Assignment-with-shift-right operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31). Bits that are shifted off the right 
 are lost. The bits filled in on the left depend on the sign bit of the original 
 value, in order to preserve the sign of the result. If the current primitive 
 instance is positive, the result has zeros placed in the high bits; if the current 
 primitive instance is negative, the result has ones placed in the high bits.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with values that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the values to 
 32-bit integers by dropping any fractional part of the value or any bits beyond 
 the 32nd. The shift operation requires a (right-side) operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted primitive instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p >>= n & 0x3f</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ashru(int)"><!-- --></A><H3>
ashru</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>ashru</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>Assignment-with-shift-right-unsigned operation, resembling that of JavaScript, moves all bits in 
 the current primitive instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31). Bits that are shifted off the right 
 are lost. The result has zeros placed in the high bits.</p>
 <p>This operation is just like <A HREF="../js/Value.html#shr(int)"><CODE>Value.shr(int)</CODE></A>, except that the bits shifted 
 in on the left are always zero, regardless of the sign of the current primitive instance.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with values that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the values to 
 32-bit integers by dropping any fractional part of the value or any bits beyond 
 the 32nd. The shift operation requires a (right-side) operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted primitive instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p >>>= n & 0x3f</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="aand(java.lang.Object)"><!-- --></A><H3>
aand</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>aand</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Assignment-with-bitwise-AND operation, resembling that of JavaScript, performs a boolean AND 
 operation on each bit of the integer arguments. A bit is set in the result only if 
 the corresponding bit is set in both operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p &= (int)value</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="aor(java.lang.Object)"><!-- --></A><H3>
aor</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>aor</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Assignment-with-bitwise-OR operation, resembling that of JavaScript, performs a boolean OR operation 
 on each bit of the integer arguments. A bit is set in the result if the corresponding 
 bit is set in one or both of the operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p |= (int)value</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="axor(java.lang.Object)"><!-- --></A><H3>
axor</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>axor</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Assignment-with-bitwise-XOR operation, resembling that of JavaScript, performs a boolean exclusive 
 OR operation on each bit of the integer arguments. Exclusive OR means that either 
 operand one is <tt>true</tt> or operand two is <tt>true</tt>, but not both. A bit is 
 set in this operation's result if a corresponding bit is set in one (but not both) 
 of the two operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-exclusive-OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>p ^= (int)value</pre>
 where <tt>p</tt> is the integer value of the current primitive instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.Integer)"><!-- --></A><H3>
and</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>and</B>(java.lang.Integer&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../js/Value.html#and(T)">and</A></CODE> in class <CODE><A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Integer&gt;</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Value)"><!-- --></A><H3>
and</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>and</B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Integer&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Value.Integer)"><!-- --></A><H3>
and</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>and</B>(<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.Integer)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>or</B>(java.lang.Integer&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Value.html#and(T)"><CODE>Value.and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../js/Value.html#or(T)">or</A></CODE> in class <CODE><A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Integer&gt;</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Value)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>or</B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Integer&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Value.html#and(T)"><CODE>Value.and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Value.Integer)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>or</B>(<A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Value.html#and(T)"><CODE>Value.and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, java.lang.Integer)"><!-- --></A><H3>
cond</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>cond</B>(java.lang.Object&nbsp;test,
                                java.lang.Integer&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../js/Value.html#cond(java.lang.Object, T)">cond</A></CODE> in class <CODE><A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Integer&gt;</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, js.Value)"><!-- --></A><H3>
cond</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>cond</B>(java.lang.Object&nbsp;test,
                                <A HREF="../js/Value.html" title="class in js">Value</A>&lt;java.lang.Integer&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, js.Value.Integer)"><!-- --></A><H3>
cond</H3>
<PRE>
public final <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A> <B>cond</B>(java.lang.Object&nbsp;test,
                                <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Value.Integer.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
JScripter(JS) Standard 1.0 API & Re-compilation Specification</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../js/Value.Float.Member.html" title="class in js"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../js/Value.Integer.Member.html" title="class in js"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?js/Value.Integer.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Value.Integer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright &#169; 2008-2011 J.J.Liu (www.jscripter.org). All Rights Reserved.</i>
</BODY>
</HTML>
