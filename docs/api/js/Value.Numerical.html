<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_25) on Thu Sep 15 00:19:46 CST 2011 -->
<TITLE>
Value.Numerical (JScripter(JS) Standard 1.0 API & Re-compilation Specification)
</TITLE>

<META NAME="date" CONTENT="2011-09-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Value.Numerical (JScripter(JS) Standard 1.0 API & Re-compilation Specification)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Value.Numerical.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
JScripter(JS) Standard 1.0 API & Re-compilation Specification</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../js/Value.Number.Member.html" title="class in js"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../js/Value.Short.html" title="class in js"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?js/Value.Numerical.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Value.Numerical.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_classes_inherited_from_class_js.Value">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
js</FONT>
<BR>
Class Value.Numerical&lt;T&gt;</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../js/Disposable.html" title="class in js">js.Disposable</A>
      <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../js/Var.html" title="class in js">js.Var</A>&lt;T&gt;
          <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../js/Value.html" title="class in js">js.Value</A>&lt;T&gt;
              <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>js.Value.Numerical&lt;T&gt;</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../js/Value.Byte.html" title="class in js">Value.Byte</A>, <A HREF="../js/Value.Character.html" title="class in js">Value.Character</A>, <A HREF="../js/Value.Double.html" title="class in js">Value.Double</A>, <A HREF="../js/Value.Float.html" title="class in js">Value.Float</A>, <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>, <A HREF="../js/Value.Long.html" title="class in js">Value.Long</A>, <A HREF="../js/Value.Number.html" title="class in js">Value.Number</A>, <A HREF="../js/Value.Short.html" title="class in js">Value.Short</A></DD>
</DL>
<DL>
<DT><B>Enclosing class:</B><DD><A HREF="../js/Value.html" title="class in js">Value</A>&lt;<A HREF="../js/Value.html" title="type parameter in Value">T</A>&gt;</DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract static class <B>Value.Numerical&lt;T&gt;</B><DT>extends <A HREF="../js/Value.html" title="class in js">Value</A>&lt;T&gt;</DL>
</PRE>

<P>
<p>An <b>opaque</b> class resembling JavaScript primitive number values.</p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD><a href="mailto:jianjunliu@126.com">J.J.Liu (Jianjun Liu)</a> at <a href="http://www.jscripter.org" target="_blank">http://www.jscripter.org</a></DD>
<DT><B>JavaScript:</B></DT>
  <DD><b>Opaque</b> types can be resolved but no class objects for them can be 
 generated into the target codes. Re-compilers must exit with error on the operations of 
 accessing that kind of class objects.</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_js.Value"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class js.<A HREF="../js/Value.html" title="class in js">Value</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Value.Boolean.html" title="class in js">Value.Boolean</A>, <A HREF="../js/Value.Byte.html" title="class in js">Value.Byte</A>, <A HREF="../js/Value.Character.html" title="class in js">Value.Character</A>, <A HREF="../js/Value.Double.html" title="class in js">Value.Double</A>, <A HREF="../js/Value.Float.html" title="class in js">Value.Float</A>, <A HREF="../js/Value.Integer.html" title="class in js">Value.Integer</A>, <A HREF="../js/Value.Long.html" title="class in js">Value.Long</A>, <A HREF="../js/Value.Member.html" title="class in js">Value.Member</A>&lt;<A HREF="../js/Value.Member.html" title="type parameter in Value.Member">T</A>&gt;, <A HREF="../js/Value.Number.html" title="class in js">Value.Number</A>, <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;<A HREF="../js/Value.Numerical.html" title="type parameter in Value.Numerical">T</A>&gt;, <A HREF="../js/Value.Short.html" title="class in js">Value.Short</A>, <A HREF="../js/Value.String.html" title="class in js">Value.String</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_js.Var"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class js.<A HREF="../js/Var.html" title="class in js">Var</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Var.Generic.html" title="class in js">Var.Generic</A>&lt;<A HREF="../js/Var.Generic.html" title="type parameter in Var.Generic">T</A>&gt;, <A HREF="../js/Var.Members.html" title="class in js">Var.Members</A>, <A HREF="../js/Var.Mid.html" title="class in js">Var.Mid</A></CODE></TD>
</TR>
</TABLE>
&nbsp;

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#Value.Numerical(T)">Value.Numerical</A></B>(<A HREF="../js/Value.Numerical.html" title="type parameter in Value.Numerical">T</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Number.html" title="class in js">Value.Number</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#add(java.lang.Number)">add</A></B>(java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the current primitive instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Number.html" title="class in js">Value.Number</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#add(js.Value)">add</A></B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the current primitive instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#and(java.lang.Character)">and</A></B>(java.lang.Character&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#and(js.core.JsNumber)">and</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#and(java.lang.Number)">and</A></B>(java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#and(js.Value.Numerical)">and</A></B>(<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#cond(java.lang.Object, java.lang.Character)">cond</A></B>(java.lang.Object&nbsp;test,
     java.lang.Character&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#cond(java.lang.Object, java.lang.Number)">cond</A></B>(java.lang.Object&nbsp;test,
     java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#cond(java.lang.Object, js.Value.Numerical)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#or(java.lang.Character)">or</A></B>(java.lang.Character&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Number.html" title="class in js">Value.Number</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#or(js.core.JsNumber)">or</A></B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#or(java.lang.Number)">or</A></B>(java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#or(js.Value.Numerical)">or</A></B>(<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#toExponential()">toExponential</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the current number to a string using exponential notation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#toExponential(java.lang.Object)">toExponential</A></B>(java.lang.Object&nbsp;digits)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the current number to a string using exponential notation with the 
 specified number of digits after the decimal place.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#toFixed()">toFixed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the current number to a string without digits after the decimal place.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#toFixed(java.lang.Object)">toFixed</A></B>(java.lang.Object&nbsp;digits)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the current number to a string that contains a specified number of 
 digits after the decimal place.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#toLocaleString()">toLocaleString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the current number to a string using local number-formatting conventions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#toPrecision()">toPrecision</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the current number to a string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#toPrecision(java.lang.Object)">toPrecision</A></B>(java.lang.Object&nbsp;precision)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the current number to a string using the specified number of significant 
 digits.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#toString(java.lang.Object)">toString</A></B>(java.lang.Object&nbsp;radix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the current number to a string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../js/Value.Numerical.html#valueOf()">valueOf</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the current instance, if there is one.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Value"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../js/Value.html" title="class in js">Value</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Value.html#add(java.lang.Object)">add</A>, <A HREF="../js/Value.html#add(java.lang.String)">add</A>, <A HREF="../js/Value.html#add(js.Var)">add</A>, <A HREF="../js/Value.html#and(T)">and</A>, <A HREF="../js/Value.html#and(js.Var)">and</A>, <A HREF="../js/Value.html#band(java.lang.Object)">band</A>, <A HREF="../js/Value.html#be()">be</A>, <A HREF="../js/Value.html#bnot()">bnot</A>, <A HREF="../js/Value.html#bor(java.lang.Object)">bor</A>, <A HREF="../js/Value.html#cond(java.lang.Object, T)">cond</A>, <A HREF="../js/Value.html#cond(java.lang.Object, js.Var)">cond</A>, <A HREF="../js/Value.html#delete()">delete</A>, <A HREF="../js/Value.html#div(java.lang.Object)">div</A>, <A HREF="../js/Value.html#eq(java.lang.Object)">eq</A>, <A HREF="../js/Value.html#eqs(java.lang.Object)">eqs</A>, <A HREF="../js/Value.html#gt(java.lang.Object)">gt</A>, <A HREF="../js/Value.html#gte(java.lang.Object)">gte</A>, <A HREF="../js/Value.html#in(java.lang.Object)">in</A>, <A HREF="../js/Value.html#instanceOf(java.lang.Object)">instanceOf</A>, <A HREF="../js/Value.html#ladd(java.lang.Object)">ladd</A>, <A HREF="../js/Value.html#land(java.lang.Object)">land</A>, <A HREF="../js/Value.html#ldiv(java.lang.Object)">ldiv</A>, <A HREF="../js/Value.html#leq(java.lang.Object)">leq</A>, <A HREF="../js/Value.html#lgt(java.lang.Object)">lgt</A>, <A HREF="../js/Value.html#lgte(java.lang.Object)">lgte</A>, <A HREF="../js/Value.html#llt(java.lang.Object)">llt</A>, <A HREF="../js/Value.html#llte(java.lang.Object)">llte</A>, <A HREF="../js/Value.html#lmod(java.lang.Object)">lmod</A>, <A HREF="../js/Value.html#lmul(java.lang.Object)">lmul</A>, <A HREF="../js/Value.html#lneg()">lneg</A>, <A HREF="../js/Value.html#lneq(java.lang.Object)">lneq</A>, <A HREF="../js/Value.html#lnot()">lnot</A>, <A HREF="../js/Value.html#lor(java.lang.Object)">lor</A>, <A HREF="../js/Value.html#lshl(int)">lshl</A>, <A HREF="../js/Value.html#lshr(int)">lshr</A>, <A HREF="../js/Value.html#lshru(int)">lshru</A>, <A HREF="../js/Value.html#lsub(java.lang.Object)">lsub</A>, <A HREF="../js/Value.html#lt(java.lang.Object)">lt</A>, <A HREF="../js/Value.html#lte(java.lang.Object)">lte</A>, <A HREF="../js/Value.html#lxor(java.lang.Object)">lxor</A>, <A HREF="../js/Value.html#mod(java.lang.Object)">mod</A>, <A HREF="../js/Value.html#mul(java.lang.Object)">mul</A>, <A HREF="../js/Value.html#neq(java.lang.Object)">neq</A>, <A HREF="../js/Value.html#neqs(java.lang.Object)">neqs</A>, <A HREF="../js/Value.html#not()">not</A>, <A HREF="../js/Value.html#or(T)">or</A>, <A HREF="../js/Value.html#or(js.Var)">or</A>, <A HREF="../js/Value.html#shl(int)">shl</A>, <A HREF="../js/Value.html#shr(int)">shr</A>, <A HREF="../js/Value.html#shru(int)">shru</A>, <A HREF="../js/Value.html#sub(java.lang.Object)">sub</A>, <A HREF="../js/Value.html#var()">var</A>, <A HREF="../js/Value.html#var(T)">var</A>, <A HREF="../js/Value.html#var(js.Var)">var</A>, <A HREF="../js/Value.html#xor(java.lang.Object)">xor</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Var"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../js/Var.html" title="class in js">Var</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Var.html#equals(java.lang.Object)">equals</A>, <A HREF="../js/Var.html#hashCode()">hashCode</A>, <A HREF="../js/Var.html#toString()">toString</A>, <A HREF="../js/Var.html#typeof()">typeof</A>, <A HREF="../js/Var.html#undefined()">undefined</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsArray)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsBoolean)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsDate)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsFunction)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsNumber)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsRegExp)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.core.JsString)">var</A>, <A HREF="../js/Var.html#var(js.core.JsObject, js.Var.Generic)">var</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Disposable"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../js/Disposable.html" title="class in js">Disposable</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../js/Disposable.html#finalize()">finalize</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Value.Numerical(java.lang.Object)"><!-- --></A><A NAME="Value.Numerical(T)"><!-- --></A><H3>
Value.Numerical</H3>
<PRE>
protected <B>Value.Numerical</B>(<A HREF="../js/Value.Numerical.html" title="type parameter in Value.Numerical">T</A>&nbsp;value)</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="add(java.lang.Number)"><!-- --></A><H3>
add</H3>
<PRE>
public final <A HREF="../js/Value.Number.html" title="class in js">Value.Number</A> <B>add</B>(java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Adds the current primitive instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</p>
 <p>If one value is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>Js.valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>Js.toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p + other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.Value)"><!-- --></A><H3>
add</H3>
<PRE>
public final <A HREF="../js/Value.Number.html" title="class in js">Value.Number</A> <B>add</B>(<A HREF="../js/Value.html" title="class in js">Value</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Adds the current primitive instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</p>
 <p>If one value is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../js/Js.html#valueOf(java.lang.Object)"><CODE>Js.valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../js/Js.html#toString(java.lang.Object)"><CODE>Js.toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p + other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.Character)"><!-- --></A><H3>
and</H3>
<PRE>
public <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt; <B>and</B>(java.lang.Character&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.Number)"><!-- --></A><H3>
and</H3>
<PRE>
public <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt; <B>and</B>(java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Value.Numerical)"><!-- --></A><H3>
and</H3>
<PRE>
public final <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt; <B>and</B>(<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsNumber)"><!-- --></A><H3>
and</H3>
<PRE>
public final <A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A> <B>and</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.Character)"><!-- --></A><H3>
or</H3>
<PRE>
public <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt; <B>or</B>(java.lang.Character&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Value.html#and(T)"><CODE>Value.and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.Number)"><!-- --></A><H3>
or</H3>
<PRE>
public <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt; <B>or</B>(java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Value.html#and(T)"><CODE>Value.and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Value.Numerical)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt; <B>or</B>(<A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Value.html#and(T)"><CODE>Value.and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsNumber)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../js/Value.Number.html" title="class in js">Value.Number</A> <B>or</B>(<A HREF="../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../js/Value.html#and(T)"><CODE>Value.and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, java.lang.Character)"><!-- --></A><H3>
cond</H3>
<PRE>
public <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt; <B>cond</B>(java.lang.Object&nbsp;test,
                               java.lang.Character&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, java.lang.Number)"><!-- --></A><H3>
cond</H3>
<PRE>
public <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt; <B>cond</B>(java.lang.Object&nbsp;test,
                               java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, js.Value.Numerical)"><!-- --></A><H3>
cond</H3>
<PRE>
public final <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt; <B>cond</B>(java.lang.Object&nbsp;test,
                                     <A HREF="../js/Value.Numerical.html" title="class in js">Value.Numerical</A>&lt;?&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current primitive instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf()"><!-- --></A><H3>
valueOf</H3>
<PRE>
public java.lang.Number <B>valueOf</B>()</PRE>
<DL>
<DD><p>Returns the primitive value associated with the current instance, if there is one.</p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../js/Var.html#valueOf()">valueOf</A></CODE> in class <CODE><A HREF="../js/Var.html" title="class in js">Var</A>&lt;<A HREF="../js/Value.Numerical.html" title="type parameter in Value.Numerical">T</A>&gt;</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The primitive value associated with the current instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current instance without changing the method 
 name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toExponential()"><!-- --></A><H3>
toExponential</H3>
<PRE>
public final java.lang.String <B>toExponential</B>()</PRE>
<DL>
<DD><p>Converts the current number to a string using exponential notation.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>A string representation of the current number, in exponential notation. The 
 fractional part of the number is rounded, or padded with zeros, as necessary, so that 
 it has the specified length.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>TypeError</tt> if this method 
 is invoked on an instance that is not a number. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsTypeError.html" title="class in js.core"><CODE>JsTypeError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Value.Numerical.html#toExponential(java.lang.Object)"><CODE>toExponential(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed()"><CODE>toFixed()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed(java.lang.Object)"><CODE>toFixed(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toLocaleString()"><CODE>toLocaleString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision()"><CODE>toPrecision()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision(java.lang.Object)"><CODE>toPrecision(Object)</CODE></A>, 
<A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toExponential(js.NumberLike)"><CODE>NumberLikes.toExponential(NumberLike)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toExponential(java.lang.Number)"><CODE>NumberLikes.toExponential(Number)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current primitive instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toExponential(java.lang.Object)"><!-- --></A><H3>
toExponential</H3>
<PRE>
public final java.lang.String <B>toExponential</B>(java.lang.Object&nbsp;digits)</PRE>
<DL>
<DD><p>Converts the current number to a string using exponential notation with the 
 specified number of digits after the decimal place.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>digits</CODE> - The number of digits that appears after the decimal point. This may be a 
 value between 0 and 20, inclusive, and implementations may optionally support a larger 
 range of values. If this argument is undefined, as many digits as necessary are used.
<DT><B>Returns:</B><DD>A string representation of the current number, in exponential notation, 
 with one digit before the decimal place and <tt>digits</tt> digits after the 
 decimal place. The fractional part of the number is rounded, or padded with zeros, 
 as necessary, so that it has the specified length.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>RangeError</tt> if 
 <tt>digits</tt> is too small or too large. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsRangeError.html" title="class in js.core"><CODE>JsRangeError</CODE></A> for JS Simulation. Values between 0 and 20, inclusive, 
 will not cause a <tt>RangeError</tt>. Implementations are allowed to support 
 larger and smaller values as well.
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>TypeError</tt> if this method 
 is invoked on an instance that is not a number. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsTypeError.html" title="class in js.core"><CODE>JsTypeError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Value.Numerical.html#toExponential()"><CODE>toExponential()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed()"><CODE>toFixed()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed(java.lang.Object)"><CODE>toFixed(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toLocaleString()"><CODE>toLocaleString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision()"><CODE>toPrecision()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision(java.lang.Object)"><CODE>toPrecision(Object)</CODE></A>, 
<A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toExponential(js.NumberLike, java.lang.Object)"><CODE>NumberLikes.toExponential(NumberLike, Object)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toExponential(java.lang.Number, java.lang.Object)"><CODE>NumberLikes.toExponential(Number, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current primitive instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toFixed()"><!-- --></A><H3>
toFixed</H3>
<PRE>
public final java.lang.String <B>toFixed</B>()</PRE>
<DL>
<DD><p>Converts the current number to a string without digits after the decimal place.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>A string representation of the current number that does not use exponential 
 notation and has no digits after the decimal place. The number is rounded if 
 necessary. If the current number is greater than 1e+21, this method simply calls 
 <A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A> and returns a string in exponential notation.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>TypeError</tt> if this method 
 is invoked on an instance that is not a number. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsTypeError.html" title="class in js.core"><CODE>JsTypeError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../jsx/core/NumberLikes.html#toFixed(js.NumberLike)"><CODE>NumberLikes.toFixed(NumberLike)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toFixed(js.NumberLike, java.lang.Object)"><CODE>NumberLikes.toFixed(NumberLike, Object)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toFixed(java.lang.Number)"><CODE>NumberLikes.toFixed(Number)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toFixed(java.lang.Number, java.lang.Object)"><CODE>NumberLikes.toFixed(Number, Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed(java.lang.Object)"><CODE>toFixed(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential()"><CODE>toExponential()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential(java.lang.Object)"><CODE>toExponential(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toLocaleString()"><CODE>toLocaleString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision()"><CODE>toPrecision()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision(java.lang.Object)"><CODE>toPrecision(Object)</CODE></A>, 
<A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toFixed(js.NumberLike)"><CODE>NumberLikes.toFixed(NumberLike)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toFixed(java.lang.Number)"><CODE>NumberLikes.toFixed(Number)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current primitive instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toFixed(java.lang.Object)"><!-- --></A><H3>
toFixed</H3>
<PRE>
public final java.lang.String <B>toFixed</B>(java.lang.Object&nbsp;digits)</PRE>
<DL>
<DD><p>Converts the current number to a string that contains a specified number of 
 digits after the decimal place.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>digits</CODE> - The number of digits to appear after the decimal point; this may be a 
 value between 0 and 20, inclusive, and implementations may optionally support a 
 larger range of values. If this argument is undefined, it is treated as 0.
<DT><B>Returns:</B><DD>A string representation of the current number that does not use exponential 
 notation and has exactly <tt>digits</tt> digits after the decimal place. The number 
 is rounded if necessary, and the fractional part is padded with zeros if necessary so 
 that it has the specified length. If the current number is greater than 1e+21, this 
 method simply calls <A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A> and returns a string in exponential 
 notation.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>RangeError</tt> if 
 <tt>digits</tt> is too small or too large. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsRangeError.html" title="class in js.core"><CODE>JsRangeError</CODE></A> for JS Simulation. Values between 0 and 20, inclusive, 
 will not cause a <tt>RangeError</tt>. Implementations are allowed to support 
 larger and smaller values as well.
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>TypeError</tt> if this method 
 is invoked on an instance that is not a number. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsTypeError.html" title="class in js.core"><CODE>JsTypeError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Value.Numerical.html#toFixed()"><CODE>toFixed()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential()"><CODE>toExponential()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential(java.lang.Object)"><CODE>toExponential(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toLocaleString()"><CODE>toLocaleString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision()"><CODE>toPrecision()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision(java.lang.Object)"><CODE>toPrecision(Object)</CODE></A>, 
<A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toFixed(js.NumberLike, java.lang.Object)"><CODE>NumberLikes.toFixed(NumberLike, Object)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toFixed(java.lang.Number, java.lang.Object)"><CODE>NumberLikes.toFixed(Number, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current primitive instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toPrecision()"><!-- --></A><H3>
toPrecision</H3>
<PRE>
public final java.lang.String <B>toPrecision</B>()</PRE>
<DL>
<DD><p>Converts the current number to a string.</p>
 <p>This method simply calls <A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A> to convert the number to a base-10 
 value.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>A string representation of the current number. The number is rounded or 
 padded with zeros as necessary.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>TypeError</tt> if this method 
 is invoked on an instance that is not a number. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsTypeError.html" title="class in js.core"><CODE>JsTypeError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Value.Numerical.html#toPrecision(java.lang.Object)"><CODE>toPrecision(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential()"><CODE>toExponential()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential(java.lang.Object)"><CODE>toExponential(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed()"><CODE>toFixed()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed(java.lang.Object)"><CODE>toFixed(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toLocaleString()"><CODE>toLocaleString()</CODE></A>, 
<A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toPrecision(js.NumberLike)"><CODE>NumberLikes.toPrecision(NumberLike)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toPrecision(java.lang.Number)"><CODE>NumberLikes.toPrecision(Number)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current primitive instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toPrecision(java.lang.Object)"><!-- --></A><H3>
toPrecision</H3>
<PRE>
public final java.lang.String <B>toPrecision</B>(java.lang.Object&nbsp;precision)</PRE>
<DL>
<DD><p>Converts the current number to a string using the specified number of significant 
 digits. Uses exponential or fixed-point notation depending on the size of the number 
 and the number of significant digits specified.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>precision</CODE> - The number of significant digits to appear in the returned string. 
 This may be a value between 1 and 21, inclusive. Implementations are allowed to 
 optionally support larger and smaller values of precision. If this argument is 
 undefined, the <A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A> method is used instead to convert the number to 
 a base-10 value.
<DT><B>Returns:</B><DD>A string representation of the current number that contains 
 <tt>precision</tt> significant digits. If <tt>precision</tt> is large 
 enough to include all the digits of the integer part of the number, the returned 
 string uses fixed-point notation. Otherwise, exponential notation is used with one 
 digit before the decimal place and <tt>precision - 1</tt> digits after the 
 decimal place. The number is rounded or padded with zeros as necessary.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>RangeError</tt> if 
 <tt>digits</tt> is too small or too large. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsRangeError.html" title="class in js.core"><CODE>JsRangeError</CODE></A> for JS Simulation. Values between 1 and 20, inclusive, 
 will not cause a <tt>RangeError</tt>. Implementations are allowed to support 
 larger and smaller values as well.
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>TypeError</tt> if this method 
 is invoked on an instance that is not a number. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsTypeError.html" title="class in js.core"><CODE>JsTypeError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Value.Numerical.html#toPrecision()"><CODE>toPrecision()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential()"><CODE>toExponential()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential(java.lang.Object)"><CODE>toExponential(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed()"><CODE>toFixed()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed(java.lang.Object)"><CODE>toFixed(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toLocaleString()"><CODE>toLocaleString()</CODE></A>, 
<A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toPrecision(js.NumberLike, java.lang.Object)"><CODE>NumberLikes.toPrecision(NumberLike, Object)</CODE></A>, 
<A HREF="../jsx/core/NumberLikes.html#toPrecision(java.lang.Number, java.lang.Object)"><CODE>NumberLikes.toPrecision(Number, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current primitive instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toLocaleString()"><!-- --></A><H3>
toLocaleString</H3>
<PRE>
public final java.lang.String <B>toLocaleString</B>()</PRE>
<DL>
<DD><p>Converts the current number to a string using local number-formatting conventions.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>An implementation-dependent string representation of the current number, 
 formatted according to local conventions, which may affect such things as the 
 punctuation characters used for the decimal point and the thousands separator.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>TypeError</tt> if this method 
 is invoked on an instance that is not a number. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsTypeError.html" title="class in js.core"><CODE>JsTypeError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toString(java.lang.Object)"><CODE>toString(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential()"><CODE>toExponential()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential(java.lang.Object)"><CODE>toExponential(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed()"><CODE>toFixed()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed(java.lang.Object)"><CODE>toFixed(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision()"><CODE>toPrecision()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision(java.lang.Object)"><CODE>toPrecision(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current primitive instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(java.lang.Object)"><!-- --></A><H3>
toString</H3>
<PRE>
public final java.lang.String <B>toString</B>(java.lang.Object&nbsp;radix)</PRE>
<DL>
<DD><p>Converts the current number to a string. When the <tt>radix</tt> argument is 
 undefined or is specified as 10, the number is converted to a base-10 string.</p> 
 <p>Although the ECMAScript specification does not require implementations to honor 
 any other values for radix, all implementations in common use accept values between 
 2 and 36.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>radix</CODE> - An optional argument that specifies the radix, or base, between 2 and 36, 
 in which the number should be represented. If undefined, base 10 is used. Note, 
 however, that the ECMAScript specification allows an implementation to return any 
 value if this argument is specified as any value other than 10.
<DT><B>Returns:</B><DD>A string representation of the current number, in the specified base.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>TypeError</tt> if this method 
 is invoked on an instance that is not a number. See <A HREF="../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A> and 
 <A HREF="../js/core/JsTypeError.html" title="class in js.core"><CODE>JsTypeError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../js/Var.html#toString()"><CODE>Var.toString()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential()"><CODE>toExponential()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toExponential(java.lang.Object)"><CODE>toExponential(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed()"><CODE>toFixed()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toFixed(java.lang.Object)"><CODE>toFixed(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision()"><CODE>toPrecision()</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toPrecision(java.lang.Object)"><CODE>toPrecision(Object)</CODE></A>, 
<A HREF="../js/Value.Numerical.html#toLocaleString()"><CODE>toLocaleString()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current primitive instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Value.Numerical.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
JScripter(JS) Standard 1.0 API & Re-compilation Specification</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../js/Value.Number.Member.html" title="class in js"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../js/Value.Short.html" title="class in js"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?js/Value.Numerical.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Value.Numerical.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_classes_inherited_from_class_js.Value">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright &#169; 2008-2011 J.J.Liu (www.jscripter.org). All Rights Reserved.</i>
</BODY>
</HTML>
