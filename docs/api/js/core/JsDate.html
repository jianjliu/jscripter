<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_25) on Thu Sep 15 00:19:53 CST 2011 -->
<TITLE>
JsDate (JScripter(JS) Standard 1.0 API & Re-compilation Specification)
</TITLE>

<META NAME="date" CONTENT="2011-09-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JsDate (JScripter(JS) Standard 1.0 API & Re-compilation Specification)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JsDate.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
JScripter(JS) Standard 1.0 API & Re-compilation Specification</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../js/core/JsClass.Members.html" title="class in js.core"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../js/core/JsDate.Member.html" title="class in js.core"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?js/core/JsDate.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JsDate.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
js.core</FONT>
<BR>
Class JsDate</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../js/Disposable.html" title="class in js">js.Disposable</A>
      <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../js/Var.html" title="class in js">js.Var</A>&lt;<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;
          <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../js/core/JsObject.html" title="class in js.core">js.core.JsObject</A>
              <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../js/core/JsGlobal.Date.Prototype.html" title="class in js.core">js.core.JsGlobal.Date.Prototype</A>
                  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>js.core.JsDate</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A>, <A HREF="../../js/ObjectLike.html" title="interface in js">ObjectLike</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>JsDate</B><DT>extends <A HREF="../../js/core/JsGlobal.Date.Prototype.html" title="class in js.core">JsGlobal.Date.Prototype</A><DT>implements <A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></DL>
</PRE>

<P>
<p>An <b>opaque</b> class representing JavaScript date objects.</p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD><a href="mailto:jianjunliu@126.com">J.J.Liu (Jianjun Liu)</a> at <a href="http://www.jscripter.org" target="_blank">http://www.jscripter.org</a></DD>
<DT><B>JavaScript:</B></DT>
  <DD><b>Opaque</b> types can be resolved but no class objects for them can be 
 generated into the target codes. Re-compilers must exit with error on the operations of 
 accessing that kind of class objects.
 The <tt>checkcast</tt> operation to the class literal of this interface must be ignored 
 and <tt>instanceof</tt> to it always <tt>true</tt>.</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.Member.html" title="class in js.core">JsDate.Member</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An <b>opaque</b> class representing members of its enclosing <b>opaque</b> type.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_js.core.JsGlobal.Date.Prototype"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class js.core.<A HREF="../../js/core/JsGlobal.Date.Prototype.html" title="class in js.core">JsGlobal.Date.Prototype</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/core/JsGlobal.Date.Prototype.Members.html" title="class in js.core">JsGlobal.Date.Prototype.Members</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_js.Var"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class js.<A HREF="../../js/Var.html" title="class in js">Var</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/Var.Generic.html" title="class in js">Var.Generic</A>&lt;<A HREF="../../js/Var.Generic.html" title="type parameter in Var.Generic">T</A>&gt;, <A HREF="../../js/Var.Mid.html" title="class in js">Var.Mid</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../js/core/JsFunction.Member.html" title="class in js.core">JsFunction.Member</A>&lt;<A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#constructor">constructor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An <b>opaque</b> static field defining a member that is named by the field name 
 without a qualifying member and to access the property of the name on an object.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_js.core.JsGlobal.Date.Prototype"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class js.core.<A HREF="../../js/core/JsGlobal.Date.Prototype.html" title="class in js.core">JsGlobal.Date.Prototype</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/core/JsGlobal.Date.Prototype.html#getDate">getDate</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getDay">getDay</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getFullYear">getFullYear</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getHours">getHours</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getMilliseconds">getMilliseconds</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getMinutes">getMinutes</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getMonth">getMonth</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getSeconds">getSeconds</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getTime">getTime</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getTimezoneOffset">getTimezoneOffset</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getUTCDate">getUTCDate</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getUTCDay">getUTCDay</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getUTCFullYear">getUTCFullYear</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getUTCHours">getUTCHours</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getUTCMilliseconds">getUTCMilliseconds</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getUTCMinutes">getUTCMinutes</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getUTCMonth">getUTCMonth</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#getUTCSeconds">getUTCSeconds</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setDate">setDate</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setFullYear">setFullYear</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setHours">setHours</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setMilliseconds">setMilliseconds</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setMinutes">setMinutes</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setMonth">setMonth</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setSeconds">setSeconds</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setTime">setTime</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setUTCDate">setUTCDate</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setUTCFullYear">setUTCFullYear</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setUTCHours">setUTCHours</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setUTCMilliseconds">setUTCMilliseconds</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setUTCMinutes">setUTCMinutes</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setUTCMonth">setUTCMonth</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#setUTCSeconds">setUTCSeconds</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#toDateString">toDateString</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#toLocaleDateString">toLocaleDateString</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#toLocaleString">toLocaleString</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#toLocaleTimeString">toLocaleTimeString</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#toTimeString">toTimeString</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#toUTCString">toUTCString</A>, <A HREF="../../js/core/JsGlobal.Date.Prototype.html#valueOf">valueOf</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_js.core.JsObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class js.core.<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/core/JsObject.html#hasOwnProperty">hasOwnProperty</A>, <A HREF="../../js/core/JsObject.html#isPrototypeOf">isPrototypeOf</A>, <A HREF="../../js/core/JsObject.html#propertyIsEnumerable">propertyIsEnumerable</A>, <A HREF="../../js/core/JsObject.html#toSource">toSource</A>, <A HREF="../../js/core/JsObject.html#toString">toString</A>, <A HREF="../../js/core/JsObject.html#var">var</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate()">JsDate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object set to the current date and time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)">JsDate</A></B>(<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Casts an <b>opaque</b> object to the current <b>opaque</b> type by wrapping it 
 with the wrapping constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)">JsDate</A></B>(java.lang.Number&nbsp;milliseconds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object taking <tt>milliseconds</tt> as the internal numeric 
 representation as returned by <A HREF="../../js/core/JsDate.html#getTime()"><CODE>getTime()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)">JsDate</A></B>(<A HREF="../../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;?&gt;&nbsp;milliseconds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object taking <tt>milliseconds</tt> as the internal numeric 
 representation as returned by <A HREF="../../js/core/JsDate.html#getTime()"><CODE>getTime()</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object)">JsDate</A></B>(java.lang.Object&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internally constructs a date object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)">JsDate</A></B>(java.lang.Object&nbsp;yr,
       java.lang.Object&nbsp;mo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)">JsDate</A></B>(java.lang.Object&nbsp;yr,
       java.lang.Object&nbsp;mo,
       java.lang.Object&nbsp;day)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">JsDate</A></B>(java.lang.Object&nbsp;yr,
       java.lang.Object&nbsp;mo,
       java.lang.Object&nbsp;day,
       java.lang.Object&nbsp;hr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">JsDate</A></B>(java.lang.Object&nbsp;yr,
       java.lang.Object&nbsp;mo,
       java.lang.Object&nbsp;day,
       java.lang.Object&nbsp;hr,
       java.lang.Object&nbsp;min)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">JsDate</A></B>(java.lang.Object&nbsp;yr,
       java.lang.Object&nbsp;mo,
       java.lang.Object&nbsp;day,
       java.lang.Object&nbsp;hr,
       java.lang.Object&nbsp;min,
       java.lang.Object&nbsp;sec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">JsDate</A></B>(java.lang.Object&nbsp;yr,
       java.lang.Object&nbsp;mo,
       java.lang.Object&nbsp;day,
       java.lang.Object&nbsp;hr,
       java.lang.Object&nbsp;min,
       java.lang.Object&nbsp;sec,
       java.lang.Object&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)">JsDate</A></B>(java.lang.String&nbsp;datestring)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object taking <tt>datestring</tt> as the string representation, 
 in the format accepted by the <A HREF="../../js/core/JsGlobal.Date.html#parse(java.lang.Object)"><CODE>JsGlobal.Date.parse(Object)</CODE></A> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)">JsDate</A></B>(<A HREF="../../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;datestring)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a date object taking <tt>datestring</tt> as the string representation, 
 in the format accepted by the <A HREF="../../js/core/JsGlobal.Date.html#parse(java.lang.Object)"><CODE>JsGlobal.Date.parse(Object)</CODE></A> method.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#aadd(java.lang.Character)">aadd</A></B>(java.lang.Character&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#aadd(js.core.JsNumber)">aadd</A></B>(<A HREF="../../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#aadd(java.lang.Number)">aadd</A></B>(java.lang.Number&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#aadd(js.Value.Character)">aadd</A></B>(<A HREF="../../js/Value.Character.html" title="class in js">Value.Character</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#aadd(js.Value)">aadd</A></B>(<A HREF="../../js/Value.html" title="class in js">Value</A>&lt;? extends java.lang.Number&gt;&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#aand(java.lang.Object)">aand</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-bitwise-AND operation, resembling that of JavaScript, performs a boolean AND 
 operation on each bit of the integer arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#add(java.lang.Object)">add</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the current date instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#add(java.lang.String)">add</A></B>(java.lang.String&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the current date instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#add(js.Value)">add</A></B>(<A HREF="../../js/Value.html" title="class in js">Value</A>&lt;java.lang.String&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the current date instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#adiv(java.lang.Object)">adiv</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Divides, by a numeric operand, the current date instance and returns the numeric 
 operand, resembling the assignment-with-division operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#amod(java.lang.Object)">amod</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Modulo operates a numeric operand onto the current date instance and returns the 
 numeric operand, resembling the assignment-with-multiplication operator in 
 JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#amul(java.lang.Object)">amul</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiplies a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-multiplication operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#and(js.DateLike)">and</A></B>(<A HREF="../../js/DateLike.html" title="interface in js">DateLike</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#and(js.core.JsDate)">and</A></B>(<A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#and(java.lang.Object)">and</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#and(js.Var)">and</A></B>(<A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#aor(java.lang.Object)">aor</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-bitwise-OR operation, resembling that of JavaScript, performs a boolean OR operation 
 on each bit of the integer arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#ashl(int)">ashl</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-shift-left operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the left by the number of places specified in the 
 second operand, which should be an integer between 0 and 31.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#ashr(int)">ashr</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-shift-right operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#ashru(int)">ashru</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-shift-right-unsigned operation, resembling that of JavaScript, moves all bits in 
 the current date instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#asub(java.lang.Object)">asub</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subtracts a numeric operand from the current date instance and returns the numeric 
 operand, resembling the assignment-with-subtraction operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#axor(java.lang.Object)">axor</A></B>(java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assignment-with-bitwise-XOR operation, resembling that of JavaScript, performs a boolean exclusive 
 OR operation on each bit of the integer arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#band(java.lang.Object)">band</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bitwise-AND operation, resembling that of JavaScript, performs a boolean AND 
 operation on each bit of the integer arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#be()">be</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates the current date instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#bnot()">bnot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bitwise-NOT operation, resembling that of JavaScript, operates by reversing all 
 bits in the current date instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#bor(java.lang.Object)">bor</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bitwise-OR operation, resembling that of JavaScript, performs a boolean OR operation 
 on each bit of the integer arguments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#cond(java.lang.Object, java.lang.Character)">cond</A></B>(java.lang.Object&nbsp;test,
     java.lang.Character&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#cond(java.lang.Object, js.core.JsDate)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#cond(java.lang.Object, java.lang.Number)">cond</A></B>(java.lang.Object&nbsp;test,
     java.lang.Number&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#cond(java.lang.Object, java.lang.Object)">cond</A></B>(java.lang.Object&nbsp;test,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#cond(java.lang.Object, js.Value)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../../js/Value.html" title="class in js">Value</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#cond(java.lang.Object, js.Var)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#dec()">dec</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decreases the current date instance by 1 and then returns the value of the 
 current date instance, resembling the pre-decrement operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#decp()">decp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value of the current date instance and then decreases the 
 current date instance by 1, resembling the post-decrement operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#div(java.lang.Object)">div</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Divides the value of the current date instance by the operand, resembling the 
 division operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#eq(java.lang.Object)">eq</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#eqs(java.lang.Object)">eqs</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getDate()">getDate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the day of the month of the current date instance, in local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getDay()">getDay</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the day of the week of the current date instance, in local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getFullYear()">getFullYear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the year of the current date instance in full four-digit form, in local 
 time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getHours()">getHours</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the hours field of the current date instance, in local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getMilliseconds()">getMilliseconds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the milliseconds field of the current date instance, in local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getMinutes()">getMinutes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minutes field of a Date object, in local or universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getMonth()">getMonth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the month field of the current date instance, in local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getSeconds()">getSeconds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the seconds field of the current date instance, in local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getTime()">getTime</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the internal, millisecond representation of the current date instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getTimezoneOffset()">getTimezoneOffset</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the difference, in minutes, between the local and UTC representations of 
 the current date instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getUTCDate()">getUTCDate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the day of the month of the current date instance, in universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getUTCDay()">getUTCDay</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the day of the week of current date instance, in universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getUTCFullYear()">getUTCFullYear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the year of the current date instance in full four-digit form, in 
 universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getUTCHours()">getUTCHours</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the hours field of the current date instance, in universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getUTCMilliseconds()">getUTCMilliseconds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the milliseconds field of current date instance, in universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getUTCMinutes()">getUTCMinutes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minutes field of the current date instance, in universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getUTCMonth()">getUTCMonth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the month field of the current date instance, in universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#getUTCSeconds()">getUTCSeconds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the seconds field of the current date instance, in universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#gt(java.lang.Object)">gt</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater-than operation, resembling that of JavaScript, evaluates to <tt>true</tt> if 
 the current date instance is greater than the second operand; otherwise it 
 evaluates to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#gte(java.lang.Object)">gte</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Greater-than-or-equal operation, resembling that of JavaScript, evaluates to 
 <tt>true</tt> if the current date instance is greater than or equal to the 
 second operand; otherwise it evaluates to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#inc()">inc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Increases the current date instance by 1 and then returns the value of the 
 current date instance, resembling the pre-increment operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#incp()">incp</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value of the current date instance and then increases the 
 current date instance by 1, resembling the post-increment operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#instanceOf(java.lang.Object)">instanceOf</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current date instance is an instance of the second operand, 
 resembling the <tt>instanceof</tt> operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#ladd(java.lang.Object)">ladd</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds two 64-bit integers, casting the operands to <tt>long</tt> numbers if any 
 one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#land(java.lang.Object)">land</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit bitwise-AND operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, performs a boolean AND operation on each 
 bit of the 64-bit integers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#ldiv(java.lang.Object)">ldiv</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Divides the first 64-bit integer by the second 64-bit integer, casting the operands 
 to <tt>long</tt> numbers if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#leq(java.lang.Object)">leq</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two 64-bit integers are "equal", casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lgt(java.lang.Object)">lgt</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit greater-than operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the first 
 operand is greater than the second operand; otherwise it evaluates to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lgte(java.lang.Object)">lgte</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit greater-than-or-equal operation, casting the operands to <tt>long</tt> 
 numbers if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the 
 first operand is greater than or equal to the second operand; otherwise it evaluates 
 to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#llt(java.lang.Object)">llt</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit less-than operation, casting the operands to <tt>long</tt> numbers if 
 any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the first 
 operand is less than the second operand; otherwise it evaluates to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#llte(java.lang.Object)">llte</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit less-than-or-equal operation, casting the operands to <tt>long</tt> 
 numbers if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if 
 the first operand is less than or equal to the second operand; otherwise it evaluates 
 to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lmod(java.lang.Object)">lmod</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the first operand modulo the second operand, casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lmul(java.lang.Object)">lmul</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiplies the two 64-bit integer, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lneg()">lneg</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs unary negation on a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lneq(java.lang.Object)">lneq</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two 64-bit integers are not "equal", casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lnot()">lnot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit bitwise-NOT operation, casting the operand to a <tt>long</tt> number 
 if it is not 64-bit, operates by reversing all bits in the 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lor(java.lang.Object)">lor</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit bitwise-OR operation, casting the operands to <tt>long</tt> numbers if 
 any one of them is not a 64-bit integer, performs a boolean OR operation on each bit 
 of the 64-bit integers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lshl(int)">lshl</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit shift-left operation, casting the first operand to a <tt>long</tt> 
 number if it is not 64-bit, moves all bits in it to the left by the number of places 
 specified in the second operand, which should be an integer between 0 and 63.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lshr(int)">lshr</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit shift-right operation, casting the first operand to a <tt>long</tt> 
 number if it is not 64-bit, moves all bits in it to the right by the number of 
 places specified in the second operand (an integer between 0 and 63).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lshru(int)">lshru</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit shift-right-unsigned operation, casting the first operand to a 
 <tt>long</tt> number if it is not 64-bit, moves all bits in it to the right by the 
 number of places specified in the second operand (an integer between 0 and 63).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lsub(java.lang.Object)">lsub</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subtracts the second 64-bit integer from the first 64-bit integer, casting the 
 operands to <tt>long</tt> numbers if any one of them is not a 64-bit integer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lt(java.lang.Object)">lt</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less-than operation, resembling that of JavaScript, evaluates to <tt>true</tt> if 
 the current date instance is less than the second operand; otherwise it 
 evaluates to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lte(java.lang.Object)">lte</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Less-than-or-equal operation, resembling that of JavaScript, evaluates to 
 <tt>true</tt> if the current date instance is less than or equal to the second 
 operand; otherwise it evaluates to <tt>false</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#lxor(java.lang.Object)">lxor</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 64-bit bitwise-XOR operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, performs a boolean exclusive OR operation 
 on each bit of the 64-bit integers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#mod(java.lang.Object)">mod</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the value of the current date instance modulo the operand, resembling 
 the modulo operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#mul(java.lang.Object)">mul</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiplies the value of the current date instance with the operand, resembling 
 the multiplication operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#neg()">neg</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs unary negation, resembling the unary minus operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#neq(java.lang.Object)">neq</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are not "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#neqs(java.lang.Object)">neqs</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are not "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#not()">not</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inverts the boolean value of the current date instance, resembling the logical 
 NOT operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#or(js.DateLike)">or</A></B>(<A HREF="../../js/DateLike.html" title="interface in js">DateLike</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#or(js.core.JsDate)">or</A></B>(<A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#or(java.lang.Object)">or</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#or(js.Var)">or</A></B>(<A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setDate(java.lang.Object)">setDate</A></B>(java.lang.Object&nbsp;day)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the day of the month field of the current date instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object)">setFullYear</A></B>(java.lang.Object&nbsp;yr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the year field of the current date instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object, java.lang.Object)">setFullYear</A></B>(java.lang.Object&nbsp;yr,
            java.lang.Object&nbsp;mo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the year and optionally month fields of the current date instance, using 
 local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object, java.lang.Object, java.lang.Object)">setFullYear</A></B>(java.lang.Object&nbsp;yr,
            java.lang.Object&nbsp;mo,
            java.lang.Object&nbsp;day)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the year and optionally month and day fields of the current date instance, 
 using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setHours(java.lang.Object)">setHours</A></B>(java.lang.Object&nbsp;hr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the hour field of the current date instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object)">setHours</A></B>(java.lang.Object&nbsp;hr,
         java.lang.Object&nbsp;min)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the hour field and optionally the minutes field of the current date 
 instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object)">setHours</A></B>(java.lang.Object&nbsp;hr,
         java.lang.Object&nbsp;min,
         java.lang.Object&nbsp;sec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the hour field and optionally the minutes and seconds fields of the current 
 date instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">setHours</A></B>(java.lang.Object&nbsp;hr,
         java.lang.Object&nbsp;min,
         java.lang.Object&nbsp;sec,
         java.lang.Object&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the hour field and optionally the minutes, seconds, and milliseconds fields 
 of the current date instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setMilliseconds(java.lang.Object)">setMilliseconds</A></B>(java.lang.Object&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the milliseconds field of a date, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object)">setMinutes</A></B>(java.lang.Object&nbsp;min)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minutes field of the current date instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object, java.lang.Object)">setMinutes</A></B>(java.lang.Object&nbsp;min,
           java.lang.Object&nbsp;sec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minutes field and optionally the seconds field of the current date 
 instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object, java.lang.Object, java.lang.Object)">setMinutes</A></B>(java.lang.Object&nbsp;min,
           java.lang.Object&nbsp;sec,
           java.lang.Object&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minutes field and optionally the seconds and milliseconds fields of the 
 current date instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setMonth(java.lang.Object)">setMonth</A></B>(java.lang.Object&nbsp;mo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the month field of the current date instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setMonth(java.lang.Object, java.lang.Object)">setMonth</A></B>(java.lang.Object&nbsp;mo,
         java.lang.Object&nbsp;day)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the month field and optionally the day of the month of the current date 
 instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setSeconds(java.lang.Object)">setSeconds</A></B>(java.lang.Object&nbsp;sec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the seconds field of the current date instance, using local time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setSeconds(java.lang.Object, java.lang.Object)">setSeconds</A></B>(java.lang.Object&nbsp;sec,
           java.lang.Object&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the seconds field and optionally the milliseconds field of the current date 
 instance, using local .</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setTime(java.lang.Object)">setTime</A></B>(java.lang.Object&nbsp;time)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the fields of the current date instance using the millisecond format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCDate(java.lang.Object)">setUTCDate</A></B>(java.lang.Object&nbsp;day)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the day of the month field of the current date instance, using universal 
 time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object)">setUTCFullYear</A></B>(java.lang.Object&nbsp;yr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the year field of the current date instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object, java.lang.Object)">setUTCFullYear</A></B>(java.lang.Object&nbsp;yr,
               java.lang.Object&nbsp;mo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the year and optionally month fields of the current date instance, using 
 universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object, java.lang.Object, java.lang.Object)">setUTCFullYear</A></B>(java.lang.Object&nbsp;yr,
               java.lang.Object&nbsp;mo,
               java.lang.Object&nbsp;day)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the year and optionally month and day fields of the current date instance, 
 using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object)">setUTCHours</A></B>(java.lang.Object&nbsp;hr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the hour field of the current date instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object)">setUTCHours</A></B>(java.lang.Object&nbsp;hr,
            java.lang.Object&nbsp;min)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the hour field and optionally the minutes field of the current date 
 instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object)">setUTCHours</A></B>(java.lang.Object&nbsp;hr,
            java.lang.Object&nbsp;min,
            java.lang.Object&nbsp;sec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the hour field and optionally the minutes and seconds fields of the current 
 date instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">setUTCHours</A></B>(java.lang.Object&nbsp;hr,
            java.lang.Object&nbsp;min,
            java.lang.Object&nbsp;sec,
            java.lang.Object&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the hour field and optionally the minutes, seconds, and milliseconds fields 
 of the current date instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCMilliseconds(java.lang.Object)">setUTCMilliseconds</A></B>(java.lang.Object&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the milliseconds field of the current date instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object)">setUTCMinutes</A></B>(java.lang.Object&nbsp;min)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minutes field of the current date instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object, java.lang.Object)">setUTCMinutes</A></B>(java.lang.Object&nbsp;min,
              java.lang.Object&nbsp;sec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minutes field and optionally the seconds field of the current date 
 instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object, java.lang.Object, java.lang.Object)">setUTCMinutes</A></B>(java.lang.Object&nbsp;min,
              java.lang.Object&nbsp;sec,
              java.lang.Object&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minutes field and optionally the seconds and milliseconds fields of the 
 current date instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCMonth(java.lang.Object)">setUTCMonth</A></B>(java.lang.Object&nbsp;mo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the month field of the current date instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCMonth(java.lang.Object, java.lang.Object)">setUTCMonth</A></B>(java.lang.Object&nbsp;mo,
            java.lang.Object&nbsp;day)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the month field and optionally the day of the month of the current date 
 instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCSeconds(java.lang.Object)">setUTCSeconds</A></B>(java.lang.Object&nbsp;sec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the seconds field of the current date instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#setUTCSeconds(java.lang.Object, java.lang.Object)">setUTCSeconds</A></B>(java.lang.Object&nbsp;sec,
              java.lang.Object&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the seconds field and optionally the milliseconds field of the current date 
 instance, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#shl(int)">shl</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shift-left operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the left by the number of places specified in the 
 second operand, which should be an integer between 0 and 31.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#shr(int)">shr</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shift-right operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#shru(int)">shru</A></B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shift-right-unsigned operation, resembling that of JavaScript, moves all bits in 
 the current date instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#sub(java.lang.Object)">sub</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subtracts the operand from the value of the current date instance, resembling 
 the subtraction operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#toDateString()">toDateString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string that represents the date portion of the current date instance, 
 expressed in the local time zone.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#toLocaleDateString()">toLocaleDateString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string that represents the date portion of the current date instance, 
 expressed in the local time zone, using the local date formatting conventions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#toLocaleTimeString()">toLocaleTimeString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string that represents the time portion of the current date instance, 
 expressed in the local time zone, using the local time formatting conventions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#toTimeString()">toTimeString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string that represents the time portion of the current date instance, 
 expressed in the local time zone.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#toUTCString()">toUTCString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the current date instance to a string, using universal time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Number</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#valueOf()">valueOf</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the current instance, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#var()">var</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simply returns the current date instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;S extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
S</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#var(S)">var</A></B>(S&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assigns the value of another date instance to the current date object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsDate.html#xor(java.lang.Object)">xor</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bitwise-XOR operation, resembling that of JavaScript, performs a boolean exclusive 
 OR operation on each bit of the integer arguments.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.core.JsObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.core.<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/core/JsObject.html#call(js.core.JsFunction.Member)">call</A>, <A HREF="../../js/core/JsObject.html#call(js.core.JsFunction.Member, java.lang.Object)">call</A>, <A HREF="../../js/core/JsObject.html#call(js.core.JsFunction.Member, js.Vars)">call</A>, <A HREF="../../js/core/JsObject.html#delete()">delete</A>, <A HREF="../../js/core/JsObject.html#delete(js.Id)">delete</A>, <A HREF="../../js/core/JsObject.html#delete(java.lang.String)">delete</A>, <A HREF="../../js/core/JsObject.html#delete(js.Var.Member)">delete</A>, <A HREF="../../js/core/JsObject.html#delete(js.Var.Mid)">delete</A>, <A HREF="../../js/core/JsObject.html#hasOwnProperty(java.lang.Object)">hasOwnProperty</A>, <A HREF="../../js/core/JsObject.html#isPrototypeOf(java.lang.Object)">isPrototypeOf</A>, <A HREF="../../js/core/JsObject.html#propertyIsEnumerable(java.lang.Object)">propertyIsEnumerable</A>, <A HREF="../../js/core/JsObject.html#toLocaleString()">toLocaleString</A>, <A HREF="../../js/core/JsObject.html#toString()">toString</A>, <A HREF="../../js/core/JsObject.html#undefined()">undefined</A>, <A HREF="../../js/core/JsObject.html#var(js.Id)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.Id, T)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsArray.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsBoolean.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsDate.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsFunction.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsNumber.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsObject.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsString.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(java.lang.String)">var</A>, <A HREF="../../js/core/JsObject.html#var(java.lang.String, T)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.Var.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.Var.Member, T)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.Var.Mid)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.Var.Mid, T)">var</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Var"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../../js/Var.html" title="class in js">Var</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/Var.html#equals(java.lang.Object)">equals</A>, <A HREF="../../js/Var.html#hashCode()">hashCode</A>, <A HREF="../../js/Var.html#typeof()">typeof</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsArray)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsBoolean)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsDate)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsFunction)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsNumber)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsRegExp)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsString)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.Var.Generic)">var</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Disposable"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../../js/Disposable.html" title="class in js">Disposable</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/Disposable.html#finalize()">finalize</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.DateLike"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface js.<A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/DateLike.html#toLocaleString()">toLocaleString</A>, <A HREF="../../js/DateLike.html#toString()">toString</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="constructor"><!-- --></A><H3>
constructor</H3>
<PRE>
public static final <A HREF="../../js/core/JsFunction.Member.html" title="class in js.core">JsFunction.Member</A>&lt;<A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A>&gt; <B>constructor</B></PRE>
<DL>
<DD><p>An <b>opaque</b> static field defining a member that is named by the field name 
 without a qualifying member and to access the property of the name on an object.</p>
 <p>The <tt>constructor</tt> property of an object is a reference to the function 
 that was the constructor for that object.</p>
 <p>A common use of the <tt>constructor</tt> property is to determine the type of unknown 
 objects. Given an unknown value, you can use the <A HREF="../../js/Js.html#typeof(java.lang.Object)"><CODE>Js.typeof(Object)</CODE></A> operation 
 to determine whether it is a primitive value or an object. If it is an object, you can 
 use the <tt>constructor</tt> property to determine what type of object it is.</p>
 <p>Note, however, that while this technique works for the objects built into core 
 JavaScript, it is not guaranteed to work with host objects such as the <tt>window</tt> 
 object of client-side JavaScript. The default implementation of the <tt>toString()</tt> 
 method provides another way to determine the type of an unknown object.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must resolve the member of this static field to the 
 identifier of the field name.</DD>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="JsDate(java.lang.Object)"><!-- --></A><H3>
JsDate</H3>
<PRE>
protected <B>JsDate</B>(java.lang.Object&nbsp;var)</PRE>
<DL>
<DD><p>Internally constructs a date object.</p>
 <p>This constructor is <b>internal</b> and only called inside of <b>opaque</b> or 
 <b>internal</b> classes or class members.</p>
 <p>Note that, The Java class <tt>java.lang.String</tt> and Java basic classes that 
 wrap primitive data types are also "primitive" to JS.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must report error on the invocation to an <b>internal</b> constructor.</DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(js.core.JsObject)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&nbsp;var)</PRE>
<DL>
<DD><p>Casts an <b>opaque</b> object to the current <b>opaque</b> type by wrapping it 
 with the wrapping constructor.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The argument of an <b>opaque</b> object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="JsDate()"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>()</PRE>
<DL>
<DD><p>Constructs a date object set to the current date and time.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/Js.html#date()"><CODE>Js.date()</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create()"><CODE>JsGlobal.Date.create()</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(js.Vars)"><CODE>JsGlobal.Date.create(Vars)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(milliseconds)</pre></DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(java.lang.Number)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(java.lang.Number&nbsp;milliseconds)</PRE>
<DL>
<DD><p>Constructs a date object taking <tt>milliseconds</tt> as the internal numeric 
 representation as returned by <A HREF="../../js/core/JsDate.html#getTime()"><CODE>getTime()</CODE></A>.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>milliseconds</CODE> - The numeric representation of the date in milliseconds.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/Js.html#date(java.lang.Number)"><CODE>Js.date(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create()"><CODE>JsGlobal.Date.create()</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(js.Vars)"><CODE>JsGlobal.Date.create(Vars)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Number)"><CODE>JsGlobal.Date.create(Number)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(js.NumberLike)"><CODE>JsGlobal.Date.create(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Object)"><CODE>JsGlobal.Date.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(milliseconds)</pre></DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(js.NumberLike)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(<A HREF="../../js/NumberLike.html" title="interface in js">NumberLike</A>&lt;?&gt;&nbsp;milliseconds)</PRE>
<DL>
<DD><p>Constructs a date object taking <tt>milliseconds</tt> as the internal numeric 
 representation as returned by <A HREF="../../js/core/JsDate.html#getTime()"><CODE>getTime()</CODE></A>.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>milliseconds</CODE> - The numeric representation of the date in milliseconds.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/Js.html#date(java.lang.Number)"><CODE>Js.date(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(js.Vars)"><CODE>JsGlobal.Date.create(Vars)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Number)"><CODE>JsGlobal.Date.create(Number)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(js.NumberLike)"><CODE>JsGlobal.Date.create(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Object)"><CODE>JsGlobal.Date.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(milliseconds)</pre></DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(java.lang.String)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(java.lang.String&nbsp;datestring)</PRE>
<DL>
<DD><p>Constructs a date object taking <tt>datestring</tt> as the string representation, 
 in the format accepted by the <A HREF="../../js/core/JsGlobal.Date.html#parse(java.lang.Object)"><CODE>JsGlobal.Date.parse(Object)</CODE></A> method.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>datestring</CODE> - The string representation of the date to construct.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/Js.html#date(java.lang.String)"><CODE>Js.date(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(js.Vars)"><CODE>JsGlobal.Date.create(Vars)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Object)"><CODE>JsGlobal.Date.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(datestring)</pre></DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(js.StringLike)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(<A HREF="../../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;datestring)</PRE>
<DL>
<DD><p>Constructs a date object taking <tt>datestring</tt> as the string representation, 
 in the format accepted by the <A HREF="../../js/core/JsGlobal.Date.html#parse(java.lang.Object)"><CODE>JsGlobal.Date.parse(Object)</CODE></A> method.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>datestring</CODE> - The string representation of the date to construct.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/Js.html#date(java.lang.String)"><CODE>Js.date(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(js.Vars)"><CODE>JsGlobal.Date.create(Vars)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Object)"><CODE>JsGlobal.Date.create(Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(datestring)</pre></DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(java.lang.Object&nbsp;yr,
              java.lang.Object&nbsp;mo)</PRE>
<DL>
<DD><p>Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time. All but the first two arguments, the year 
 and month fields, are optional.</p>
 <p>Note that these date and time fields are specified using local time, not 
 Coordinated Universal Time (UTC) (which is similar to Greenwich Mean Time [GMT]). 
 See the static <A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object)</CODE></A>
 method for an alternative.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, in four-digit format. For compatibility with early implementations 
 of JavaScript, if this argument is between 0 and 99, 1900 is added to it.<DD><CODE>mo</CODE> - The month, specified as an integer from 0 (January) to 11 (December).<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.create(Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(yr, mo)</pre></DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(java.lang.Object&nbsp;yr,
              java.lang.Object&nbsp;mo,
              java.lang.Object&nbsp;day)</PRE>
<DL>
<DD><p>Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time. All but the first two arguments, the year 
 and month fields, are optional.</p>
 <p>Note that these date and time fields are specified using local time, not 
 Coordinated Universal Time (UTC) (which is similar to Greenwich Mean Time [GMT]). 
 See the static <A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object, Object)</CODE></A>
 method for an alternative.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, in four-digit format. For compatibility with early implementations 
 of JavaScript, if this argument is between 0 and 99, 1900 is added to it.<DD><CODE>mo</CODE> - The month, specified as an integer from 0 (January) to 11 (December).<DD><CODE>day</CODE> - The day of the month, specified as an integer from 1 to 31. Note that 
 this argument uses 1 as its lowest value, while other arguments use 0 as their 
 lowest value. Optional.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.create(Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(yr, mo, day)</pre></DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(java.lang.Object&nbsp;yr,
              java.lang.Object&nbsp;mo,
              java.lang.Object&nbsp;day,
              java.lang.Object&nbsp;hr)</PRE>
<DL>
<DD><p>Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time. All but the first two arguments, the year 
 and month fields, are optional.</p>
 <p>Note that these date and time fields are specified using local time, not 
 Coordinated Universal Time (UTC) (which is similar to Greenwich Mean Time [GMT]). 
 See the static <A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object, Object, Object)</CODE></A>
 method for an alternative.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, in four-digit format. For compatibility with early implementations 
 of JavaScript, if this argument is between 0 and 99, 1900 is added to it.<DD><CODE>mo</CODE> - The month, specified as an integer from 0 (January) to 11 (December).<DD><CODE>day</CODE> - The day of the month, specified as an integer from 1 to 31. Note that 
 this argument uses 1 as its lowest value, while other arguments use 0 as their 
 lowest value. Optional.<DD><CODE>hr</CODE> - The hour, specified as an integer from 0 (midnight) to 23 (11 p.m.). 
 Optional.<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.create(Object, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(yr, mo, day, hr)</pre></DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(java.lang.Object&nbsp;yr,
              java.lang.Object&nbsp;mo,
              java.lang.Object&nbsp;day,
              java.lang.Object&nbsp;hr,
              java.lang.Object&nbsp;min)</PRE>
<DL>
<DD><p>Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time. All but the first two arguments, the year 
 and month fields, are optional.</p>
 <p>Note that these date and time fields are specified using local time, not 
 Coordinated Universal Time (UTC) (which is similar to Greenwich Mean Time [GMT]). 
 See the static <A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object, Object, Object, Object)</CODE></A>
 method for an alternative.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, in four-digit format. For compatibility with early implementations 
 of JavaScript, if this argument is between 0 and 99, 1900 is added to it.<DD><CODE>mo</CODE> - The month, specified as an integer from 0 (January) to 11 (December).<DD><CODE>day</CODE> - The day of the month, specified as an integer from 1 to 31. Note that 
 this argument uses 1 as its lowest value, while other arguments use 0 as their 
 lowest value. Optional.<DD><CODE>hr</CODE> - The hour, specified as an integer from 0 (midnight) to 23 (11 p.m.). 
 Optional.<DD><CODE>min</CODE> - The minutes in the hour, specified as an integer from 0 to 59. Optional.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.create(Object, Object, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(yr, mo, day, hr, min)</pre></DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(java.lang.Object&nbsp;yr,
              java.lang.Object&nbsp;mo,
              java.lang.Object&nbsp;day,
              java.lang.Object&nbsp;hr,
              java.lang.Object&nbsp;min,
              java.lang.Object&nbsp;sec)</PRE>
<DL>
<DD><p>Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time. All but the first two arguments, the year 
 and month fields, are optional.</p>
 <p>Note that these date and time fields are specified using local time, not 
 Coordinated Universal Time (UTC) (which is similar to Greenwich Mean Time [GMT]). 
 See the static <A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object, Object, Object, Object, Object)</CODE></A>
 method for an alternative.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, in four-digit format. For compatibility with early implementations 
 of JavaScript, if this argument is between 0 and 99, 1900 is added to it.<DD><CODE>mo</CODE> - The month, specified as an integer from 0 (January) to 11 (December).<DD><CODE>day</CODE> - The day of the month, specified as an integer from 1 to 31. Note that 
 this argument uses 1 as its lowest value, while other arguments use 0 as their 
 lowest value. Optional.<DD><CODE>hr</CODE> - The hour, specified as an integer from 0 (midnight) to 23 (11 p.m.). 
 Optional.<DD><CODE>min</CODE> - The minutes in the hour, specified as an integer from 0 to 59. Optional.<DD><CODE>sec</CODE> - The seconds in the minute, specified as an integer from 0 to 59. Optional.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.create(Object, Object, Object, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(yr, mo, day, hr, min, sec)</pre></DD>
</DL>
</DL>
<HR>

<A NAME="JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
JsDate</H3>
<PRE>
public <B>JsDate</B>(java.lang.Object&nbsp;yr,
              java.lang.Object&nbsp;mo,
              java.lang.Object&nbsp;day,
              java.lang.Object&nbsp;hr,
              java.lang.Object&nbsp;min,
              java.lang.Object&nbsp;sec,
              java.lang.Object&nbsp;ms)</PRE>
<DL>
<DD><p>Constructs a date object with two to seven numeric arguments that specify the 
 individual fields of the date and time. All but the first two arguments, the year 
 and month fields, are optional.</p>
 <p>Note that these date and time fields are specified using local time, not 
 Coordinated Universal Time (UTC) (which is similar to Greenwich Mean Time [GMT]). 
 See the static <A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object, Object, Object, Object, Object, Object)</CODE></A>
 method for an alternative.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, in four-digit format. For compatibility with early implementations 
 of JavaScript, if this argument is between 0 and 99, 1900 is added to it.<DD><CODE>mo</CODE> - The month, specified as an integer from 0 (January) to 11 (December).<DD><CODE>day</CODE> - The day of the month, specified as an integer from 1 to 31. Note that 
 this argument uses 1 as its lowest value, while other arguments use 0 as their 
 lowest value. Optional.<DD><CODE>hr</CODE> - The hour, specified as an integer from 0 (midnight) to 23 (11 p.m.). 
 Optional.<DD><CODE>min</CODE> - The minutes in the hour, specified as an integer from 0 to 59. Optional.<DD><CODE>sec</CODE> - The seconds in the minute, specified as an integer from 0 to 59. Optional.<DD><CODE>ms</CODE> - The milliseconds in the second, specified as an integer from 0 to 999. 
 Optional.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#JsDate(js.core.JsObject)"><CODE>JsDate(js.core.JsObject)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate(Number)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#JsDate(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsDate(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.create(Object, Object, Object, Object, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the construction operation of this constructor 
 with the JavaScript expression:
 <pre>new Date(yr, mo, day, hr, min, sec, ms)</pre></DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="var()"><!-- --></A><H3>
var</H3>
<PRE>
public <A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A> <B>var</B>()</PRE>
<DL>
<DD><p>Simply returns the current date instance.</p>
 <p>This method is useful for JS Simulation to implement opaque types.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#var()">var</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE><DT><B>Specified by:</B><DD><CODE><A HREF="../../js/ObjectLike.html#var()">var</A></CODE> in interface <CODE><A HREF="../../js/ObjectLike.html" title="interface in js">ObjectLike</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../js/core/JsObject.html#var()">var</A></CODE> in class <CODE><A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The current boolean instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the instance invocation of this method, that is, 
 replacing it with its current instance.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="var(js.core.JsObject)"><!-- --></A><A NAME="var(S)"><!-- --></A><H3>
var</H3>
<PRE>
public final &lt;S extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; S <B>var</B>(S&nbsp;var)</PRE>
<DL>
<DD><p>Assigns the value of another date instance to the current date object.</p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../js/core/JsObject.html#var(T)">var</A></CODE> in class <CODE><A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The argument date instance.
<DT><B>Returns:</B><DD>The new instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method into 
 the JavaScript expression: 
 <pre>o = var</pre>
 where <tt>o</tt> is the current instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTime()"><!-- --></A><H3>
getTime</H3>
<PRE>
public final java.lang.Number <B>getTime</B>()</PRE>
<DL>
<DD><p>Returns the internal, millisecond representation of the current date instance.</p>
 <p>It converts the current date instance to a single integer. This is useful when 
 you want to compare two date instances or to determine the time elapsed between two 
 dates. Note that the millisecond representation of a date is independent of the 
 time zone, so there is no <tt>getUTCTime()</tt> method in addition to this one. 
 Don't confuse this method with the <A HREF="../../js/core/JsDate.html#getDay()"><CODE>getDay()</CODE></A> and <A HREF="../../js/core/JsDate.html#getDate()"><CODE>getDate()</CODE></A> methods, 
 which return the day of the week and the day of the month, respectively</p>
 <p><A HREF="../../js/core/JsGlobal.Date.html#parse(java.lang.Object)"><CODE>JsGlobal.Date.parse(Object)</CODE></A> and <A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object)</CODE></A> 
 allow you to convert a date and time specification to a millisecond representation without 
 going through the overhead of first creating a date object.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getTime()">getTime</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The millisecond representation of the current date instance, that is, the 
 number of milliseconds between midnight (GMT) on 1/1/1970 and the date and time 
 specified by the date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setTime(java.lang.Object)"><CODE>setTime(Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#parse(java.lang.Object)"><CODE>JsGlobal.Date.parse(Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object, Object, Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getTime(js.DateLike)"><CODE>DateLikes.getTime(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getFullYear()"><!-- --></A><H3>
getFullYear</H3>
<PRE>
public final java.lang.Number <B>getFullYear</B>()</PRE>
<DL>
<DD><p>Returns the year of the current date instance in full four-digit form, in local 
 time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getFullYear()">getFullYear</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The year that results when the current date instance is expressed in local 
 time. The return value is a full four-digit year, including the century, not a 
 two-digit abbreviation..<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getUTCFullYear()"><CODE>getUTCFullYear()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getFullYear(js.DateLike)"><CODE>DateLikes.getFullYear(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUTCFullYear()"><!-- --></A><H3>
getUTCFullYear</H3>
<PRE>
public final java.lang.Number <B>getUTCFullYear</B>()</PRE>
<DL>
<DD><p>Returns the year of the current date instance in full four-digit form, in 
 universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getUTCFullYear()">getUTCFullYear</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The year that results when the current date instance is expressed in 
 universal time. The return value is a full four-digit year, not a two-digit 
 abbreviation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getFullYear()"><CODE>getFullYear()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getUTCFullYear(js.DateLike)"><CODE>DateLikes.getUTCFullYear(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMonth()"><!-- --></A><H3>
getMonth</H3>
<PRE>
public final java.lang.Number <B>getMonth</B>()</PRE>
<DL>
<DD><p>Returns the month field of the current date instance, in local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getMonth()">getMonth</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The month of the year that results when the current date instance is 
 expressed in local time. The return value is an integer between 0 (January) 
 and 11 (December). Note that the date represents the first day of the month as 1 
 but represents the first month of the year as 0.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getUTCMonth()"><CODE>getUTCMonth()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getMonth(js.DateLike)"><CODE>DateLikes.getMonth(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUTCMonth()"><!-- --></A><H3>
getUTCMonth</H3>
<PRE>
public final java.lang.Number <B>getUTCMonth</B>()</PRE>
<DL>
<DD><p>Returns the month field of the current date instance, in universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getUTCMonth()">getUTCMonth</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The month of the year that results when the current date instance is 
 expressed in universal time. The return value is an integer between 0 (January) 
 and 11 (December). Note that the date represents the first day of the month as 1 
 but represents the first month of the year as 0.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getMonth()"><CODE>getMonth()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getUTCMonth(js.DateLike)"><CODE>DateLikes.getUTCMonth(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDate()"><!-- --></A><H3>
getDate</H3>
<PRE>
public final java.lang.Number <B>getDate</B>()</PRE>
<DL>
<DD><p>Returns the day of the month of the current date instance, in local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getDate()">getDate</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The day of the month of the current date instance, using local time. 
 Return values are between 1 and 31.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getUTCDate()"><CODE>getUTCDate()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getDate(js.DateLike)"><CODE>DateLikes.getDate(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUTCDate()"><!-- --></A><H3>
getUTCDate</H3>
<PRE>
public final java.lang.Number <B>getUTCDate</B>()</PRE>
<DL>
<DD><p>Returns the day of the month of the current date instance, in universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getUTCDate()">getUTCDate</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The day of the month (a value between 1 and 31) that results when the 
 current date instance is expressed in universal time.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../jsx/core/DateLikes.html#getUTCDate(js.DateLike)"><CODE>DateLikes.getUTCDate(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDay()"><!-- --></A><H3>
getDay</H3>
<PRE>
public final java.lang.Number <B>getDay</B>()</PRE>
<DL>
<DD><p>Returns the day of the week of the current date instance, in local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getDay()">getDay</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The day of the week of the current date instance, using local time. Return values 
 are between 0 (Sunday) and 6 (Saturday).<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getUTCDay()"><CODE>getUTCDay()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getDay(js.DateLike)"><CODE>DateLikes.getDay(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUTCDay()"><!-- --></A><H3>
getUTCDay</H3>
<PRE>
public final java.lang.Number <B>getUTCDay</B>()</PRE>
<DL>
<DD><p>Returns the day of the week of current date instance, in universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getUTCDay()">getUTCDay</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The day of the week that results when the current date instance is expressed 
 in universal time. Return values are between 0 (Sunday) and 6 (Saturday).<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getDay()"><CODE>getDay()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getUTCDay(js.DateLike)"><CODE>DateLikes.getUTCDay(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getHours()"><!-- --></A><H3>
getHours</H3>
<PRE>
public final java.lang.Number <B>getHours</B>()</PRE>
<DL>
<DD><p>Returns the hours field of the current date instance, in local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getHours()">getHours</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The hours field, expressed in local time, of the current date instance. 
 Return values are between 0 (midnight) and 23 (11 p.m.).<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getUTCHours()"><CODE>getUTCHours()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getHours(js.DateLike)"><CODE>DateLikes.getHours(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUTCHours()"><!-- --></A><H3>
getUTCHours</H3>
<PRE>
public final java.lang.Number <B>getUTCHours</B>()</PRE>
<DL>
<DD><p>Returns the hours field of the current date instance, in universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getUTCHours()">getUTCHours</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The hours field, expressed in universal time, of the current date instance. 
 The return value is an integer between 0 (midnight) and 23 (11 p.m.).<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getHours()"><CODE>getHours()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getUTCHours(js.DateLike)"><CODE>DateLikes.getUTCHours(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMinutes()"><!-- --></A><H3>
getMinutes</H3>
<PRE>
public final java.lang.Number <B>getMinutes</B>()</PRE>
<DL>
<DD><p>Returns the minutes field of a Date object, in local or universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getMinutes()">getMinutes</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The minutes field, expressed in local time, of the current date instance. 
 Return values are between 0 and 59.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getUTCMinutes()"><CODE>getUTCMinutes()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getMinutes(js.DateLike)"><CODE>DateLikes.getMinutes(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUTCMinutes()"><!-- --></A><H3>
getUTCMinutes</H3>
<PRE>
public final java.lang.Number <B>getUTCMinutes</B>()</PRE>
<DL>
<DD><p>Returns the minutes field of the current date instance, in universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getUTCMinutes()">getUTCMinutes</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The minutes field, expressed in universal time, of the current date instance. 
 The return value is an integer between 0 and 59.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getMinutes()"><CODE>getMinutes()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getUTCMinutes(js.DateLike)"><CODE>DateLikes.getUTCMinutes(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSeconds()"><!-- --></A><H3>
getSeconds</H3>
<PRE>
public final java.lang.Number <B>getSeconds</B>()</PRE>
<DL>
<DD><p>Returns the seconds field of the current date instance, in local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getSeconds()">getSeconds</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The seconds field, expressed in local time, of the current date instance. 
 Return values are between 0 and 59.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getUTCSeconds()"><CODE>getUTCSeconds()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getSeconds(js.DateLike)"><CODE>DateLikes.getSeconds(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUTCSeconds()"><!-- --></A><H3>
getUTCSeconds</H3>
<PRE>
public final java.lang.Number <B>getUTCSeconds</B>()</PRE>
<DL>
<DD><p>Returns the seconds field of the current date instance, in universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getUTCSeconds()">getUTCSeconds</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The seconds field, expressed in universal time, of the current date instance. 
 The return value is an integer between 0 and 59.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getSeconds()"><CODE>getSeconds()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getUTCSeconds(js.DateLike)"><CODE>DateLikes.getUTCSeconds(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMilliseconds()"><!-- --></A><H3>
getMilliseconds</H3>
<PRE>
public final java.lang.Number <B>getMilliseconds</B>()</PRE>
<DL>
<DD><p>Returns the milliseconds field of the current date instance, in local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getMilliseconds()">getMilliseconds</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The milliseconds field, expressed in local time, of the current date instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getUTCMilliseconds()"><CODE>getUTCMilliseconds()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getMilliseconds(js.DateLike)"><CODE>DateLikes.getMilliseconds(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getUTCMilliseconds()"><!-- --></A><H3>
getUTCMilliseconds</H3>
<PRE>
public final java.lang.Number <B>getUTCMilliseconds</B>()</PRE>
<DL>
<DD><p>Returns the milliseconds field of current date instance, in universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getUTCMilliseconds()">getUTCMilliseconds</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The milliseconds field, expressed in universal time, of the current date instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#getMilliseconds()"><CODE>getMilliseconds()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#getUTCMilliseconds(js.DateLike)"><CODE>DateLikes.getUTCMilliseconds(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTimezoneOffset()"><!-- --></A><H3>
getTimezoneOffset</H3>
<PRE>
public final java.lang.Number <B>getTimezoneOffset</B>()</PRE>
<DL>
<DD><p>Returns the difference, in minutes, between the local and UTC representations of 
 the current date instance. Note that the value returned depends on whether daylight 
 saving time is or would be in effect at the specific date.</p>
 <p>The return value is measured in minutes, rather than hours, because some 
 countries have time zones that are not at even one-hour intervals.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#getTimezoneOffset()">getTimezoneOffset</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The difference, in minutes, between GMT and local time.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../jsx/core/DateLikes.html#getTimezoneOffset(js.DateLike)"><CODE>DateLikes.getTimezoneOffset(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTime(java.lang.Object)"><!-- --></A><H3>
setTime</H3>
<PRE>
public final java.lang.Number <B>setTime</B>(java.lang.Object&nbsp;time)</PRE>
<DL>
<DD><p>Sets the fields of the current date instance using the millisecond format.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setTime(java.lang.Object)">setTime</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - The number of milliseconds between the desired date and time and 
 midnight GMT on January 1, 1970. A millisecond value of this type may also be 
 passed to the <A HREF="../../js/Js.html#date(java.lang.Number)"><CODE>Js.date(Number)</CODE></A>, <A HREF="../../js/core/JsDate.html#JsDate(java.lang.Number)"><CODE>JsDate(Number)</CODE></A>, 
 <A HREF="../../js/core/JsDate.html#JsDate(js.NumberLike)"><CODE>JsDate(NumberLike)</CODE></A>, <A HREF="../../js/core/JsDate.html#JsDate(java.lang.String)"><CODE>JsDate(String)</CODE></A>, 
 <A HREF="../../js/core/JsDate.html#JsDate(js.StringLike)"><CODE>JsDate(StringLike)</CODE></A>, <A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Number)"><CODE>JsGlobal.Date.create(Number)</CODE></A> 
 or <A HREF="../../js/core/JsGlobal.Date.html#create(java.lang.Number)"><CODE>JsGlobal.Date.create(Number)</CODE></A> and may be obtained by calling the 
 <A HREF="../../js/core/JsGlobal.Date.html#UTC(java.lang.Object, java.lang.Object)"><CODE>JsGlobal.Date.UTC(Object, Object)</CODE></A> and <A HREF="../../js/core/JsGlobal.Date.html#parse(java.lang.Object)"><CODE>JsGlobal.Date.parse(Object)</CODE></A> 
 methods. Representing a date in this millisecond format makes it independent of 
 time zone.
<DT><B>Returns:</B><DD>The <tt>time</tt> argument. Prior to ECMAScript standardization, 
 this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../jsx/core/DateLikes.html#setTime(js.DateLike, java.lang.Object)"><CODE>DateLikes.setTime(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMilliseconds(java.lang.Object)"><!-- --></A><H3>
setMilliseconds</H3>
<PRE>
public final java.lang.Number <B>setMilliseconds</B>(java.lang.Object&nbsp;ms)</PRE>
<DL>
<DD><p>Sets the milliseconds field of a date, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setMilliseconds(java.lang.Object)">setMilliseconds</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ms</CODE> - The milliseconds field, expressed in local time, to be set in the current 
 date instance. This argument should be an integer between 0 and 999.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCMilliseconds(java.lang.Object)"><CODE>setUTCMilliseconds(Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setMilliseconds(js.DateLike, java.lang.Object)"><CODE>DateLikes.setMilliseconds(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCMilliseconds(java.lang.Object)"><!-- --></A><H3>
setUTCMilliseconds</H3>
<PRE>
public final java.lang.Number <B>setUTCMilliseconds</B>(java.lang.Object&nbsp;ms)</PRE>
<DL>
<DD><p>Sets the milliseconds field of the current date instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCMilliseconds(java.lang.Object)">setUTCMilliseconds</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ms</CODE> - The milliseconds field, expressed in universal time, to be set in the 
 current date instance. This argument should be an integer between 0 and 999.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setMilliseconds(java.lang.Object)"><CODE>setMilliseconds(Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCMilliseconds(js.DateLike, java.lang.Object)"><CODE>DateLikes.setUTCMilliseconds(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSeconds(java.lang.Object)"><!-- --></A><H3>
setSeconds</H3>
<PRE>
public final java.lang.Number <B>setSeconds</B>(java.lang.Object&nbsp;sec)</PRE>
<DL>
<DD><p>Sets the seconds field of the current date instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setSeconds(java.lang.Object)">setSeconds</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sec</CODE> - An integer between 0 and 59 that is set as the seconds value for the 
 current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. Prior to ECMAScript 
 standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCSeconds(java.lang.Object)"><CODE>setUTCSeconds(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setSeconds(java.lang.Object, java.lang.Object)"><CODE>setSeconds(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setSeconds(js.DateLike, java.lang.Object)"><CODE>DateLikes.setSeconds(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCSeconds(java.lang.Object)"><!-- --></A><H3>
setUTCSeconds</H3>
<PRE>
public final java.lang.Number <B>setUTCSeconds</B>(java.lang.Object&nbsp;sec)</PRE>
<DL>
<DD><p>Sets the seconds field of the current date instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCSeconds(java.lang.Object)">setUTCSeconds</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sec</CODE> - The seconds field, expressed in universal time, to be set in the current 
 date instance. This argument should be an integer between 0 and 59.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setSeconds(java.lang.Object)"><CODE>setSeconds(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCSeconds(java.lang.Object, java.lang.Object)"><CODE>setUTCSeconds(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCSeconds(js.DateLike, java.lang.Object)"><CODE>DateLikes.setUTCSeconds(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setSeconds(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setSeconds</H3>
<PRE>
public final java.lang.Number <B>setSeconds</B>(java.lang.Object&nbsp;sec,
                                         java.lang.Object&nbsp;ms)</PRE>
<DL>
<DD><p>Sets the seconds field and optionally the milliseconds field of the current date 
 instance, using local .</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setSeconds(java.lang.Object, java.lang.Object)">setSeconds</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sec</CODE> - An integer between 0 and 59 that is set as the seconds value for the 
 current date instance.<DD><CODE>ms</CODE> - An optional integer, between 0 and 999, that is used as the new value 
 in local time of the milliseconds field of the current date instance. This argument 
 is not supported prior to ECMAScript standardization.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. Prior to ECMAScript 
 standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCSeconds(java.lang.Object, java.lang.Object)"><CODE>setUTCSeconds(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setSeconds(java.lang.Object)"><CODE>setSeconds(Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setSeconds(js.DateLike, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setSeconds(DateLike, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCSeconds(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setUTCSeconds</H3>
<PRE>
public final java.lang.Number <B>setUTCSeconds</B>(java.lang.Object&nbsp;sec,
                                            java.lang.Object&nbsp;ms)</PRE>
<DL>
<DD><p>Sets the seconds field and optionally the milliseconds field of the current date 
 instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCSeconds(java.lang.Object, java.lang.Object)">setUTCSeconds</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sec</CODE> - The seconds field, expressed in universal time, to be set in the current 
 date instance. This argument should be an integer between 0 and 59.<DD><CODE>ms</CODE> - An optional integer, between 0 and 999, that is used as the new value 
 in universal time of the milliseconds field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setSeconds(java.lang.Object, java.lang.Object)"><CODE>setSeconds(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCSeconds(java.lang.Object)"><CODE>setUTCSeconds(Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCSeconds(js.DateLike, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setUTCSeconds(DateLike, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMinutes(java.lang.Object)"><!-- --></A><H3>
setMinutes</H3>
<PRE>
public final java.lang.Number <B>setMinutes</B>(java.lang.Object&nbsp;min)</PRE>
<DL>
<DD><p>Sets the minutes field of the current date instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setMinutes(java.lang.Object)">setMinutes</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in local time of the minutes field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object)"><CODE>setUTCMinutes(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object, java.lang.Object)"><CODE>setMinutes(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setMinutes(Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setMinutes(js.DateLike, java.lang.Object)"><CODE>DateLikes.setMinutes(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCMinutes(java.lang.Object)"><!-- --></A><H3>
setUTCMinutes</H3>
<PRE>
public final java.lang.Number <B>setUTCMinutes</B>(java.lang.Object&nbsp;min)</PRE>
<DL>
<DD><p>Sets the minutes field of the current date instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCMinutes(java.lang.Object)">setUTCMinutes</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in universal time of the minutes field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object)"><CODE>setMinutes(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object, java.lang.Object)"><CODE>setUTCMinutes(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCMinutes(Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCMinutes(js.DateLike, java.lang.Object)"><CODE>DateLikes.setUTCMinutes(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMinutes(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setMinutes</H3>
<PRE>
public final java.lang.Number <B>setMinutes</B>(java.lang.Object&nbsp;min,
                                         java.lang.Object&nbsp;sec)</PRE>
<DL>
<DD><p>Sets the minutes field and optionally the seconds field of the current date 
 instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setMinutes(java.lang.Object, java.lang.Object)">setMinutes</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in local time of the minutes field of the current date instance. This argument is 
 not supported prior to ECMAScript standardization.<DD><CODE>sec</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in local time of the seconds field of the current date instance. This argument is 
 not supported prior to ECMAScript standardization.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object, java.lang.Object)"><CODE>setUTCMinutes(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object)"><CODE>setMinutes(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setMinutes(Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setMinutes(js.DateLike, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setMinutes(DateLike, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCMinutes(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setUTCMinutes</H3>
<PRE>
public final java.lang.Number <B>setUTCMinutes</B>(java.lang.Object&nbsp;min,
                                            java.lang.Object&nbsp;sec)</PRE>
<DL>
<DD><p>Sets the minutes field and optionally the seconds field of the current date 
 instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCMinutes(java.lang.Object, java.lang.Object)">setUTCMinutes</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in universal time of the minutes field of the current date instance.<DD><CODE>sec</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in universal time of the seconds field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object, java.lang.Object)"><CODE>setMinutes(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object)"><CODE>setUTCMinutes(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCMinutes(Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCMinutes(js.DateLike, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setUTCMinutes(DateLike, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMinutes(java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setMinutes</H3>
<PRE>
public final java.lang.Number <B>setMinutes</B>(java.lang.Object&nbsp;min,
                                         java.lang.Object&nbsp;sec,
                                         java.lang.Object&nbsp;ms)</PRE>
<DL>
<DD><p>Sets the minutes field and optionally the seconds and milliseconds fields of the 
 current date instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setMinutes(java.lang.Object, java.lang.Object, java.lang.Object)">setMinutes</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in local time of the minutes field of the current date instance. This argument is 
 not supported prior to ECMAScript standardization.<DD><CODE>sec</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in local time of the seconds field of the current date instance. This argument is 
 not supported prior to ECMAScript standardization.<DD><CODE>ms</CODE> - An optional integer, between 0 and 999, that is used as the new value 
 in local time of the milliseconds field of the current date instance. This argument 
 is not supported prior to ECMAScript standardization.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCMinutes(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object)"><CODE>setMinutes(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object, java.lang.Object)"><CODE>setMinutes(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setMinutes(js.DateLike, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setMinutes(DateLike, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCMinutes(java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setUTCMinutes</H3>
<PRE>
public final java.lang.Number <B>setUTCMinutes</B>(java.lang.Object&nbsp;min,
                                            java.lang.Object&nbsp;sec,
                                            java.lang.Object&nbsp;ms)</PRE>
<DL>
<DD><p>Sets the minutes field and optionally the seconds and milliseconds fields of the 
 current date instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCMinutes(java.lang.Object, java.lang.Object, java.lang.Object)">setUTCMinutes</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in universal time of the minutes field of the current date instance.<DD><CODE>sec</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in universal time of the seconds field of the current date instance.<DD><CODE>ms</CODE> - An optional integer, between 0 and 999, that is used as the new value 
 in universal time of the milliseconds field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setMinutes(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setMinutes(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object)"><CODE>setUTCMinutes(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCMinutes(java.lang.Object, java.lang.Object)"><CODE>setUTCMinutes(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCMinutes(js.DateLike, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setUTCMinutes(DateLike, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setHours(java.lang.Object)"><!-- --></A><H3>
setHours</H3>
<PRE>
public final java.lang.Number <B>setHours</B>(java.lang.Object&nbsp;hr)</PRE>
<DL>
<DD><p>Sets the hour field of the current date instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setHours(java.lang.Object)">setHours</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hr</CODE> - An integer between 0 (midnight) and 23 (11 p.m.) local time that is set 
 as the new hours value of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object)"><CODE>setUTCHours(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setHours(js.DateLike, java.lang.Object)"><CODE>DateLikes.setHours(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCHours(java.lang.Object)"><!-- --></A><H3>
setUTCHours</H3>
<PRE>
public final java.lang.Number <B>setUTCHours</B>(java.lang.Object&nbsp;hr)</PRE>
<DL>
<DD><p>Sets the hour field of the current date instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCHours(java.lang.Object)">setUTCHours</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hr</CODE> - The hours field, expressed in universal time, to be set in the current 
 date instance. This argument should be an integer between 0 (midnight) and 23 
 (11 p.m.).
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setHours(java.lang.Object)"><CODE>setHours(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCHours(js.DateLike, java.lang.Object)"><CODE>DateLikes.setUTCHours(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setHours(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setHours</H3>
<PRE>
public final java.lang.Number <B>setHours</B>(java.lang.Object&nbsp;hr,
                                       java.lang.Object&nbsp;min)</PRE>
<DL>
<DD><p>Sets the hour field and optionally the minutes field of the current date 
 instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setHours(java.lang.Object, java.lang.Object)">setHours</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hr</CODE> - An integer between 0 (midnight) and 23 (11 p.m.) local time that is set 
 as the new hours value of the current date instance.<DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in local time of the minutes field of the current date instance. This argument is 
 not supported prior to ECMAScript standardization.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object)"><CODE>setHours(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setHours(js.DateLike, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setHours(DateLike, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCHours(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setUTCHours</H3>
<PRE>
public final java.lang.Number <B>setUTCHours</B>(java.lang.Object&nbsp;hr,
                                          java.lang.Object&nbsp;min)</PRE>
<DL>
<DD><p>Sets the hour field and optionally the minutes field of the current date 
 instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCHours(java.lang.Object, java.lang.Object)">setUTCHours</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hr</CODE> - The hours field, expressed in universal time, to be set in the current 
 date instance. This argument should be an integer between 0 (midnight) and 23 
 (11 p.m.).<DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in universal time of the minutes field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object)"><CODE>setUTCHours(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCHours(js.DateLike, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setUTCHours(DateLike, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setHours(java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setHours</H3>
<PRE>
public final java.lang.Number <B>setHours</B>(java.lang.Object&nbsp;hr,
                                       java.lang.Object&nbsp;min,
                                       java.lang.Object&nbsp;sec)</PRE>
<DL>
<DD><p>Sets the hour field and optionally the minutes and seconds fields of the current 
 date instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object)">setHours</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hr</CODE> - An integer between 0 (midnight) and 23 (11 p.m.) local time that is set 
 as the new hours value of the current date instance.<DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in local time of the minutes field of the current date instance. This argument is 
 not supported prior to ECMAScript standardization.<DD><CODE>sec</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in local time of the seconds field of the current date instance. This argument is 
 not supported prior to ECMAScript standardization.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object)"><CODE>setHours(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setHours(js.DateLike, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setHours(DateLike, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setUTCHours</H3>
<PRE>
public final java.lang.Number <B>setUTCHours</B>(java.lang.Object&nbsp;hr,
                                          java.lang.Object&nbsp;min,
                                          java.lang.Object&nbsp;sec)</PRE>
<DL>
<DD><p>Sets the hour field and optionally the minutes and seconds fields of the current 
 date instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object)">setUTCHours</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hr</CODE> - The hours field, expressed in universal time, to be set in the current 
 date instance. This argument should be an integer between 0 (midnight) and 23 
 (11 p.m.).<DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in universal time of the minutes field of the current date instance.<DD><CODE>sec</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in universal time of the seconds field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object)"><CODE>setUTCHours(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCHours(js.DateLike, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setUTCHours(DateLike, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setHours</H3>
<PRE>
public final java.lang.Number <B>setHours</B>(java.lang.Object&nbsp;hr,
                                       java.lang.Object&nbsp;min,
                                       java.lang.Object&nbsp;sec,
                                       java.lang.Object&nbsp;ms)</PRE>
<DL>
<DD><p>Sets the hour field and optionally the minutes, seconds, and milliseconds fields 
 of the current date instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">setHours</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hr</CODE> - An integer between 0 (midnight) and 23 (11 p.m.) local time that is set 
 as the new hours value of the current date instance.<DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in local time of the minutes field of the current date instance. This argument is 
 not supported prior to ECMAScript standardization.<DD><CODE>sec</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in local time of the seconds field of the current date instance. This argument is 
 not supported prior to ECMAScript standardization.<DD><CODE>ms</CODE> - An optional integer, between 0 and 999, that is used as the new value 
 in local time of the milliseconds field of the current date instance. This argument 
 is not supported prior to ECMAScript standardization.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object)"><CODE>setHours(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setHours(js.DateLike, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setHours(DateLike, Object, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setUTCHours</H3>
<PRE>
public final java.lang.Number <B>setUTCHours</B>(java.lang.Object&nbsp;hr,
                                          java.lang.Object&nbsp;min,
                                          java.lang.Object&nbsp;sec,
                                          java.lang.Object&nbsp;ms)</PRE>
<DL>
<DD><p>Sets the hour field and optionally the minutes, seconds, and milliseconds fields 
 of the current date instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)">setUTCHours</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hr</CODE> - The hours field, expressed in universal time, to be set in the current 
 date instance. This argument should be an integer between 0 (midnight) and 23 
 (11 p.m.).<DD><CODE>min</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in universal time of the minutes field of the current date instance.<DD><CODE>sec</CODE> - An optional integer, between 0 and 59, that is used as the new value 
 in universal time of the seconds field of the current date instance.<DD><CODE>ms</CODE> - An optional integer, between 0 and 999, that is used as the new value 
 in universal time of the milliseconds field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setHours(java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setHours(Object, Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object)"><CODE>setUTCHours(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCHours(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCHours(Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCHours(js.DateLike, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setUTCHours(DateLike, Object, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDate(java.lang.Object)"><!-- --></A><H3>
setDate</H3>
<PRE>
public final java.lang.Number <B>setDate</B>(java.lang.Object&nbsp;day)</PRE>
<DL>
<DD><p>Sets the day of the month field of the current date instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setDate(java.lang.Object)">setDate</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>day</CODE> - An integer between 1 and 31 that is used as the new value in local time 
 of the day-of-the-month field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCDate(java.lang.Object)"><CODE>setUTCDate(Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setDate(js.DateLike, java.lang.Object)"><CODE>DateLikes.setDate(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCDate(java.lang.Object)"><!-- --></A><H3>
setUTCDate</H3>
<PRE>
public final java.lang.Number <B>setUTCDate</B>(java.lang.Object&nbsp;day)</PRE>
<DL>
<DD><p>Sets the day of the month field of the current date instance, using universal 
 time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCDate(java.lang.Object)">setUTCDate</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>day</CODE> - The day of the month, expressed in universal time, to be set in the 
 current date instance. This argument should be an integer between 1 and 31.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setDate(java.lang.Object)"><CODE>setDate(Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCDate(js.DateLike, java.lang.Object)"><CODE>DateLikes.setUTCDate(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMonth(java.lang.Object)"><!-- --></A><H3>
setMonth</H3>
<PRE>
public final java.lang.Number <B>setMonth</B>(java.lang.Object&nbsp;mo)</PRE>
<DL>
<DD><p>Sets the month field of the current date instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setMonth(java.lang.Object)">setMonth</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mo</CODE> - An integer between 0 ( January) and 11 (December) that is set as the month 
 value in local time for the current date instance. Note that months are numbered 
 beginning with 0, while days within the month are numbered beginning with 1.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCMonth(java.lang.Object)"><CODE>setUTCMonth(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setMonth(java.lang.Object, java.lang.Object)"><CODE>setMonth(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setMonth(js.DateLike, java.lang.Object)"><CODE>DateLikes.setMonth(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCMonth(java.lang.Object)"><!-- --></A><H3>
setUTCMonth</H3>
<PRE>
public final java.lang.Number <B>setUTCMonth</B>(java.lang.Object&nbsp;mo)</PRE>
<DL>
<DD><p>Sets the month field of the current date instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCMonth(java.lang.Object)">setUTCMonth</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mo</CODE> - The month, expressed in universal time, to be set in the current date
 instance. This argument should be an integer between 0 (January) and 11 (December). 
 Note that months are numbered beginning with 0, while days within the month are 
 numbered beginning with 1.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setMonth(java.lang.Object)"><CODE>setMonth(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCMonth(java.lang.Object, java.lang.Object)"><CODE>setUTCMonth(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCMonth(js.DateLike, java.lang.Object)"><CODE>DateLikes.setUTCMonth(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMonth(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setMonth</H3>
<PRE>
public final java.lang.Number <B>setMonth</B>(java.lang.Object&nbsp;mo,
                                       java.lang.Object&nbsp;day)</PRE>
<DL>
<DD><p>Sets the month field and optionally the day of the month of the current date 
 instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setMonth(java.lang.Object, java.lang.Object)">setMonth</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mo</CODE> - An integer between 0 ( January) and 11 (December) that is set as the month 
 value in local time for the current date instance. Note that months are numbered 
 beginning with 0, while days within the month are numbered beginning with 1.<DD><CODE>day</CODE> - An optional integer between 1 and 31 that is used as the new value in 
 local time of the day-of-the-month field of the current date instance. This argument 
 is not supported prior to ECMAScript standardization.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date. 
 Prior to ECMAScript standardization, this method returns nothing.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCMonth(java.lang.Object, java.lang.Object)"><CODE>setUTCMonth(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setMonth(java.lang.Object)"><CODE>setMonth(Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setMonth(js.DateLike, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setMonth(DateLike, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCMonth(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setUTCMonth</H3>
<PRE>
public final java.lang.Number <B>setUTCMonth</B>(java.lang.Object&nbsp;mo,
                                          java.lang.Object&nbsp;day)</PRE>
<DL>
<DD><p>Sets the month field and optionally the day of the month of the current date 
 instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCMonth(java.lang.Object, java.lang.Object)">setUTCMonth</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mo</CODE> - The month, expressed in universal time, to be set in the current date
 instance. This argument should be an integer between 0 (January) and 11 (December). 
 Note that months are numbered beginning with 0, while days within the month are 
 numbered beginning with 1.<DD><CODE>day</CODE> - An optional integer between 1 and 31 that is used as the new value in 
 universal time of the day-of-the-month field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setMonth(java.lang.Object, java.lang.Object)"><CODE>setMonth(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCMonth(java.lang.Object)"><CODE>setUTCMonth(Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCMonth(js.DateLike, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setUTCMonth(DateLike, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFullYear(java.lang.Object)"><!-- --></A><H3>
setFullYear</H3>
<PRE>
public final java.lang.Number <B>setFullYear</B>(java.lang.Object&nbsp;yr)</PRE>
<DL>
<DD><p>Sets the year field of the current date instance, using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setFullYear(java.lang.Object)">setFullYear</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, expressed in local time, to be set in the current date instance. 
 This argument should be an integer that includes the century, such as 1999; it 
 should not be an abbreviation, such as 99.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object)"><CODE>setUTCFullYear(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object, java.lang.Object)"><CODE>setFullYear(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setFullYear(Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setFullYear(js.DateLike, java.lang.Object)"><CODE>DateLikes.setFullYear(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCFullYear(java.lang.Object)"><!-- --></A><H3>
setUTCFullYear</H3>
<PRE>
public final java.lang.Number <B>setUTCFullYear</B>(java.lang.Object&nbsp;yr)</PRE>
<DL>
<DD><p>Sets the year field of the current date instance, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCFullYear(java.lang.Object)">setUTCFullYear</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, expressed in universal time, to be set in the current date 
 instance. This argument should be an integer that includes the century, such as 
 1999, not an abbreviation, such as 99.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object)"><CODE>setFullYear(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object, java.lang.Object)"><CODE>setUTCFullYear(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCFullYear(Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCFullYear(js.DateLike, java.lang.Object)"><CODE>DateLikes.setUTCFullYear(DateLike, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFullYear(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setFullYear</H3>
<PRE>
public final java.lang.Number <B>setFullYear</B>(java.lang.Object&nbsp;yr,
                                          java.lang.Object&nbsp;mo)</PRE>
<DL>
<DD><p>Sets the year and optionally month fields of the current date instance, using 
 local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setFullYear(java.lang.Object, java.lang.Object)">setFullYear</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, expressed in local time, to be set in the current date instance. 
 This argument should be an integer that includes the century, such as 1999; it 
 should not be an abbreviation, such as 99.<DD><CODE>mo</CODE> - An optional integer between 0 and 11 that is used as the new value in 
 local time of the month field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object, java.lang.Object)"><CODE>setUTCFullYear(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object)"><CODE>setFullYear(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setFullYear(Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setFullYear(js.DateLike, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setFullYear(DateLike, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCFullYear(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setUTCFullYear</H3>
<PRE>
public final java.lang.Number <B>setUTCFullYear</B>(java.lang.Object&nbsp;yr,
                                             java.lang.Object&nbsp;mo)</PRE>
<DL>
<DD><p>Sets the year and optionally month fields of the current date instance, using 
 universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCFullYear(java.lang.Object, java.lang.Object)">setUTCFullYear</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, expressed in universal time, to be set in the current date 
 instance. This argument should be an integer that includes the century, such as 
 1999, not an abbreviation, such as 99.<DD><CODE>mo</CODE> - An optional integer between 0 and 11 that is used as the new value in 
 universal time of the month field of the current date instance. Note that months 
 are numbered beginning with 0, while days within the month are numbered beginning 
 with 1.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object, java.lang.Object)"><CODE>setFullYear(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object)"><CODE>setUTCFullYear(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCFullYear(Object, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCFullYear(js.DateLike, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setUTCFullYear(DateLike, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFullYear(java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setFullYear</H3>
<PRE>
public final java.lang.Number <B>setFullYear</B>(java.lang.Object&nbsp;yr,
                                          java.lang.Object&nbsp;mo,
                                          java.lang.Object&nbsp;day)</PRE>
<DL>
<DD><p>Sets the year and optionally month and day fields of the current date instance, 
 using local time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setFullYear(java.lang.Object, java.lang.Object, java.lang.Object)">setFullYear</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, expressed in local time, to be set in the current date instance. 
 This argument should be an integer that includes the century, such as 1999; it 
 should not be an abbreviation, such as 99.<DD><CODE>mo</CODE> - An optional integer between 0 and 11 that is used as the new value in 
 local time of the month field of the current date instance.<DD><CODE>day</CODE> - An optional integer between 1 and 31 that is used as the new value in 
 local time of the day-of-the-month field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setUTCFullYear(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object)"><CODE>setFullYear(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object, java.lang.Object)"><CODE>setFullYear(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setFullYear(js.DateLike, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setFullYear(DateLike, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUTCFullYear(java.lang.Object, java.lang.Object, java.lang.Object)"><!-- --></A><H3>
setUTCFullYear</H3>
<PRE>
public final java.lang.Number <B>setUTCFullYear</B>(java.lang.Object&nbsp;yr,
                                             java.lang.Object&nbsp;mo,
                                             java.lang.Object&nbsp;day)</PRE>
<DL>
<DD><p>Sets the year and optionally month and day fields of the current date instance, 
 using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#setUTCFullYear(java.lang.Object, java.lang.Object, java.lang.Object)">setUTCFullYear</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>yr</CODE> - The year, expressed in universal time, to be set in the current date 
 instance. This argument should be an integer that includes the century, such as 
 1999, not an abbreviation, such as 99.<DD><CODE>mo</CODE> - An optional integer between 0 and 11 that is used as the new value in 
 universal time of the month field of the current date instance. Note that months 
 are numbered beginning with 0, while days within the month are numbered beginning 
 with 1.<DD><CODE>day</CODE> - An optional integer between 1 and 31 that is used as the new value in 
 universal time of the day-of-the-month field of the current date instance.
<DT><B>Returns:</B><DD>The millisecond representation of the adjusted date.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#setFullYear(java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>setFullYear(Object, Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object)"><CODE>setUTCFullYear(Object)</CODE></A>, 
<A HREF="../../js/core/JsDate.html#setUTCFullYear(java.lang.Object, java.lang.Object)"><CODE>setUTCFullYear(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#setUTCFullYear(js.DateLike, java.lang.Object, java.lang.Object, java.lang.Object)"><CODE>DateLikes.setUTCFullYear(DateLike, Object, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toDateString()"><!-- --></A><H3>
toDateString</H3>
<PRE>
public final java.lang.String <B>toDateString</B>()</PRE>
<DL>
<DD><p>Returns a string that represents the date portion of the current date instance, 
 expressed in the local time zone.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#toDateString()">toDateString</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>An implementation-dependent, human-readable string representation of the 
 date portion of the current date instance, expressed in the local time zone.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#toLocaleDateString()"><CODE>toLocaleDateString()</CODE></A>, 
<A HREF="../../js/core/JsObject.html#toLocaleString()"><CODE>JsObject.toLocaleString()</CODE></A>, 
<A HREF="../../js/core/JsDate.html#toLocaleTimeString()"><CODE>toLocaleTimeString()</CODE></A>, 
<A HREF="../../js/core/JsObject.html#toString()"><CODE>JsObject.toString()</CODE></A>, 
<A HREF="../../js/core/JsDate.html#toTimeString()"><CODE>toTimeString()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#toDateString(js.DateLike)"><CODE>DateLikes.toDateString(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toTimeString()"><!-- --></A><H3>
toTimeString</H3>
<PRE>
public final java.lang.String <B>toTimeString</B>()</PRE>
<DL>
<DD><p>Returns a string that represents the time portion of the current date instance, 
 expressed in the local time zone.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#toTimeString()">toTimeString</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>An implementation-dependent, human-readable string representation of the 
 time portion of the current date instance, expressed in the local time zone.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#toDateString()"><CODE>toDateString()</CODE></A>, 
<A HREF="../../js/core/JsDate.html#toLocaleDateString()"><CODE>toLocaleDateString()</CODE></A>, 
<A HREF="../../js/core/JsObject.html#toLocaleString()"><CODE>JsObject.toLocaleString()</CODE></A>, 
<A HREF="../../js/core/JsDate.html#toLocaleTimeString()"><CODE>toLocaleTimeString()</CODE></A>, 
<A HREF="../../js/core/JsObject.html#toString()"><CODE>JsObject.toString()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#toTimeString(js.DateLike)"><CODE>DateLikes.toTimeString(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toLocaleDateString()"><!-- --></A><H3>
toLocaleDateString</H3>
<PRE>
public final java.lang.String <B>toLocaleDateString</B>()</PRE>
<DL>
<DD><p>Returns a string that represents the date portion of the current date instance, 
 expressed in the local time zone, using the local date formatting conventions.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#toLocaleDateString()">toLocaleDateString</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>An implementation-dependent, human-readable string representation of the 
 date portion of the current date instance, expressed in the local time zone and 
 formatted according to local conventions.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#toDateString()"><CODE>toDateString()</CODE></A>, 
<A HREF="../../js/core/JsObject.html#toLocaleString()"><CODE>JsObject.toLocaleString()</CODE></A>, 
<A HREF="../../js/core/JsDate.html#toLocaleTimeString()"><CODE>toLocaleTimeString()</CODE></A>, 
<A HREF="../../js/core/JsObject.html#toString()"><CODE>JsObject.toString()</CODE></A>, 
<A HREF="../../js/core/JsDate.html#toTimeString()"><CODE>toTimeString()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#toLocaleDateString(js.DateLike)"><CODE>DateLikes.toLocaleDateString(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toLocaleTimeString()"><!-- --></A><H3>
toLocaleTimeString</H3>
<PRE>
public final java.lang.String <B>toLocaleTimeString</B>()</PRE>
<DL>
<DD><p>Returns a string that represents the time portion of the current date instance, 
 expressed in the local time zone, using the local time formatting conventions.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#toLocaleTimeString()">toLocaleTimeString</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>An implementation-dependent, human-readable string representation of the 
 time portion of the current date instance, expressed in the local time zone and 
 formatted according to local conventions.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsDate.html#toDateString()"><CODE>toDateString()</CODE></A>, 
<A HREF="../../js/core/JsDate.html#toLocaleDateString()"><CODE>toLocaleDateString()</CODE></A>, 
<A HREF="../../js/core/JsObject.html#toLocaleString()"><CODE>JsObject.toLocaleString()</CODE></A>, 
<A HREF="../../js/core/JsObject.html#toString()"><CODE>JsObject.toString()</CODE></A>, 
<A HREF="../../js/core/JsDate.html#toTimeString()"><CODE>toTimeString()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#toLocaleTimeString(js.DateLike)"><CODE>DateLikes.toLocaleTimeString(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toUTCString()"><!-- --></A><H3>
toUTCString</H3>
<PRE>
public final java.lang.String <B>toUTCString</B>()</PRE>
<DL>
<DD><p>Converts the current date instance to a string, using universal time.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#toUTCString()">toUTCString</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A human-readable string representation, expressed in universal time, of the 
 current date instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsObject.html#toLocaleString()"><CODE>JsObject.toLocaleString()</CODE></A>, 
<A HREF="../../js/core/JsObject.html#toString()"><CODE>JsObject.toString()</CODE></A>, 
<A HREF="../../jsx/core/DateLikes.html#toUTCString(js.DateLike)"><CODE>DateLikes.toUTCString(DateLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf()"><!-- --></A><H3>
valueOf</H3>
<PRE>
public java.lang.Number <B>valueOf</B>()</PRE>
<DL>
<DD><p>Returns the primitive value associated with the current instance, if there is one. 
 This invocation returns the primitive number value associated with the current instance.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/DateLike.html#valueOf()">valueOf</A></CODE> in interface <CODE><A HREF="../../js/DateLike.html" title="interface in js">DateLike</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../js/Var.html#valueOf()">valueOf</A></CODE> in class <CODE><A HREF="../../js/Var.html" title="class in js">Var</A>&lt;<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The millisecond representation of the current date instance. The value 
 returned is the same as that returned by <A HREF="../../js/core/JsDate.html#getTime()"><CODE>getTime()</CODE></A>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/Var.html#toString()"><CODE>Var.toString()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method directly 
 into a JavaScript invocation on its current date instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="inc()"><!-- --></A><H3>
inc</H3>
<PRE>
public java.lang.Number <B>inc</B>()</PRE>
<DL>
<DD><p>Increases the current date instance by 1 and then returns the value of the 
 current date instance, resembling the pre-increment operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The value of the current date instance increased by 1.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>++d</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="dec()"><!-- --></A><H3>
dec</H3>
<PRE>
public java.lang.Number <B>dec</B>()</PRE>
<DL>
<DD><p>Decreases the current date instance by 1 and then returns the value of the 
 current date instance, resembling the pre-decrement operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The value of the current date instance decreased by 1.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>--d</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="incp()"><!-- --></A><H3>
incp</H3>
<PRE>
public java.lang.Number <B>incp</B>()</PRE>
<DL>
<DD><p>Returns the primitive value of the current date instance and then increases the 
 current date instance by 1, resembling the post-increment operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The value of the original date instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>d++</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="decp()"><!-- --></A><H3>
decp</H3>
<PRE>
public java.lang.Number <B>decp</B>()</PRE>
<DL>
<DD><p>Returns the primitive value of the current date instance and then decreases the 
 current date instance by 1, resembling the post-decrement operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The value of the original date instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>d--</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="aadd(java.lang.Character)"><!-- --></A><H3>
aadd</H3>
<PRE>
public java.lang.Number <B>aadd</B>(java.lang.Character&nbsp;value)</PRE>
<DL>
<DD><p>Adds a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-addition operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The numeric value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d += value</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="aadd(js.Value.Character)"><!-- --></A><H3>
aadd</H3>
<PRE>
public java.lang.Number <B>aadd</B>(<A HREF="../../js/Value.Character.html" title="class in js">Value.Character</A>&nbsp;value)</PRE>
<DL>
<DD><p>Adds a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-addition operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The numeric value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d += value</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="aadd(java.lang.Number)"><!-- --></A><H3>
aadd</H3>
<PRE>
public java.lang.Number <B>aadd</B>(java.lang.Number&nbsp;value)</PRE>
<DL>
<DD><p>Adds a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-addition operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The numeric value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d += value</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="aadd(js.Value)"><!-- --></A><H3>
aadd</H3>
<PRE>
public java.lang.Number <B>aadd</B>(<A HREF="../../js/Value.html" title="class in js">Value</A>&lt;? extends java.lang.Number&gt;&nbsp;value)</PRE>
<DL>
<DD><p>Adds a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-addition operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The numeric value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d += value</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="aadd(js.core.JsNumber)"><!-- --></A><H3>
aadd</H3>
<PRE>
public java.lang.Number <B>aadd</B>(<A HREF="../../js/core/JsNumber.html" title="class in js.core">JsNumber</A>&nbsp;value)</PRE>
<DL>
<DD><p>Adds a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-addition operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The numeric value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d += value</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="asub(java.lang.Object)"><!-- --></A><H3>
asub</H3>
<PRE>
public java.lang.Number <B>asub</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Subtracts a numeric operand from the current date instance and returns the numeric 
 operand, resembling the assignment-with-subtraction operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The numeric value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d -= value</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="amul(java.lang.Object)"><!-- --></A><H3>
amul</H3>
<PRE>
public java.lang.Number <B>amul</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Multiplies a numeric operand to the current date instance and returns the numeric 
 operand, resembling the assignment-with-multiplication operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The numeric value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d *= value</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="adiv(java.lang.Object)"><!-- --></A><H3>
adiv</H3>
<PRE>
public java.lang.Number <B>adiv</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Divides, by a numeric operand, the current date instance and returns the numeric 
 operand, resembling the assignment-with-division operator in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The numeric value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d /= value</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="amod(java.lang.Object)"><!-- --></A><H3>
amod</H3>
<PRE>
public java.lang.Number <B>amod</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Modulo operates a numeric operand onto the current date instance and returns the 
 numeric operand, resembling the assignment-with-multiplication operator in 
 JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The numeric value of the argument.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d %= value</pre>
 where <tt>d</tt> is the primitive value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ashl(int)"><!-- --></A><H3>
ashl</H3>
<PRE>
public java.lang.Number <B>ashl</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>Assignment-with-shift-left operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the left by the number of places specified in the 
 second operand, which should be an integer between 0 and 31.</p>
 <p>A zero is used for the new first bit, and the value of the 32nd bit is lost. 
 Shifting a value left by one position is equivalent to multiplying by 2, shifting 
 two positions is equivalent to multiplying by 4, etc.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with values that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the values to 
 32-bit integers by dropping any fractional part of the value or any bits beyond 
 the 32nd. The shift operation requires a (right-side) operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted primitive instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>d <<= n & 0x3f</pre>
 where <tt>d</tt> is the integer value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ashr(int)"><!-- --></A><H3>
ashr</H3>
<PRE>
public java.lang.Number <B>ashr</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>Assignment-with-shift-right operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31). Bits that are shifted off the right 
 are lost. The bits filled in on the left depend on the sign bit of the original 
 value, in order to preserve the sign of the result. If the current primitive 
 instance is positive, the result has zeros placed in the high bits; if the current 
 primitive instance is negative, the result has ones placed in the high bits.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with values that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the values to 
 32-bit integers by dropping any fractional part of the value or any bits beyond 
 the 32nd. The shift operation requires a (right-side) operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted primitive instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>d >>= n & 0x3f</pre>
 where <tt>d</tt> is the integer value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ashru(int)"><!-- --></A><H3>
ashru</H3>
<PRE>
public java.lang.Number <B>ashru</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>Assignment-with-shift-right-unsigned operation, resembling that of JavaScript, moves all bits in 
 the current date instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31). Bits that are shifted off the right 
 are lost. The result has zeros placed in the high bits.</p>
 <p>This operation is just like <A HREF="../../js/core/JsDate.html#shr(int)"><CODE>shr(int)</CODE></A>, except that the bits shifted 
 in on the left are always zero, regardless of the sign of the current date instance.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with values that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the values to 
 32-bit integers by dropping any fractional part of the value or any bits beyond 
 the 32nd. The shift operation requires a (right-side) operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted primitive instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>d >>>= n & 0x3f</pre>
 where <tt>d</tt> is the integer value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="aand(java.lang.Object)"><!-- --></A><H3>
aand</H3>
<PRE>
public java.lang.Number <B>aand</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Assignment-with-bitwise-AND operation, resembling that of JavaScript, performs a boolean AND 
 operation on each bit of the integer arguments. A bit is set in the result only if 
 the corresponding bit is set in both operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>d &= (char)value</pre>
 where <tt>d</tt> is the integer value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="aor(java.lang.Object)"><!-- --></A><H3>
aor</H3>
<PRE>
public java.lang.Number <B>aor</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Assignment-with-bitwise-OR operation, resembling that of JavaScript, performs a boolean OR operation 
 on each bit of the integer arguments. A bit is set in the result if the corresponding 
 bit is set in one or both of the operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>d |= (char)value</pre>
 where <tt>d</tt> is the integer value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="axor(java.lang.Object)"><!-- --></A><H3>
axor</H3>
<PRE>
public java.lang.Number <B>axor</B>(java.lang.Object&nbsp;value)</PRE>
<DL>
<DD><p>Assignment-with-bitwise-XOR operation, resembling that of JavaScript, performs a boolean exclusive 
 OR operation on each bit of the integer arguments. Exclusive OR means that either 
 operand one is <tt>true</tt> or operand two is <tt>true</tt>, but not both. A bit is 
 set in this operation's result if a corresponding bit is set in one (but not both) 
 of the two operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-exclusive-OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this 
 method with the equivalent JavaScript expression as re-compiled from the Java expression:  
 <pre>d ^= (char)value</pre>
 where <tt>d</tt> is the integer value of the current date instance of the 
 invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be()"><!-- --></A><H3>
be</H3>
<PRE>
public final boolean <B>be</B>()</PRE>
<DL>
<DD><p>Logically evaluates the current date instance.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The logical value of the current date instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the instance invocation of this method, that is, 
 replacing it with its current date instance.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="neg()"><!-- --></A><H3>
neg</H3>
<PRE>
public final java.lang.Number <B>neg</B>()</PRE>
<DL>
<DD><p>Performs unary negation, resembling the unary minus operator in JavaScript.</p>
 <p>This operation converts a positive value to an equivalently negative value, and 
 vice versa. If the operand is not a number, it attempts to convert it to one.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The negation of the current date instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>-d</pre>
 where <tt>d</tt> is the current date instance of the invocation of this 
 method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="not()"><!-- --></A><H3>
not</H3>
<PRE>
public final boolean <B>not</B>()</PRE>
<DL>
<DD><p>Inverts the boolean value of the current date instance, resembling the logical 
 NOT operator in JavaScript.</p>
 <p>This operation converts the current date instance to a boolean value using 
 the following rules if necessary before inverting the converted value.</p>
 <ul>
 <li>If a number is used where a boolean value is expected, the number is converted 
 to <tt>true</tt> unless the number is 0 or NaN, which are converted to <tt>false</tt>.</li>
 <li>If a string is used where a boolean value is expected, it is converted to <tt>true</tt> 
 except for the empty string, which is converted to <tt>false</tt>.</li>
 <li><tt>null</tt> and the undefined value convert to <tt>false</tt>, and any 
 non-null object, array, or function converts to <tt>true</tt>.
 </ul>
 <p>You can convert any value <tt>x</tt> to its equivalent boolean value by applying 
 this operation twice: <tt>Js.not(Js.not(x))</tt></p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical NOT operator of the 
 Java language like this:
 <pre>!Js.be(var)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The inverted boolean value.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>!d</pre>
 where <tt>d</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="bnot()"><!-- --></A><H3>
bnot</H3>
<PRE>
public final int <B>bnot</B>()</PRE>
<DL>
<DD><p>Bitwise-NOT operation, resembling that of JavaScript, operates by reversing all 
 bits in the current date instance.</p>
 <p>Because of the way signed integers are represented in JavaScript, applying this 
 operation to a value is equivalent to changing its sign and subtracting 1.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 values using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with the current date instance that are 
 not integers or are too large to fit in a 32-bit integer representation, it simply 
 coerces them to 32-bit integers by dropping any fractional part of the value or any 
 bits beyond the 32nd.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The bitwise-NOT of the current date instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>~d</pre>
 where <tt>d</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="mul(java.lang.Object)"><!-- --></A><H3>
mul</H3>
<PRE>
public final java.lang.Number <B>mul</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Multiplies the value of the current date instance with the operand, resembling 
 the multiplication operator in JavaScript.</p>
 <p>If used with non-numeric values, this operation attempts to convert them to 
 numbers.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The product of the current date instance and the operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d * other</pre>
 where <tt>d</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="div(java.lang.Object)"><!-- --></A><H3>
div</H3>
<PRE>
public final java.lang.Number <B>div</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Divides the value of the current date instance by the operand, resembling the 
 division operator in JavaScript.</p>
 <p>Used with non-numeric values, this operation attempts to convert them to 
 numbers. If you are used to programming languages that distinguish between integer 
 and floating-point numbers, you might expect to get an integer result when you 
 divide one integer by another. In JavaScript, however, all numbers are floating-point, 
 so all division operations have floating-point results. Division by zero yields positive 
 or negative infinity, while <tt>0/0</tt> evaluates to <tt>NaN</tt>.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The quotient of the current date instance and the operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d / other</pre>
 where <tt>d</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="mod(java.lang.Object)"><!-- --></A><H3>
mod</H3>
<PRE>
public final java.lang.Number <B>mod</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Computes the value of the current date instance modulo the operand, resembling 
 the modulo operator in JavaScript.</p>
 <p>The operation returns the remainder when the current date instance is divided 
 by the operand a certain number of times. If used with non-numeric values, the 
 operation attempts to convert them to numbers. The sign of the result is the same 
 as the sign of the current date instance.</p>
 <p>This operation is typically used with integer values, it also works for 
 floating-point values.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The remainder.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d % other</pre>
 where <tt>d</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="sub(java.lang.Object)"><!-- --></A><H3>
sub</H3>
<PRE>
public final java.lang.Number <B>sub</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Subtracts the operand from the value of the current date instance, resembling 
 the subtraction operator in JavaScript.</p>
 <p>If used with non-numeric values, this operation attempts to convert them to 
 numbers.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The difference between the current date instance and the operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d - other</pre>
 where <tt>d</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Object)"><!-- --></A><H3>
add</H3>
<PRE>
public java.lang.Object <B>add</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Adds the current date instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</p>
 <p>If one value is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../../js/Js.html#valueOf(java.lang.Object)"><CODE>Js.valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../../js/Js.html#toString(java.lang.Object)"><CODE>Js.toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d + other</pre>
 where <tt>d</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.String)"><!-- --></A><H3>
add</H3>
<PRE>
public final java.lang.String <B>add</B>(java.lang.String&nbsp;other)</PRE>
<DL>
<DD><p>Adds the current date instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</p>
 <p>If one value is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../../js/Js.html#valueOf(java.lang.Object)"><CODE>Js.valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../../js/Js.html#toString(java.lang.Object)"><CODE>Js.toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d + other</pre>
 where <tt>d</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(js.Value)"><!-- --></A><H3>
add</H3>
<PRE>
public final java.lang.String <B>add</B>(<A HREF="../../js/Value.html" title="class in js">Value</A>&lt;java.lang.String&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Adds the current date instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</p>
 <p>If one value is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../../js/Js.html#valueOf(java.lang.Object)"><CODE>Js.valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../../js/Js.html#toString(java.lang.Object)"><CODE>Js.toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d + other</pre>
 where <tt>d</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lt(java.lang.Object)"><!-- --></A><H3>
lt</H3>
<PRE>
public final boolean <B>lt</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Less-than operation, resembling that of JavaScript, evaluates to <tt>true</tt> if 
 the current date instance is less than the second operand; otherwise it 
 evaluates to <tt>false</tt>.</p>
 <p>The operands of this operation may be of any type. Comparison can be performed 
 only on numbers and strings, however, so operands that are not numbers or strings 
 are converted. Comparison and conversion occur as follows:</p>
 <ul>
 <li>If both operands are numbers, or if both convert to numbers, they are compared 
 numerically.</li>
 <li>If both operands are strings or convert to strings, they are compared as 
 strings.</li>
 <li>If one operand is or converts to a string, and one is or converts to a number, 
 the operation attempts to convert the string to a number and performs a numerical 
 comparison. If the string does not represent a number, it converts to <tt>NaN</tt>, 
 and the comparison is <tt>false</tt>. In JavaScript 1.1, the string-to-number 
 conversion causes an error instead of yielding <tt>NaN</tt>.</li>
 <li>If an object can be converted to either a number or a string, JavaScript performs 
 the numerical conversion. This means, for example, that Date objects are compared 
 numerically, and it is meaningful to compare two dates to see whether one is earlier 
 than the other.</li>
 <li>If the operands of the comparison operations cannot both be successfully converted 
 to numbers or to strings, these operations always return <tt>false</tt>.</li>
 <li>If either operand is or converts to <tt>NaN</tt>, the comparison operation always 
 yields <tt>false</tt>.</li>
 </ul>
 <p>Keep in mind that string comparison is done on a strict character-by-character 
 basis using the numerical value of each character from the Unicode encoding. Although 
 in some cases the Unicode standard allows equivalent strings to be encoded using 
 different sequences of characters, the JavaScript comparison operations do not 
 detect these encoding differences; they assume that all strings are expressed in 
 normalized form. Note in particular that string comparison is case-sensitive, and 
 in the Unicode encoding (at least for the ASCII subset), all capital letters are 
 "less than" all lowercase letters. This rule can cause confusing results if you do 
 not expect it.</p>
 <p>For a more robust string-comparison algorithm, see the <A HREF="../../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> 
 method, which also takes locale-specific definitions of alphabetical order into account. 
 For case-insensitive comparisons, you must first convert the strings to all lowercase or 
 all uppercase using <A HREF="../../js/StringLike.html#toLowerCase()"><CODE>StringLike.toLowerCase()</CODE></A> or <A HREF="../../js/StringLike.html#toUpperCase()"><CODE>StringLike.toUpperCase()</CODE></A>.</p>
 <p>The less-than-or-equal and greater-than-or-equal operations do not rely on the 
 equality or identity operations for determining whether two values are "equal." 
 Instead, the less-than-or-equal operator is simply defined as "not greater than", 
 and the greater-than-or-equal operator is defined as "not less than". The one 
 exception occurs when either operand is (or converts to) <tt>NaN</tt>, in which case 
 all comparison operations return <tt>false</tt>.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the current date instance is less than the second 
 operand; otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>d < other</pre>
 where <tt>d</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="gt(java.lang.Object)"><!-- --></A><H3>
gt</H3>
<PRE>
public final boolean <B>gt</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Greater-than operation, resembling that of JavaScript, evaluates to <tt>true</tt> if 
 the current date instance is greater than the second operand; otherwise it 
 evaluates to <tt>false</tt>.</p>
 <p>The operands of this operation may be of any type. Comparison can be performed 
 only on numbers and strings, however, so operands that are not numbers or strings 
 are converted. Comparison and conversion occur as follows:</p>
 <ul>
 <li>If both operands are numbers, or if both convert to numbers, they are compared 
 numerically.</li>
 <li>If both operands are strings or convert to strings, they are compared as 
 strings.</li>
 <li>If one operand is or converts to a string, and one is or converts to a number, 
 the operation attempts to convert the string to a number and performs a numerical 
 comparison. If the string does not represent a number, it converts to <tt>NaN</tt>, 
 and the comparison is <tt>false</tt>. In JavaScript 1.1, the string-to-number 
 conversion causes an error instead of yielding <tt>NaN</tt>.</li>
 <li>If an object can be converted to either a number or a string, JavaScript performs 
 the numerical conversion. This means, for example, that Date objects are compared 
 numerically, and it is meaningful to compare two dates to see whether one is earlier 
 than the other.</li>
 <li>If the operands of the comparison operations cannot both be successfully converted 
 to numbers or to strings, these operations always return <tt>false</tt>.</li>
 <li>If either operand is or converts to <tt>NaN</tt>, the comparison operation always 
 yields <tt>false</tt>.</li>
 </ul>
 <p>Keep in mind that string comparison is done on a strict character-by-character 
 basis using the numerical value of each character from the Unicode encoding. Although 
 in some cases the Unicode standard allows equivalent strings to be encoded using 
 different sequences of characters, the JavaScript comparison operations do not 
 detect these encoding differences; they assume that all strings are expressed in 
 normalized form. Note in particular that string comparison is case-sensitive, and 
 in the Unicode encoding (at least for the ASCII subset), all capital letters are 
 "less than" all lowercase letters. This rule can cause confusing results if you do 
 not expect it.</p>
 <p>For a more robust string-comparison algorithm, see the <A HREF="../../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> 
 method, which also takes locale-specific definitions of alphabetical order into account. 
 For case-insensitive comparisons, you must first convert the strings to all lowercase or 
 all uppercase using <A HREF="../../js/StringLike.html#toLowerCase()"><CODE>StringLike.toLowerCase()</CODE></A> or <A HREF="../../js/StringLike.html#toUpperCase()"><CODE>StringLike.toUpperCase()</CODE></A>.</p>
 <p>The less-than-or-equal and greater-than-or-equal operations do not rely on the 
 equality or identity operations for determining whether two values are "equal." 
 Instead, the less-than-or-equal operator is simply defined as "not greater than", 
 and the greater-than-or-equal operator is defined as "not less than". The one 
 exception occurs when either operand is (or converts to) <tt>NaN</tt>, in which case 
 all comparison operations return <tt>false</tt>.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the current date instance is greater than the second 
 operand; otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p > other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lte(java.lang.Object)"><!-- --></A><H3>
lte</H3>
<PRE>
public final boolean <B>lte</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Less-than-or-equal operation, resembling that of JavaScript, evaluates to 
 <tt>true</tt> if the current date instance is less than or equal to the second 
 operand; otherwise it evaluates to <tt>false</tt>.</p>
 <p>The operands of this operation may be of any type. Comparison can be performed 
 only on numbers and strings, however, so operands that are not numbers or strings 
 are converted. Comparison and conversion occur as follows:</p>
 <ul>
 <li>If both operands are numbers, or if both convert to numbers, they are compared 
 numerically.</li>
 <li>If both operands are strings or convert to strings, they are compared as 
 strings.</li>
 <li>If one operand is or converts to a string, and one is or converts to a number, 
 the operation attempts to convert the string to a number and performs a numerical 
 comparison. If the string does not represent a number, it converts to <tt>NaN</tt>, 
 and the comparison is <tt>false</tt>. In JavaScript 1.1, the string-to-number 
 conversion causes an error instead of yielding <tt>NaN</tt>.</li>
 <li>If an object can be converted to either a number or a string, JavaScript performs 
 the numerical conversion. This means, for example, that Date objects are compared 
 numerically, and it is meaningful to compare two dates to see whether one is earlier 
 than the other.</li>
 <li>If the operands of the comparison operations cannot both be successfully converted 
 to numbers or to strings, these operations always return <tt>false</tt>.</li>
 <li>If either operand is or converts to <tt>NaN</tt>, the comparison operation always 
 yields <tt>false</tt>.</li>
 </ul>
 <p>Keep in mind that string comparison is done on a strict character-by-character 
 basis using the numerical value of each character from the Unicode encoding. Although 
 in some cases the Unicode standard allows equivalent strings to be encoded using 
 different sequences of characters, the JavaScript comparison operations do not 
 detect these encoding differences; they assume that all strings are expressed in 
 normalized form. Note in particular that string comparison is case-sensitive, and 
 in the Unicode encoding (at least for the ASCII subset), all capital letters are 
 "less than" all lowercase letters. This rule can cause confusing results if you do 
 not expect it.</p>
 <p>For a more robust string-comparison algorithm, see the <A HREF="../../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> 
 method, which also takes locale-specific definitions of alphabetical order into account. 
 For case-insensitive comparisons, you must first convert the strings to all lowercase or 
 all uppercase using <A HREF="../../js/StringLike.html#toLowerCase()"><CODE>StringLike.toLowerCase()</CODE></A> or <A HREF="../../js/StringLike.html#toUpperCase()"><CODE>StringLike.toUpperCase()</CODE></A>.</p>
 <p>The less-than-or-equal and greater-than-or-equal operations do not rely on the 
 equality or identity operations for determining whether two values are "equal." 
 Instead, the less-than-or-equal operator is simply defined as "not greater than", 
 and the greater-than-or-equal operator is defined as "not less than". The one 
 exception occurs when either operand is (or converts to) <tt>NaN</tt>, in which case 
 all comparison operations return <tt>false</tt>.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the current date instance is less than or equal to 
 the second operand; otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p <= other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="gte(java.lang.Object)"><!-- --></A><H3>
gte</H3>
<PRE>
public final boolean <B>gte</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Greater-than-or-equal operation, resembling that of JavaScript, evaluates to 
 <tt>true</tt> if the current date instance is greater than or equal to the 
 second operand; otherwise it evaluates to <tt>false</tt>.</p>
 <p>The operands of this operation may be of any type. Comparison can be performed 
 only on numbers and strings, however, so operands that are not numbers or strings 
 are converted. Comparison and conversion occur as follows:</p>
 <ul>
 <li>If both operands are numbers, or if both convert to numbers, they are compared 
 numerically.</li>
 <li>If both operands are strings or convert to strings, they are compared as 
 strings.</li>
 <li>If one operand is or converts to a string, and one is or converts to a number, 
 the operation attempts to convert the string to a number and performs a numerical 
 comparison. If the string does not represent a number, it converts to <tt>NaN</tt>, 
 and the comparison is <tt>false</tt>. In JavaScript 1.1, the string-to-number 
 conversion causes an error instead of yielding <tt>NaN</tt>.</li>
 <li>If an object can be converted to either a number or a string, JavaScript performs 
 the numerical conversion. This means, for example, that Date objects are compared 
 numerically, and it is meaningful to compare two dates to see whether one is earlier 
 than the other.</li>
 <li>If the operands of the comparison operations cannot both be successfully converted 
 to numbers or to strings, these operations always return <tt>false</tt>.</li>
 <li>If either operand is or converts to <tt>NaN</tt>, the comparison operation always 
 yields <tt>false</tt>.</li>
 </ul>
 <p>Keep in mind that string comparison is done on a strict character-by-character 
 basis using the numerical value of each character from the Unicode encoding. Although 
 in some cases the Unicode standard allows equivalent strings to be encoded using 
 different sequences of characters, the JavaScript comparison operations do not 
 detect these encoding differences; they assume that all strings are expressed in 
 normalized form. Note in particular that string comparison is case-sensitive, and 
 in the Unicode encoding (at least for the ASCII subset), all capital letters are 
 "less than" all lowercase letters. This rule can cause confusing results if you do 
 not expect it.</p>
 <p>For a more robust string-comparison algorithm, see the <A HREF="../../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> 
 method, which also takes locale-specific definitions of alphabetical order into account. 
 For case-insensitive comparisons, you must first convert the strings to all lowercase or 
 all uppercase using <A HREF="../../js/StringLike.html#toLowerCase()"><CODE>StringLike.toLowerCase()</CODE></A> or <A HREF="../../js/StringLike.html#toUpperCase()"><CODE>StringLike.toUpperCase()</CODE></A>.</p>
 <p>The less-than-or-equal and greater-than-or-equal operations do not rely on the 
 equality or identity operations for determining whether two values are "equal." 
 Instead, the less-than-or-equal operator is simply defined as "not greater than", 
 and the greater-than-or-equal operator is defined as "not less than". The one 
 exception occurs when either operand is (or converts to) <tt>NaN</tt>, in which case 
 all comparison operations return <tt>false</tt>.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the current date instance is greater than or equal to 
 the second operand; otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p >= other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="instanceOf(java.lang.Object)"><!-- --></A><H3>
instanceOf</H3>
<PRE>
public final boolean <B>instanceOf</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks if the current date instance is an instance of the second operand, 
 resembling the <tt>instanceof</tt> operator in JavaScript.</p>
 <p>This operation expects the first operand be an object and the second be a class 
 of objects. In JavaScript, classes of objects are defined by the constructor function 
 that initializes them.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A constructor function.
<DT><B>Returns:</B><DD><tt>true</tt> if the current date instance is an instance of the second 
 operand; <tt>false</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p instanceof other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="eq(java.lang.Object)"><!-- --></A><H3>
eq</H3>
<PRE>
public final boolean <B>eq</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are equal according to the 
 equality operation:
 <ul>
 <li>If the two values have the same type, test them for identity. If the values are 
 identical, they are equal; if they are not identical, they are not equal.</li>
 <li>If the two values do not have the same type, they may still be equal. Use the 
 following rules and type conversions to check for equality:</li>
 <ul>
 <li>If one value is null and the other is undefined, they are equal.</li>
 <li>If one value is a number and the other is a string, convert the string to a 
 number and try the comparison again, using the converted value.</li>
 <li>If either value is <tt>true</tt>, convert it to 1 and try the comparison 
 again. If either value is <tt>false</tt>, convert it to 0 and try the comparison 
 again.</li>
 <li>If one value is an object and the other is a number or string, convert the 
 object to a primitive and try the comparison again. An object is converted to a 
 primitive value by either its <tt>toString()</tt> method or its <tt>valueOf()</tt> 
 method. The built-in classes of core JavaScript attempt <tt>valueOf()</tt> 
 conversion before <tt>toString()</tt> conversion, except for the Date class, 
 which performs <tt>toString()</tt> conversion. Objects that are not part of core 
 JavaScript may convert themselves to primitive values in an implementation-defined 
 way.</li>
 <li>Any other combinations of values are not equal.</li>
 </ul>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand equals the second; <tt>false</tt>, 
 otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p == other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="eqs(java.lang.Object)"><!-- --></A><H3>
eqs</H3>
<PRE>
public final boolean <B>eqs</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are identical according to the identity operation:
 <ul>
 <li>If the two values have different types, they are not identical.</li>
 <li>If both values are numbers and have the same value, they are identical, unless 
 either or both values are <tt>NaN</tt>, in which case they are not identical. 
 The <tt>NaN</tt> value is never identical to any other value, including itself! 
 To check whether a value is <tt>NaN</tt>, use the global <A HREF="../../js/Js.html#isNaN(java.lang.Object)"><CODE>Js.isNaN(Object)</CODE></A> 
 function.</li>
 <li>If both values are strings and contain exactly the same characters in the same 
 positions, they are identical. If the strings differ in length or content, they are 
 not identical. Note that in some cases, the Unicode standard allows more than one 
 way to encode the same string. For efficiency, however, JavaScript's string 
 comparison compares strictly on a character-by-character basis, and it assumes that 
 all strings have been converted to a "normalized form" before they are compared. 
 See the <A HREF="../../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> for another way to compare strings.</li>
 <li>If both values are the boolean value <tt>true</tt> or both are the boolean 
 value <tt>false</tt>, they are identical.</li>
 <li>If both values refer to the same object, array, or function, they are identical. 
 If they refer to different objects (or arrays or functions) they are not identical, 
 even if both objects have identical properties or both arrays have identical elements.</li>
 <li>If both values are null or both values are undefined, they are identical.</li>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is identical to the second; 
 <tt>false</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p === other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="neq(java.lang.Object)"><!-- --></A><H3>
neq</H3>
<PRE>
public final boolean <B>neq</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are not "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are equal according to the 
 equality operation:
 <ul>
 <li>If the two values have the same type, test them for identity. If the values are 
 identical, they are equal; if they are not identical, they are not equal.</li>
 <li>If the two values do not have the same type, they may still be equal. Use the 
 following rules and type conversions to check for equality:</li>
 <ul>
 <li>If one value is null and the other is undefined, they are equal.</li>
 <li>If one value is a number and the other is a string, convert the string to a 
 number and try the comparison again, using the converted value.</li>
 <li>If either value is <tt>true</tt>, convert it to 1 and try the comparison 
 again. If either value is <tt>false</tt>, convert it to 0 and try the comparison 
 again.</li>
 <li>If one value is an object and the other is a number or string, convert the 
 object to a primitive and try the comparison again. An object is converted to a 
 primitive value by either its <tt>toString()</tt> method or its <tt>valueOf()</tt> 
 method. The built-in classes of core JavaScript attempt <tt>valueOf()</tt> 
 conversion before <tt>toString()</tt> conversion, except for the Date class, 
 which performs <tt>toString()</tt> conversion. Objects that are not part of core 
 JavaScript may convert themselves to primitive values in an implementation-defined 
 way.</li>
 <li>Any other combinations of values are not equal.</li>
 </ul>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>false</tt> if the first operand equals the second; <tt>true</tt>, 
 otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p != other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="neqs(java.lang.Object)"><!-- --></A><H3>
neqs</H3>
<PRE>
public final boolean <B>neqs</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are not "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are identical according to the identity operation:
 <ul>
 <li>If the two values have different types, they are not identical.</li>
 <li>If both values are numbers and have the same value, they are identical, unless 
 either or both values are <tt>NaN</tt>, in which case they are not identical. 
 The <tt>NaN</tt> value is never identical to any other value, including itself! 
 To check whether a value is <tt>NaN</tt>, use the global <A HREF="../../js/Js.html#isNaN(java.lang.Object)"><CODE>Js.isNaN(Object)</CODE></A> 
 function.</li>
 <li>If both values are strings and contain exactly the same characters in the same 
 positions, they are identical. If the strings differ in length or content, they are 
 not identical. Note that in some cases, the Unicode standard allows more than one 
 way to encode the same string. For efficiency, however, JavaScript's string 
 comparison compares strictly on a character-by-character basis, and it assumes that 
 all strings have been converted to a "normalized form" before they are compared. 
 See the <A HREF="../../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> for another way to compare strings.</li>
 <li>If both values are the boolean value <tt>true</tt> or both are the boolean 
 value <tt>false</tt>, they are identical.</li>
 <li>If both values refer to the same object, array, or function, they are identical. 
 If they refer to different objects (or arrays or functions) they are not identical, 
 even if both objects have identical properties or both arrays have identical elements.</li>
 <li>If both values are null or both values are undefined, they are identical.</li>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>false</tt> if the first operand is identical to the second; 
 <tt>true</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p !== other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="band(java.lang.Object)"><!-- --></A><H3>
band</H3>
<PRE>
public final int <B>band</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Bitwise-AND operation, resembling that of JavaScript, performs a boolean AND 
 operation on each bit of the integer arguments. A bit is set in the result only if 
 the corresponding bit is set in both operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p & other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="bor(java.lang.Object)"><!-- --></A><H3>
bor</H3>
<PRE>
public final int <B>bor</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Bitwise-OR operation, resembling that of JavaScript, performs a boolean OR operation 
 on each bit of the integer arguments. A bit is set in the result if the corresponding 
 bit is set in one or both of the operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p | other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="xor(java.lang.Object)"><!-- --></A><H3>
xor</H3>
<PRE>
public final int <B>xor</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Bitwise-XOR operation, resembling that of JavaScript, performs a boolean exclusive 
 OR operation on each bit of the integer arguments. Exclusive OR means that either 
 operand one is <tt>true</tt> or operand two is <tt>true</tt>, but not both. A bit is 
 set in this operation's result if a corresponding bit is set in one (but not both) 
 of the two operands.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with operands that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the operands to 
 32-bit integers by dropping any fractional part of the operand or any bits beyond 
 the 32nd.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A numeric value.
<DT><B>Returns:</B><DD>The bitwise-exclusive-OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p ^ other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="shl(int)"><!-- --></A><H3>
shl</H3>
<PRE>
public final int <B>shl</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>Shift-left operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the left by the number of places specified in the 
 second operand, which should be an integer between 0 and 31.</p>
 <p>A zero is used for the new first bit, and the value of the 32nd bit is lost. 
 Shifting a value left by one position is equivalent to multiplying by 2, shifting 
 two positions is equivalent to multiplying by 4, etc.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with values that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the values to 
 32-bit integers by dropping any fractional part of the value or any bits beyond 
 the 32nd. The shift operation requires a (right-side) operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted integer number.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p << n</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="shr(int)"><!-- --></A><H3>
shr</H3>
<PRE>
public final int <B>shr</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>Shift-right operation, resembling that of JavaScript, moves all bits in the 
 current primitive instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31). Bits that are shifted off the right 
 are lost. The bits filled in on the left depend on the sign bit of the original 
 value, in order to preserve the sign of the result. If the current primitive 
 instance is positive, the result has zeros placed in the high bits; if the current 
 primitive instance is negative, the result has ones placed in the high bits.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with values that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the values to 
 32-bit integers by dropping any fractional part of the value or any bits beyond 
 the 32nd. The shift operation requires a (right-side) operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted integer number.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p >> n</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="shru(int)"><!-- --></A><H3>
shru</H3>
<PRE>
public final int <B>shru</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>Shift-right-unsigned operation, resembling that of JavaScript, moves all bits in 
 the current date instance to the right by the number of places specified in the 
 second operand (an integer between 0 and 31). Bits that are shifted off the right 
 are lost. The result has zeros placed in the high bits.</p>
 <p>This operation is just like <A HREF="../../js/core/JsDate.html#shr(int)"><CODE>shr(int)</CODE></A>, except that the bits shifted 
 in on the left are always zero, regardless of the sign of the current date instance.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Despite the fact that all numbers in JavaScript are floating-point numbers, the bitwise 
 operation requires numeric operands that have integer values. It operate on the integer 
 operands using a 32-bit integer representation instead of the equivalent floating-point 
 representation.</p>
 <p>If this bitwise operation is used with values that are not integers or are too 
 large to fit in a 32-bit integer representation, it simply coerces the values to 
 32-bit integers by dropping any fractional part of the value or any bits beyond 
 the 32nd. The shift operation requires a (right-side) operand between 0 and 31. After 
 converting this operand to a 32-bit integer, it drops any bits beyond the 5th, which 
 yields a number in the appropriate range.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted integer number.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p >>> n</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.Object)"><!-- --></A><H3>
and</H3>
<PRE>
public final java.lang.Object <B>and</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Var)"><!-- --></A><H3>
and</H3>
<PRE>
public final <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A> <B>and</B>(<A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsDate)"><!-- --></A><H3>
and</H3>
<PRE>
public final <A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A> <B>and</B>(<A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.DateLike)"><!-- --></A><H3>
and</H3>
<PRE>
public final <A HREF="../../js/DateLike.html" title="interface in js">DateLike</A> <B>and</B>(<A HREF="../../js/DateLike.html" title="interface in js">DateLike</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.Object)"><!-- --></A><H3>
or</H3>
<PRE>
public final java.lang.Object <B>or</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../../js/core/JsDate.html#and(java.lang.Object)"><CODE>and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Var)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A> <B>or</B>(<A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../../js/core/JsDate.html#and(java.lang.Object)"><CODE>and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsDate)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A> <B>or</B>(<A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../../js/core/JsDate.html#and(java.lang.Object)"><CODE>and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.DateLike)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../../js/DateLike.html" title="interface in js">DateLike</A> <B>or</B>(<A HREF="../../js/DateLike.html" title="interface in js">DateLike</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../../js/core/JsDate.html#and(java.lang.Object)"><CODE>and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
cond</H3>
<PRE>
public final java.lang.Object <B>cond</B>(java.lang.Object&nbsp;test,
                                   java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, java.lang.Number)"><!-- --></A><H3>
cond</H3>
<PRE>
public final java.lang.Number <B>cond</B>(java.lang.Object&nbsp;test,
                                   java.lang.Number&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, java.lang.Character)"><!-- --></A><H3>
cond</H3>
<PRE>
public final java.lang.Number <B>cond</B>(java.lang.Object&nbsp;test,
                                   java.lang.Character&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, js.Value)"><!-- --></A><H3>
cond</H3>
<PRE>
public final java.lang.Number <B>cond</B>(java.lang.Object&nbsp;test,
                                   <A HREF="../../js/Value.html" title="class in js">Value</A>&lt;? extends java.lang.Number&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, js.Var)"><!-- --></A><H3>
cond</H3>
<PRE>
public final <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A> <B>cond</B>(java.lang.Object&nbsp;test,
                           <A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, js.core.JsDate)"><!-- --></A><H3>
cond</H3>
<PRE>
public final <A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A> <B>cond</B>(java.lang.Object&nbsp;test,
                         <A HREF="../../js/core/JsDate.html" title="class in js.core">JsDate</A>&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lneg()"><!-- --></A><H3>
lneg</H3>
<PRE>
public final long <B>lneg</B>()</PRE>
<DL>
<DD><p>Performs unary negation on a 64-bit integer.</p>
 <p>This operation converts a positive value to an equivalently negative value, and 
 vice versa. If the operand is not a 64-bit integer, it attempts to convert it to one.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision. </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The negation of the 64-bit integer.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a negation operation on a long number, 
 such as the byte codes compiled from the following Java expression:  
 <pre>-((Number)p).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lnot()"><!-- --></A><H3>
lnot</H3>
<PRE>
public final long <B>lnot</B>()</PRE>
<DL>
<DD><p>The 64-bit bitwise-NOT operation, casting the operand to a <tt>long</tt> number 
 if it is not 64-bit, operates by reversing all bits in the 64-bit integer.</p>
 <p>Because of the way signed integers are represented in JavaScript, applying this 
 operation to a value is equivalent to changing its sign and subtracting 1.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The bitwise-NOT of the 64-bit integer.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a bitwise-NOT operation on a long number, 
 such as the byte codes compiled from the following Java expression:  
 <pre>~((Number)p).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ladd(java.lang.Object)"><!-- --></A><H3>
ladd</H3>
<PRE>
public final long <B>ladd</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Adds two 64-bit integers, casting the operands to <tt>long</tt> numbers if any 
 one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The sum of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of an addition operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() + ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lsub(java.lang.Object)"><!-- --></A><H3>
lsub</H3>
<PRE>
public final long <B>lsub</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Subtracts the second 64-bit integer from the first 64-bit integer, casting the 
 operands to <tt>long</tt> numbers if any one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The difference between the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a subtraction operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() - ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lmul(java.lang.Object)"><!-- --></A><H3>
lmul</H3>
<PRE>
public final long <B>lmul</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Multiplies the two 64-bit integer, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The product of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a multiplication operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() * ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="ldiv(java.lang.Object)"><!-- --></A><H3>
ldiv</H3>
<PRE>
public final long <B>ldiv</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Divides the first 64-bit integer by the second 64-bit integer, casting the operands 
 to <tt>long</tt> numbers if any one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The quotient of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of an division operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() / ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lmod(java.lang.Object)"><!-- --></A><H3>
lmod</H3>
<PRE>
public final long <B>lmod</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Computes the first operand modulo the second operand, casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</p>
 <p>The operation returns the remainder when the first operand is divided by the 
 second operand a certain number of times. The sign of the result is the same as the 
 sign of the first operand.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The remainder.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a modulo operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() % ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lshl(int)"><!-- --></A><H3>
lshl</H3>
<PRE>
public final long <B>lshl</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>The 64-bit shift-left operation, casting the first operand to a <tt>long</tt> 
 number if it is not 64-bit, moves all bits in it to the left by the number of places 
 specified in the second operand, which should be an integer between 0 and 63.</p>
 <p>A zero is used for the new first bit, and the value of the 64th bit is lost. 
 Shifting a value left by one position is equivalent to multiplying by 2, shifting 
 two positions is equivalent to multiplying by 4, etc.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted 64-bit integer.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a shift-left operation on a long number, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() << n</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lshr(int)"><!-- --></A><H3>
lshr</H3>
<PRE>
public final long <B>lshr</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>The 64-bit shift-right operation, casting the first operand to a <tt>long</tt> 
 number if it is not 64-bit, moves all bits in it to the right by the number of 
 places specified in the second operand (an integer between 0 and 63). Bits that are 
 shifted off the right are lost. The bits filled in on the left depend on the sign 
 bit of the original operand, in order to preserve the sign of the result. If the 
 first operand is positive, the result has zeros placed in the high bits; if the 
 first operand is negative, the result has ones placed in the high bits.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted 64-bit integer.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a shift-right operation on a long number, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() >> n</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lshru(int)"><!-- --></A><H3>
lshru</H3>
<PRE>
public final long <B>lshru</B>(int&nbsp;n)</PRE>
<DL>
<DD><p>The 64-bit shift-right-unsigned operation, casting the first operand to a 
 <tt>long</tt> number if it is not 64-bit, moves all bits in it to the right by the 
 number of places specified in the second operand (an integer between 0 and 63). Bits 
 that are shifted off the right are lost. The result has zeros placed in the high 
 bits.</p>
 <p>This operation is just like <A HREF="../../js/core/JsDate.html#lshr(int)"><CODE>lshr(int)</CODE></A>, except that the bits shifted 
 in on the left are always zero, regardless of the sign of the first operand.</p>
 <p>Shifting a value right one place is equivalent to dividing by 2 (discarding the 
 remainder), shifting right two places is equivalent to integer division by 4, and 
 so on.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - The number of bits to shift.
<DT><B>Returns:</B><DD>The shifted 64-bit integer.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of an unsigned shift-right operation on a long number, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() >>> n</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="land(java.lang.Object)"><!-- --></A><H3>
land</H3>
<PRE>
public final long <B>land</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit bitwise-AND operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, performs a boolean AND operation on each 
 bit of the 64-bit integers. A bit is set in the result only if the corresponding 
 bit is set in both operands.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The bitwise-AND of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a bitwise AND operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() & ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lor(java.lang.Object)"><!-- --></A><H3>
lor</H3>
<PRE>
public final long <B>lor</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit bitwise-OR operation, casting the operands to <tt>long</tt> numbers if 
 any one of them is not a 64-bit integer, performs a boolean OR operation on each bit 
 of the 64-bit integers. A bit is set in the result if the corresponding bit is set 
 in one or both of the operands.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The bitwise-OR of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a bitwise OR operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() | ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lxor(java.lang.Object)"><!-- --></A><H3>
lxor</H3>
<PRE>
public final long <B>lxor</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit bitwise-XOR operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, performs a boolean exclusive OR operation 
 on each bit of the 64-bit integers. Exclusive OR means that either operand one is 
 <tt>true</tt> or operand two is <tt>true</tt>, but not both. A bit is set in this 
 operation's result if a corresponding bit is set in one (but not both) of the two 
 operands.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD>The bitwise-exclusive-OR of the two 64-bit integers.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a bitwise exclusive OR operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() ^ ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="llt(java.lang.Object)"><!-- --></A><H3>
llt</H3>
<PRE>
public final boolean <B>llt</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit less-than operation, casting the operands to <tt>long</tt> numbers if 
 any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the first 
 operand is less than the second operand; otherwise it evaluates to <tt>false</tt>.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is less than the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a less-than operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() < ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lgt(java.lang.Object)"><!-- --></A><H3>
lgt</H3>
<PRE>
public final boolean <B>lgt</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit greater-than operation, casting the operands to <tt>long</tt> numbers 
 if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the first 
 operand is greater than the second operand; otherwise it evaluates to <tt>false</tt>.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is greater than the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a greater-than operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() > ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="llte(java.lang.Object)"><!-- --></A><H3>
llte</H3>
<PRE>
public final boolean <B>llte</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit less-than-or-equal operation, casting the operands to <tt>long</tt> 
 numbers if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if 
 the first operand is less than or equal to the second operand; otherwise it evaluates 
 to <tt>false</tt>.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is less than or equal to the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a less-than-or-equal operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() <= ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lgte(java.lang.Object)"><!-- --></A><H3>
lgte</H3>
<PRE>
public final boolean <B>lgte</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>The 64-bit greater-than-or-equal operation, casting the operands to <tt>long</tt> 
 numbers if any one of them is not a 64-bit integer, evaluates to <tt>true</tt> if the 
 first operand is greater than or equal to the second operand; otherwise it evaluates 
 to <tt>false</tt>.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is greater than or equal to the second operand; 
 otherwise <tt>false</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of a greater-than-or-equal operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() >= ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="leq(java.lang.Object)"><!-- --></A><H3>
leq</H3>
<PRE>
public final boolean <B>leq</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two 64-bit integers are "equal", casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand equals the second; <tt>false</tt>, 
 otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of an equality operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() == ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lneq(java.lang.Object)"><!-- --></A><H3>
lneq</H3>
<PRE>
public final boolean <B>lneq</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two 64-bit integers are not "equal", casting the operands to 
 <tt>long</tt> numbers if any one of them is not a 64-bit integer.</p>
 <p>Note that, although the representation of <tt>long</tt> numbers in JavaScript and 
 the 64-bit operations on them are re-compiler dependent, the re-compilers are expected 
 to express 64-bit integers as JavaScript objects or arrays, with a bitwise or arithmetc 
 operation on <tt>long</tt> numbers converted to the invocation of a predefined global 
 function that is also re-compiler dependent. The <tt>valueOf()</tt> method of the object 
 or array representing a 64-bit integer must return a number representing the <tt>long</tt> 
 number in JavaScript limited bits range, so that a <tt>long</tt> integer in JavaScript 
 naturally evaluates to a normal number without extra casting codes. That is, casting 
 a normal number to a <tt>long</tt> integer, or creating a <tt>long</tt> integer from 
 bits involve the invocation of a predefined re-compiler dependent function while 
 casting a <tt>long</tt> integer to a normal number is expected to be ignored by re-compilation. 
 In addition, the <tt>toString()</tt> method of that object or array must return a 
 string representation of the <tt>long</tt> number in full 64-bit precision.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any numeric value.
<DT><B>Returns:</B><DD><tt>false</tt> if the first operand equals the second; <tt>true</tt>, 
 otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>A re-compiler is expected to replace the instance invocation of this method 
 with the invocation of a predefined and re-compiler dependent function, with an invocation of which 
 the same re-compiler would replace the byte codes of an inequality operation on two long numbers, 
 such as the byte codes compiled from the following Java expression:  
 <pre>((Number)p).longValue() != ((Number)other).longValue()</pre>
 where <tt>p</tt> is the current date instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JsDate.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
JScripter(JS) Standard 1.0 API & Re-compilation Specification</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../js/core/JsClass.Members.html" title="class in js.core"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../js/core/JsDate.Member.html" title="class in js.core"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?js/core/JsDate.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JsDate.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright &#169; 2008-2011 J.J.Liu (www.jscripter.org). All Rights Reserved.</i>
</BODY>
</HTML>
