<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_25) on Thu Sep 15 00:19:57 CST 2011 -->
<TITLE>
JsString (JScripter(JS) Standard 1.0 API & Re-compilation Specification)
</TITLE>

<META NAME="date" CONTENT="2011-09-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="JsString (JScripter(JS) Standard 1.0 API & Re-compilation Specification)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JsString.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
JScripter(JS) Standard 1.0 API & Re-compilation Specification</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../js/core/JsRegExp.Members.html" title="class in js.core"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../js/core/JsString.Member.html" title="class in js.core"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?js/core/JsString.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JsString.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
js.core</FONT>
<BR>
Class JsString</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../js/Disposable.html" title="class in js">js.Disposable</A>
      <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../js/Var.html" title="class in js">js.Var</A>&lt;<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;
          <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../js/core/JsObject.html" title="class in js.core">js.core.JsObject</A>
              <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../js/core/JsGlobal.String.Prototype.html" title="class in js.core">js.core.JsGlobal.String.Prototype</A>
                  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>js.core.JsString</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../js/ObjectLike.html" title="interface in js">ObjectLike</A>, <A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>JsString</B><DT>extends <A HREF="../../js/core/JsGlobal.String.Prototype.html" title="class in js.core">JsGlobal.String.Prototype</A><DT>implements <A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></DL>
</PRE>

<P>
<p>An <b>opaque</b> class representing JavaScript string objects.</p>
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD><a href="mailto:jianjunliu@126.com">J.J.Liu (Jianjun Liu)</a> at <a href="http://www.jscripter.org" target="_blank">http://www.jscripter.org</a></DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsGlobal.String.html#create()"><CODE>JsGlobal.String.create()</CODE></A>, 
<A HREF="../../js/core/JsGlobal.String.html#create(java.lang.Object)"><CODE>JsGlobal.String.create(Object)</CODE></A>, 
<A HREF="../../js/core/JsGlobal.String.html#create(js.Vars)"><CODE>JsGlobal.String.create(Vars)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html" title="class in jsx.core"><CODE>StringLikes</CODE></A><DT><B>JavaScript:</B></DT>
  <DD><b>Opaque</b> types can be resolved but no class objects for them can be 
 generated into the target codes. Re-compilers must exit with error on the operations of 
 accessing that kind of class objects.
 The <tt>checkcast</tt> operation to the class literal of this interface must be ignored 
 and <tt>instanceof</tt> to it always <tt>true</tt>.</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.Member.html" title="class in js.core">JsString.Member</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An <b>opaque</b> class representing members of its enclosing <b>opaque</b> type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.Members.html" title="class in js.core">JsString.Members</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An <b>internal</b> class containing membership data for its enclosing 
 opaque class.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_js.Var"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class js.<A HREF="../../js/Var.html" title="class in js">Var</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/Var.Generic.html" title="class in js">Var.Generic</A>&lt;<A HREF="../../js/Var.Generic.html" title="type parameter in Var.Generic">T</A>&gt;, <A HREF="../../js/Var.Mid.html" title="class in js">Var.Mid</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../js/core/JsFunction.Member.html" title="class in js.core">JsFunction.Member</A>&lt;<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#constructor">constructor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An <b>opaque</b> static field defining a member that is named by the field name 
 without a qualifying member and to access the property of the name on an object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../js/Value.Integer.Member.html" title="class in js">Value.Integer.Member</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#length">length</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An <b>opaque</b> static field defining a member that is named by the field name 
 without a qualifying member and to access the property of the name on an object.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_js.core.JsGlobal.String.Prototype"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class js.core.<A HREF="../../js/core/JsGlobal.String.Prototype.html" title="class in js.core">JsGlobal.String.Prototype</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/core/JsGlobal.String.Prototype.html#charAt">charAt</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#charCodeAt">charCodeAt</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#concat">concat</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#indexOf">indexOf</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#lastIndexOf">lastIndexOf</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#localeCompare">localeCompare</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#match">match</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#replace">replace</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#search">search</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#slice">slice</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#split">split</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#substr">substr</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#substring">substring</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#toLocaleLowerCase">toLocaleLowerCase</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#toLocaleUpperCase">toLocaleUpperCase</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#toLowerCase">toLowerCase</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#toUpperCase">toUpperCase</A>, <A HREF="../../js/core/JsGlobal.String.Prototype.html#valueOf">valueOf</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_js.core.JsObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class js.core.<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/core/JsObject.html#hasOwnProperty">hasOwnProperty</A>, <A HREF="../../js/core/JsObject.html#isPrototypeOf">isPrototypeOf</A>, <A HREF="../../js/core/JsObject.html#propertyIsEnumerable">propertyIsEnumerable</A>, <A HREF="../../js/core/JsObject.html#toLocaleString">toLocaleString</A>, <A HREF="../../js/core/JsObject.html#toSource">toSource</A>, <A HREF="../../js/core/JsObject.html#toString">toString</A>, <A HREF="../../js/core/JsObject.html#var">var</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#JsString(js.core.JsObject)">JsString</A></B>(<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Casts an <b>opaque</b> object to the current <b>opaque</b> type by wrapping it 
 with the wrapping constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#JsString(java.lang.Object)">JsString</A></B>(java.lang.Object&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internally constructs a string object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#JsString(java.lang.String)">JsString</A></B>(java.lang.String&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Casts a string value to the current <b>opaque</b> type by wrapping it with the 
 wrapping constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#JsString(js.Var)">JsString</A></B>(<A HREF="../../js/Var.html" title="class in js">Var</A>&lt;java.lang.String&gt;&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Casts a string value to the current <b>opaque</b> type by wrapping it with the 
 wrapping constructor.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#add(java.lang.Object)">add</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the current string instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#and(js.core.JsString)">and</A></B>(<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#and(java.lang.Object)">and</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#and(java.lang.String)">and</A></B>(java.lang.String&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#and(js.Value)">and</A></B>(<A HREF="../../js/Value.html" title="class in js">Value</A>&lt;java.lang.String&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#and(js.Var)">and</A></B>(<A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#be()">be</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logically evaluates the current string instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#charAt(java.lang.Object)">charAt</A></B>(java.lang.Object&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the character string of length 1 at the specified <tt>index</tt> within 
 the current string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Character</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#charCodeAt(java.lang.Object)">charCodeAt</A></B>(java.lang.Object&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the character encoding at a specific <tt>index</tt> within the current 
 string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#concat(java.lang.Object)">concat</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts the argument to a string (if necessary) and appends them, in order, to 
 the end of the current string and returns the resulting concatenation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#concat(js.Vars)">concat</A></B>(<A HREF="../../js/Vars.html" title="class in js">Vars</A>&lt;?&gt;&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Converts each of the argument values to a string (if necessary) and appends them, 
 in order, to the end of the current string and returns the resulting concatenation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#cond(java.lang.Object, js.core.JsString)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#cond(java.lang.Object, java.lang.Object)">cond</A></B>(java.lang.Object&nbsp;test,
     java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#cond(java.lang.Object, js.Var)">cond</A></B>(java.lang.Object&nbsp;test,
     <A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#eq(java.lang.Object)">eq</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#eqs(java.lang.Object)">eqs</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#eval()">eval</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evaluates the current primitive string instance as JavaScript code and 
 returns the result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#in(java.lang.Object)">in</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current string instance is the name of a property of the second 
 operand, resembling the <tt>in</tt> operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#indexOf(java.lang.Object)">indexOf</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the current string instance from beginning to end to see if it contains 
 an occurrence of the substring <tt>other</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#indexOf(java.lang.Object, java.lang.Object)">indexOf</A></B>(java.lang.Object&nbsp;other,
        java.lang.Object&nbsp;pos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the current string instance from beginning to end to see if it contains 
 an occurrence of the substring <tt>other</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#instanceOf(java.lang.Object)">instanceOf</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current string instance is an instance of the second operand, 
 resembling the <tt>instanceof</tt> operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object)">lastIndexOf</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the current string instance from end to beginning to see if it contains 
 an occurrence of the substring <tt>other</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object, java.lang.Object)">lastIndexOf</A></B>(java.lang.Object&nbsp;other,
            java.lang.Object&nbsp;pos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the current string instance from end to beginning to see if it contains 
 an occurrence of the substring <tt>other</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#length()">length</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the length of the current string, an integer that indicates the number of 
 characters in the current string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#localeCompare(java.lang.Object)">localeCompare</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compares strings taking the collation order of the default locale into account.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsArray.html" title="class in js.core">JsArray</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#match(js.RegExpLike)">match</A></B>(<A HREF="../../js/RegExpLike.html" title="interface in js">RegExpLike</A>&nbsp;regexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Searches the current string for one or more matches of <tt>regexp</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#neq(java.lang.Object)">neq</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are not "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#neqs(java.lang.Object)">neqs</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether the two operands are not "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#not()">not</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inverts the boolean value of the current string instance, resembling the 
 logical NOT operator in JavaScript.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#or(js.core.JsString)">or</A></B>(<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#or(java.lang.Object)">or</A></B>(java.lang.Object&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#or(java.lang.String)">or</A></B>(java.lang.String&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#or(js.Value)">or</A></B>(<A HREF="../../js/Value.html" title="class in js">Value</A>&lt;java.lang.String&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#or(js.Var)">or</A></B>(<A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#replace(js.RegExpLike, js.core.JsFunction)">replace</A></B>(<A HREF="../../js/RegExpLike.html" title="interface in js">RegExpLike</A>&nbsp;regexp,
        <A HREF="../../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;java.lang.String&gt;&nbsp;lambda)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a search-and-replace operation on the current string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#replace(js.RegExpLike, java.lang.String)">replace</A></B>(<A HREF="../../js/RegExpLike.html" title="interface in js">RegExpLike</A>&nbsp;regexp,
        java.lang.String&nbsp;newSubStr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a search-and-replace operation on the current string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#replace(js.RegExpLike, js.StringLike)">replace</A></B>(<A HREF="../../js/RegExpLike.html" title="interface in js">RegExpLike</A>&nbsp;regexp,
        <A HREF="../../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;newSubStr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a search-and-replace operation on the current string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#search(js.RegExpLike)">search</A></B>(<A HREF="../../js/RegExpLike.html" title="interface in js">RegExpLike</A>&nbsp;regexp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Looks for a substring matching <tt>regexp</tt> within the current string 
 and returns the position of the first character of the matching substring, 
 or -1 if no match was found.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#slice(java.lang.Object)">slice</A></B>(java.lang.Object&nbsp;begin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string containing a slice, or substring, of the current string without 
 modify it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#slice(java.lang.Object, java.lang.Object)">slice</A></B>(java.lang.Object&nbsp;begin,
      java.lang.Object&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string containing a slice, or substring, of the current string without 
 modify it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsArray.html" title="class in js.core">JsArray</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#split(java.lang.Object)">split</A></B>(java.lang.Object&nbsp;separator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates and returns an array of substrings of the current string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsArray.html" title="class in js.core">JsArray</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#split(java.lang.Object, java.lang.Object)">split</A></B>(java.lang.Object&nbsp;separator,
      java.lang.Object&nbsp;limit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates and returns an array of as many as <tt>limit</tt> substrings of the 
 current string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#substr(java.lang.Object)">substr</A></B>(java.lang.Object&nbsp;start)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extracts and returns a substring of the current string without modifying it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#substr(java.lang.Object, java.lang.Object)">substr</A></B>(java.lang.Object&nbsp;start,
       java.lang.Object&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extracts and returns a substring of the current string without modifying it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#substring(java.lang.Object)">substring</A></B>(java.lang.Object&nbsp;from)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a substring of the current string consisting of the characters from 
 position <tt>from</tt> to the end of the string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#substring(java.lang.Object, java.lang.Object)">substring</A></B>(java.lang.Object&nbsp;from,
          java.lang.Object&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a substring of the current string consisting of the characters between 
 positions <tt>from</tt> and <tt>to</tt>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#toLocaleLowerCase()">toLocaleLowerCase</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a copy of the current string, converted to lower-case letters in a 
 locale-specific way.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#toLocaleUpperCase()">toLocaleUpperCase</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a copy of the current string, converted to upper-case letters in a 
 locale-specific way.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#toLowerCase()">toLowerCase</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a copy of string, with each upper-case letter converted to its lower-case 
 equivalent, if it has one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#toUpperCase()">toUpperCase</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a copy of string, with each lower-case letter converted to its upper-case 
 equivalent, if it has one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#valueOf()">valueOf</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the primitive value associated with the current instance, if there is one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#var()">var</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simply returns the current string instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;S extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; 
<BR>
S</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../js/core/JsString.html#var(S)">var</A></B>(S&nbsp;var)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assigns the value of another string instance to the string number object.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.core.JsObject"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.core.<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/core/JsObject.html#call(js.core.JsFunction.Member)">call</A>, <A HREF="../../js/core/JsObject.html#call(js.core.JsFunction.Member, java.lang.Object)">call</A>, <A HREF="../../js/core/JsObject.html#call(js.core.JsFunction.Member, js.Vars)">call</A>, <A HREF="../../js/core/JsObject.html#delete()">delete</A>, <A HREF="../../js/core/JsObject.html#delete(js.Id)">delete</A>, <A HREF="../../js/core/JsObject.html#delete(java.lang.String)">delete</A>, <A HREF="../../js/core/JsObject.html#delete(js.Var.Member)">delete</A>, <A HREF="../../js/core/JsObject.html#delete(js.Var.Mid)">delete</A>, <A HREF="../../js/core/JsObject.html#hasOwnProperty(java.lang.Object)">hasOwnProperty</A>, <A HREF="../../js/core/JsObject.html#isPrototypeOf(java.lang.Object)">isPrototypeOf</A>, <A HREF="../../js/core/JsObject.html#propertyIsEnumerable(java.lang.Object)">propertyIsEnumerable</A>, <A HREF="../../js/core/JsObject.html#toLocaleString()">toLocaleString</A>, <A HREF="../../js/core/JsObject.html#toString()">toString</A>, <A HREF="../../js/core/JsObject.html#undefined()">undefined</A>, <A HREF="../../js/core/JsObject.html#var(js.Id)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.Id, T)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsArray.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsBoolean.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsDate.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsFunction.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsNumber.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsObject.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.core.JsString.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(java.lang.String)">var</A>, <A HREF="../../js/core/JsObject.html#var(java.lang.String, T)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.Var.Member)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.Var.Member, T)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.Var.Mid)">var</A>, <A HREF="../../js/core/JsObject.html#var(js.Var.Mid, T)">var</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Var"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../../js/Var.html" title="class in js">Var</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/Var.html#equals(java.lang.Object)">equals</A>, <A HREF="../../js/Var.html#hashCode()">hashCode</A>, <A HREF="../../js/Var.html#typeof()">typeof</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsArray)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsBoolean)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsDate)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsFunction)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsNumber)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsRegExp)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.core.JsString)">var</A>, <A HREF="../../js/Var.html#var(js.core.JsObject, js.Var.Generic)">var</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.Disposable"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class js.<A HREF="../../js/Disposable.html" title="class in js">Disposable</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/Disposable.html#finalize()">finalize</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_js.StringLike"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from interface js.<A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../js/StringLike.html#toString()">toString</A>, <A HREF="../../js/StringLike.html#typeof()">typeof</A>, <A HREF="../../js/StringLike.html#undefined()">undefined</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="constructor"><!-- --></A><H3>
constructor</H3>
<PRE>
public static final <A HREF="../../js/core/JsFunction.Member.html" title="class in js.core">JsFunction.Member</A>&lt;<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A>&gt; <B>constructor</B></PRE>
<DL>
<DD><p>An <b>opaque</b> static field defining a member that is named by the field name 
 without a qualifying member and to access the property of the name on an object.</p>
 <p>The <tt>constructor</tt> property of an object is a reference to the function 
 that was the constructor for that object.</p>
 <p>A common use of the <tt>constructor</tt> property is to determine the type of unknown 
 objects. Given an unknown value, you can use the <A HREF="../../js/Js.html#typeof(java.lang.Object)"><CODE>Js.typeof(Object)</CODE></A> operation 
 to determine whether it is a primitive value or an object. If it is an object, you can 
 use the <tt>constructor</tt> property to determine what type of object it is.</p>
 <p>Note, however, that while this technique works for the objects built into core 
 JavaScript, it is not guaranteed to work with host objects such as the <tt>window</tt> 
 object of client-side JavaScript. The default implementation of the <tt>toString()</tt> 
 method provides another way to determine the type of an unknown object.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must resolve the member of this static field to the 
 identifier of the field name.</DD>
</DL>
</DL>
<HR>

<A NAME="length"><!-- --></A><H3>
length</H3>
<PRE>
public static final <A HREF="../../js/Value.Integer.Member.html" title="class in js">Value.Integer.Member</A> <B>length</B></PRE>
<DL>
<DD><p>An <b>opaque</b> static field defining a member that is named by the field name 
 without a qualifying member and to access the property of the name on an object.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#length()"><CODE>length()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must resolve the member of this static field to the 
 identifier of the field name.</DD>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="JsString(java.lang.Object)"><!-- --></A><H3>
JsString</H3>
<PRE>
protected <B>JsString</B>(java.lang.Object&nbsp;var)</PRE>
<DL>
<DD><p>Internally constructs a string object.</p>
 <p>This constructor is <b>internal</b> and only called inside of <b>opaque</b> or 
 <b>internal</b> classes or class members.</p>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must report error on the invocation to an <b>internal</b> constructor.</DD>
</DL>
</DL>
<HR>

<A NAME="JsString(js.core.JsObject)"><!-- --></A><H3>
JsString</H3>
<PRE>
public <B>JsString</B>(<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&nbsp;var)</PRE>
<DL>
<DD><p>Casts an <b>opaque</b> object to the current <b>opaque</b> type by wrapping it 
 with the wrapping constructor.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The argument of an <b>opaque</b> object.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="JsString(java.lang.String)"><!-- --></A><H3>
JsString</H3>
<PRE>
public <B>JsString</B>(java.lang.String&nbsp;var)</PRE>
<DL>
<DD><p>Casts a string value to the current <b>opaque</b> type by wrapping it with the 
 wrapping constructor.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The argument of a string.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>
<HR>

<A NAME="JsString(js.Var)"><!-- --></A><H3>
JsString</H3>
<PRE>
public <B>JsString</B>(<A HREF="../../js/Var.html" title="class in js">Var</A>&lt;java.lang.String&gt;&nbsp;var)</PRE>
<DL>
<DD><p>Casts a string value to the current <b>opaque</b> type by wrapping it with the 
 wrapping constructor.</p>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The argument of a string.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the construction operation of this constructor, 
 that is, replacing it with its only argument.</DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="var()"><!-- --></A><H3>
var</H3>
<PRE>
public <A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A> <B>var</B>()</PRE>
<DL>
<DD><p>Simply returns the current string instance.</p>
 <p>This method is useful for JS Simulation to implement opaque types.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/ObjectLike.html#var()">var</A></CODE> in interface <CODE><A HREF="../../js/ObjectLike.html" title="interface in js">ObjectLike</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../js/core/JsObject.html#var()">var</A></CODE> in class <CODE><A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The current string instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the instance invocation of this method, that is, 
 replacing it with its current instance.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="var(js.core.JsObject)"><!-- --></A><A NAME="var(S)"><!-- --></A><H3>
var</H3>
<PRE>
public final &lt;S extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt; S <B>var</B>(S&nbsp;var)</PRE>
<DL>
<DD><p>Assigns the value of another string instance to the string number object.</p>
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../js/core/JsObject.html#var(T)">var</A></CODE> in class <CODE><A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>var</CODE> - The argument string instance.
<DT><B>Returns:</B><DD>The new instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the instance invocation of this method into 
 the JavaScript expression: 
 <pre>o = var</pre>
 where <tt>o</tt> is the current instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="length()"><!-- --></A><H3>
length</H3>
<PRE>
public final int <B>length</B>()</PRE>
<DL>
<DD><p>Gets the length of the current string, an integer that indicates the number of 
 characters in the current string. For any string <tt>s</tt>, the index of the 
 last character is <tt>s.length() - 1</tt>. The length property of a string may 
 not be deleted.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#length()">length</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The length of the current string.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../jsx/core/StringLikes.html#length(js.StringLike)"><CODE>StringLikes.length(StringLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method into the 
 JavaScript expression: 
 <pre>s.length</pre>
 where <tt>s</tt> is the current string instance of the invocation.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="charAt(java.lang.Object)"><!-- --></A><H3>
charAt</H3>
<PRE>
public final java.lang.String <B>charAt</B>(java.lang.Object&nbsp;index)</PRE>
<DL>
<DD><p>Returns the character string of length 1 at the specified <tt>index</tt> within 
 the current string. An index ranges from 0 to <tt>length() - 1</tt>. The first 
 character of the sequence is at index 0, the next at index 1, and so on, as for 
 array indexing. If <tt>index</tt> is not between 0 and <tt>length() - 1</tt>, 
 this invocation returns an empty string.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#charAt(java.lang.Object)">charAt</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - The index of the character
<DT><B>Returns:</B><DD>The character string of length 1 at the specified index of the current string<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#charCodeAt(java.lang.Object)"><CODE>charCodeAt(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object)"><CODE>indexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object, java.lang.Object)"><CODE>indexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object)"><CODE>lastIndexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object, java.lang.Object)"><CODE>lastIndexOf(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#charAt(js.StringLike, java.lang.Object)"><CODE>StringLikes.charAt(StringLike, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#charAt(java.lang.String, java.lang.Object)"><CODE>StringLikes.charAt(String, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="charCodeAt(java.lang.Object)"><!-- --></A><H3>
charCodeAt</H3>
<PRE>
public final java.lang.Character <B>charCodeAt</B>(java.lang.Object&nbsp;index)</PRE>
<DL>
<DD><p>Returns the character encoding at a specific <tt>index</tt> within the current 
 string. An index ranges from 0 to <tt>length() - 1</tt>. The first 
 character of the sequence is at index 0, the next at index 1, and so on, as for 
 array indexing. If <tt>index</tt> is not between 0 and <tt>length() - 1</tt>, 
 this invocation returns <tt>NaN</tt>.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#charCodeAt(java.lang.Object)">charCodeAt</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - The index of the character
<DT><B>Returns:</B><DD>The Unicode encoding of the character within the current string. The return 
 value is a 16-bit integer between 0 and 65535.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#charAt(java.lang.Object)"><CODE>charAt(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object)"><CODE>indexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object, java.lang.Object)"><CODE>indexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object)"><CODE>lastIndexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object, java.lang.Object)"><CODE>lastIndexOf(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#charCodeAt(js.StringLike, java.lang.Object)"><CODE>StringLikes.charCodeAt(StringLike, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#charCodeAt(java.lang.String, java.lang.Object)"><CODE>StringLikes.charCodeAt(String, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="concat(java.lang.Object)"><!-- --></A><H3>
concat</H3>
<PRE>
public final java.lang.String <B>concat</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Converts the argument to a string (if necessary) and appends them, in order, to 
 the end of the current string and returns the resulting concatenation.</p>
 <p>Note that the current string itself is not modified.</p>
 <p>This method is an analog to <A HREF="../../js/ArrayLike.html#concat(java.lang.Object)"><CODE>ArrayLike.concat(Object)</CODE></A>. Note that it is 
 often easier to use <A HREF="../../js/Js.html#add(java.lang.Object, java.lang.Object)"><CODE>Js.add(Object, Object)</CODE></A> perform string concatenation.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#concat(java.lang.Object)">concat</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value to be concatenated to the current string
<DT><B>Returns:</B><DD>A new string that results from concatenating the argument to the current 
 string.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#concat(js.Vars)"><CODE>concat(Vars)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#concat(java.lang.Object)"><CODE>ArrayLike.concat(Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#concat(js.Vars)"><CODE>ArrayLike.concat(Vars)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#concat(js.StringLike, java.lang.Object)"><CODE>StringLikes.concat(StringLike, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#concat(java.lang.String, java.lang.Object)"><CODE>StringLikes.concat(String, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="concat(js.Vars)"><!-- --></A><H3>
concat</H3>
<PRE>
public final java.lang.String <B>concat</B>(<A HREF="../../js/Vars.html" title="class in js">Vars</A>&lt;?&gt;&nbsp;args)</PRE>
<DL>
<DD><p>Converts each of the argument values to a string (if necessary) and appends them, 
 in order, to the end of the current string and returns the resulting concatenation.</p>
 <p>Note that the current string itself is not modified.</p>
 <p>This method is an analog to <A HREF="../../js/ArrayLike.html#concat(js.Vars)"><CODE>ArrayLike.concat(Vars)</CODE></A>. Note that it is 
 often easier to use <A HREF="../../js/Js.html#add(java.lang.Object, java.lang.Object)"><CODE>Js.add(Object, Object)</CODE></A> perform string concatenation.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#concat(js.Vars)">concat</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>args</CODE> - A list of the values to be concatenated to the current string
<DT><B>Returns:</B><DD>A new string that results from concatenating each of the argument values 
 to the current string.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#concat(java.lang.Object)"><CODE>concat(Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#concat(java.lang.Object)"><CODE>ArrayLike.concat(Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#concat(js.Vars)"><CODE>ArrayLike.concat(Vars)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="indexOf(java.lang.Object)"><!-- --></A><H3>
indexOf</H3>
<PRE>
public final java.lang.Integer <B>indexOf</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Searches the current string instance from beginning to end to see if it contains 
 an occurrence of the substring <tt>other</tt>. The search begins at the beginning 
 of the current string. If an occurrence of the substring is found, this invocation 
 returns the position of the first character of the first occurrence of the substring 
 within the current string. Character positions within string are numbered starting with 
 zero. If no occurrence of substring is found within the current string, this invocation 
 returns -1.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#indexOf(java.lang.Object)">indexOf</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - The substring that is to be searched for within the current string
<DT><B>Returns:</B><DD>The position of the first occurrence of <tt>other</tt> within string, if 
 any, or -1 if no such occurrence is found.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#indexOf(java.lang.Object, java.lang.Object)"><CODE>indexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#charAt(java.lang.Object)"><CODE>charAt(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object)"><CODE>lastIndexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object, java.lang.Object)"><CODE>lastIndexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object)"><CODE>substr(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object, java.lang.Object)"><CODE>substr(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object)"><CODE>substring(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object, java.lang.Object)"><CODE>substring(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#indexOf(js.StringLike, java.lang.Object)"><CODE>StringLikes.indexOf(StringLike, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#indexOf(java.lang.String, java.lang.Object)"><CODE>StringLikes.indexOf(String, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="indexOf(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
indexOf</H3>
<PRE>
public final java.lang.Integer <B>indexOf</B>(java.lang.Object&nbsp;other,
                                       java.lang.Object&nbsp;pos)</PRE>
<DL>
<DD><p>Searches the current string instance from beginning to end to see if it contains 
 an occurrence of the substring <tt>other</tt>. The search begins at position 
 <tt>pos</tt> within string, or at the beginning of string if <tt>pos</tt> is  
 undefined. If an occurrence of the substring is found, this invocation returns the 
 position of the first character of the first occurrence of the substring within 
 the current string. Character positions within string are numbered starting with 
 zero. If no occurrence of substring is found within the current string, this invocation 
 returns -1.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#indexOf(java.lang.Object, java.lang.Object)">indexOf</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - The substring that is to be searched for within the current string<DD><CODE>pos</CODE> - An optional integer argument that specifies the position within the 
 current string at which the search is to start. Legal values are 0 (the position of 
 the first character in the string) to <tt>length() - 1</tt> (the position of 
 the last character in the string). If this argument is undefined, the search begins 
 at the first character of the string
<DT><B>Returns:</B><DD>The position of the first occurrence of <tt>other</tt> within string that 
 appears after the <tt>pos</tt> position, if any, or -1 if no such occurrence 
 is found.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#indexOf(java.lang.Object)"><CODE>indexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#charAt(java.lang.Object)"><CODE>charAt(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object)"><CODE>lastIndexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object, java.lang.Object)"><CODE>lastIndexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object)"><CODE>substr(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object, java.lang.Object)"><CODE>substr(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object)"><CODE>substring(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object, java.lang.Object)"><CODE>substring(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#indexOf(js.StringLike, java.lang.Object, java.lang.Object)"><CODE>StringLikes.indexOf(StringLike, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#indexOf(java.lang.String, java.lang.Object, java.lang.Object)"><CODE>StringLikes.indexOf(String, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lastIndexOf(java.lang.Object)"><!-- --></A><H3>
lastIndexOf</H3>
<PRE>
public final java.lang.Integer <B>lastIndexOf</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Searches the current string instance from end to beginning to see if it contains 
 an occurrence of the substring <tt>other</tt>. The search begins at the end 
 of the current string. If an occurrence of the substring is found, this invocation 
 returns the position of the first character of that occurrence. If no occurrence of 
 substring is found within the current string, this invocation returns -1.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#lastIndexOf(java.lang.Object)">lastIndexOf</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - The substring that is to be searched for within the current string
<DT><B>Returns:</B><DD>The position of the last occurrence of <tt>other</tt> within string, if 
 any, or -1 if no such occurrence is found.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object, java.lang.Object)"><CODE>lastIndexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#charAt(java.lang.Object)"><CODE>charAt(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object)"><CODE>indexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object, java.lang.Object)"><CODE>indexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object)"><CODE>substr(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object, java.lang.Object)"><CODE>substr(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object)"><CODE>substring(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object, java.lang.Object)"><CODE>substring(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#lastIndexOf(js.StringLike, java.lang.Object)"><CODE>StringLikes.lastIndexOf(StringLike, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#lastIndexOf(java.lang.String, java.lang.Object)"><CODE>StringLikes.lastIndexOf(String, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="lastIndexOf(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
lastIndexOf</H3>
<PRE>
public final java.lang.Integer <B>lastIndexOf</B>(java.lang.Object&nbsp;other,
                                           java.lang.Object&nbsp;pos)</PRE>
<DL>
<DD><p>Searches the current string instance from end to beginning to see if it contains 
 an occurrence of the substring <tt>other</tt>. The search begins at position 
 <tt>pos</tt> within string, or at the end of string if <tt>pos</tt> is  
 undefined. If an occurrence of the substring is found, this invocation returns the 
 position of the first character that occurrence. Since this method 
 searches from end to beginning of the string, the first occurrence found is the last 
 one in the string that occurs before the <tt>pos</tt> position. If no occurrence 
 of substring is found within the current string, this invocation returns -1.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#lastIndexOf(java.lang.Object, java.lang.Object)">lastIndexOf</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - The substring that is to be searched for within the current string<DD><CODE>pos</CODE> - An optional integer argument that specifies the position within the 
 current string at which the search is to start. Legal values are 0 (the position of 
 the first character in the string) to <tt>length() - 1</tt> (the position of 
 the last character in the string). If this argument is undefined, the search begins 
 at the last character of the string
<DT><B>Returns:</B><DD>The position of the last occurrence of <tt>other</tt> within string that 
 appears before the <tt>pos</tt> position, if any, or -1 if no such occurrence 
 is found.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object)"><CODE>lastIndexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#charAt(java.lang.Object)"><CODE>charAt(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object)"><CODE>indexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object, java.lang.Object)"><CODE>indexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object)"><CODE>substr(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object, java.lang.Object)"><CODE>substr(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object)"><CODE>substring(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object, java.lang.Object)"><CODE>substring(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#lastIndexOf(js.StringLike, java.lang.Object, java.lang.Object)"><CODE>StringLikes.lastIndexOf(StringLike, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#lastIndexOf(java.lang.String, java.lang.Object, java.lang.Object)"><CODE>StringLikes.lastIndexOf(String, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="localeCompare(java.lang.Object)"><!-- --></A><H3>
localeCompare</H3>
<PRE>
public final java.lang.Integer <B>localeCompare</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Compares strings taking the collation order of the default locale into account.</p>
 <p>The ECMAScript standard does not specify how the locale-specific comparison is done; 
 it merely specifies that this function utilize the collation order provided by the 
 underlying operating system.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#localeCompare(java.lang.Object)">localeCompare</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A string to be compared, in a locale-sensitive fashion, with the current string
<DT><B>Returns:</B><DD>An integer number that indicates the result of the comparison. If the current 
 string is "less than" the string <tt>other</tt>, this invocation returns a 
 number less than zero. If the current string is "greater than" <tt>other</tt>, 
 it returns a integer number greater than zero. And if the strings are identical or 
 indistinguishable according to the locale ordering conventions, the method returns 0.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../jsx/core/StringLikes.html#localeCompare(js.StringLike, java.lang.Object)"><CODE>StringLikes.localeCompare(StringLike, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#localeCompare(java.lang.String, java.lang.Object)"><CODE>StringLikes.localeCompare(String, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="match(js.RegExpLike)"><!-- --></A><H3>
match</H3>
<PRE>
public final <A HREF="../../js/core/JsArray.html" title="class in js.core">JsArray</A> <B>match</B>(<A HREF="../../js/RegExpLike.html" title="interface in js">RegExpLike</A>&nbsp;regexp)</PRE>
<DL>
<DD><p>Searches the current string for one or more matches of <tt>regexp</tt>. 
 The behavior of this invocation depends significantly on whether <tt>regexp</tt> 
 has the "g" attribute or not .</p>
 <p>If <tt>regexp</tt> does not have the "g" attribute, this invocation searches 
 string for a single match. If no match is found, it returns <tt>null</tt>. 
 Otherwise, it returns an array containing information about the match that it found. 
 Element 0 of the array contains the matched text. The remaining elements contain 
 the text that matches any parenthesized subexpressions within the regular expression. 
 In addition to these normal array elements, the returned array also has two object 
 properties. The <tt>index</tt> property (see <A HREF="../../js/ArrayLike.html#index()"><CODE>ArrayLike.index()</CODE></A>) of the array  
 specifies the character position within string of the start of the matched text. Also, 
 the <tt>input</tt> property (see <A HREF="../../js/ArrayLike.html#input()"><CODE>ArrayLike.input()</CODE></A>) of the returned array 
 is a reference to string itself.</p>
 <p>If <tt>regexp</tt> has the "g" flag, this invocation does a global search, 
 searching string for all matching substrings. It returns <tt>null</tt> if no 
 match is found, and it returns an array if one or more matches are found. The 
 contents of this returned array are quite different for global matches, however. In 
 this case, the array elements contain each of the matched substrings within string. 
 The returned array does not have <tt>index</tt> (see <A HREF="../../js/ArrayLike.html#index()"><CODE>ArrayLike.index()</CODE></A>) 
 or <tt>input</tt> (see <A HREF="../../js/ArrayLike.html#input()"><CODE>ArrayLike.input()</CODE></A>) properties in this case. Note 
 that for global matches, this invocation does not provide information about 
 parenthesized subexpressions, nor does it specify where within string each match 
 occurred. If you need to obtain this information for a global search, you can use 
 <A HREF="../../js/RegExpLike.html#exec(java.lang.Object)"><CODE>RegExpLike.exec(Object)</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#match(js.RegExpLike)">match</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regexp</CODE> - A RegExp object that specifies the pattern to be matched
<DT><B>Returns:</B><DD>An array containing the results of the match. The contents of the array 
 depend on whether regexp has the global "g" attribute set.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#replace(js.RegExpLike, java.lang.String)"><CODE>replace(RegExpLike, String)</CODE></A>, 
<A HREF="../../js/core/JsString.html#replace(js.RegExpLike, js.StringLike)"><CODE>replace(RegExpLike, StringLike)</CODE></A>, 
<A HREF="../../js/core/JsString.html#replace(js.RegExpLike, js.core.JsFunction)"><CODE>replace(RegExpLike, JsFunction)</CODE></A>, 
<A HREF="../../js/core/JsString.html#search(js.RegExpLike)"><CODE>search(RegExpLike)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#index()"><CODE>ArrayLike.index()</CODE></A>, 
<A HREF="../../js/ArrayLike.html#input()"><CODE>ArrayLike.input()</CODE></A>, 
<A HREF="../../js/Js.html#re(java.lang.String)"><CODE>Js.re(String)</CODE></A>, 
<A HREF="../../js/Js.html#re(java.lang.String, java.lang.String)"><CODE>Js.re(String, String)</CODE></A>, 
<A HREF="../../js/RegExpLike.html#exec(java.lang.Object)"><CODE>RegExpLike.exec(Object)</CODE></A>, 
<A HREF="../../js/RegExpLike.html#test(java.lang.Object)"><CODE>RegExpLike.test(Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#match(js.StringLike, js.RegExpLike)"><CODE>StringLikes.match(StringLike, RegExpLike)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#match(java.lang.String, js.RegExpLike)"><CODE>StringLikes.match(String, RegExpLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="replace(js.RegExpLike, java.lang.String)"><!-- --></A><H3>
replace</H3>
<PRE>
public final java.lang.String <B>replace</B>(<A HREF="../../js/RegExpLike.html" title="interface in js">RegExpLike</A>&nbsp;regexp,
                                      java.lang.String&nbsp;newSubStr)</PRE>
<DL>
<DD><p>Performs a search-and-replace operation on the current string.</p>
 <p>This invocation searches the current string for one or more substrings that 
 match <tt>regexp</tt> and replaces them with the replacement string 
 <tt>newSubStr</tt>.</p>
 <p>If <tt>regexp</tt> has the global "g" attribute specified, this invocation 
 replaces all matching substrings. Otherwise, it replaces only the first matching 
 substring.</p>
 <p>Note that the $ character has special meaning within the replacement string 
 <tt>newSubStr</tt>. As shown in the following, it indicates that a string 
 derived from the pattern match is used in the replacement.</p>
 <ul>
 <li>$1, $2, ..., $99 The text that matched the 1st through 99th parenthesized 
 subexpression within <tt>regexp</tt></li>
 <li>$& The substring that matched <tt>regexp</tt></li>
 <li>$' The text to the left of the matched substring</li>
 <li>$' The text to the right of the matched substring</li>
 <li>$$ A literal dollar sign</li>
 </ul>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#replace(js.RegExpLike, java.lang.String)">replace</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regexp</CODE> - The RegExp object that specifies the pattern to be replaced<DD><CODE>newSubStr</CODE> - A string that specifies the replacement text
<DT><B>Returns:</B><DD>A new string, with the first match, or all matches, of <tt>regexp</tt> 
 replaced with the replacement.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#replace(js.RegExpLike, js.StringLike)"><CODE>replace(RegExpLike, StringLike)</CODE></A>, 
<A HREF="../../js/core/JsString.html#replace(js.RegExpLike, js.core.JsFunction)"><CODE>replace(RegExpLike, JsFunction)</CODE></A>, 
<A HREF="../../js/core/JsString.html#match(js.RegExpLike)"><CODE>match(RegExpLike)</CODE></A>, 
<A HREF="../../js/core/JsString.html#search(js.RegExpLike)"><CODE>search(RegExpLike)</CODE></A>, 
<A HREF="../../js/Js.html#re(java.lang.String)"><CODE>Js.re(String)</CODE></A>, 
<A HREF="../../js/Js.html#re(java.lang.String, java.lang.String)"><CODE>Js.re(String, String)</CODE></A>, 
<A HREF="../../js/RegExpLike.html#exec(java.lang.Object)"><CODE>RegExpLike.exec(Object)</CODE></A>, 
<A HREF="../../js/RegExpLike.html#test(java.lang.Object)"><CODE>RegExpLike.test(Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#replace(js.StringLike, js.RegExpLike, java.lang.String)"><CODE>StringLikes.replace(StringLike, RegExpLike, String)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#replace(java.lang.String, js.RegExpLike, java.lang.String)"><CODE>StringLikes.replace(String, RegExpLike, String)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="replace(js.RegExpLike, js.StringLike)"><!-- --></A><H3>
replace</H3>
<PRE>
public final java.lang.String <B>replace</B>(<A HREF="../../js/RegExpLike.html" title="interface in js">RegExpLike</A>&nbsp;regexp,
                                      <A HREF="../../js/StringLike.html" title="interface in js">StringLike</A>&nbsp;newSubStr)</PRE>
<DL>
<DD><p>Performs a search-and-replace operation on the current string.</p>
 <p>This invocation searches the current string for one or more substrings that 
 match <tt>regexp</tt> and replaces them with the replacement string 
 <tt>newSubStr</tt>.</p>
 <p>If <tt>regexp</tt> has the global "g" attribute specified, this invocation 
 replaces all matching substrings. Otherwise, it replaces only the first matching 
 substring.</p>
 <p>Note that the $ character has special meaning within the replacement string 
 <tt>newSubStr</tt>. As shown in the following, it indicates that a string 
 derived from the pattern match is used in the replacement.</p>
 <ul>
 <li>$1, $2, ..., $99 The text that matched the 1st through 99th parenthesized 
 subexpression within <tt>regexp</tt></li>
 <li>$& The substring that matched <tt>regexp</tt></li>
 <li>$' The text to the left of the matched substring</li>
 <li>$' The text to the right of the matched substring</li>
 <li>$$ A literal dollar sign</li>
 </ul>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#replace(js.RegExpLike, js.StringLike)">replace</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regexp</CODE> - The RegExp object that specifies the pattern to be replaced<DD><CODE>newSubStr</CODE> - A string that specifies the replacement text
<DT><B>Returns:</B><DD>A new string, with the first match, or all matches, of <tt>regexp</tt> 
 replaced with the replacement.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#replace(js.RegExpLike, java.lang.String)"><CODE>replace(RegExpLike, String)</CODE></A>, 
<A HREF="../../js/core/JsString.html#replace(js.RegExpLike, js.core.JsFunction)"><CODE>replace(RegExpLike, JsFunction)</CODE></A>, 
<A HREF="../../js/core/JsString.html#match(js.RegExpLike)"><CODE>match(RegExpLike)</CODE></A>, 
<A HREF="../../js/core/JsString.html#search(js.RegExpLike)"><CODE>search(RegExpLike)</CODE></A>, 
<A HREF="../../js/Js.html#re(java.lang.String)"><CODE>Js.re(String)</CODE></A>, 
<A HREF="../../js/Js.html#re(java.lang.String, java.lang.String)"><CODE>Js.re(String, String)</CODE></A>, 
<A HREF="../../js/RegExpLike.html#exec(java.lang.Object)"><CODE>RegExpLike.exec(Object)</CODE></A>, 
<A HREF="../../js/RegExpLike.html#test(java.lang.Object)"><CODE>RegExpLike.test(Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#replace(js.StringLike, js.RegExpLike, js.StringLike)"><CODE>StringLikes.replace(StringLike, RegExpLike, StringLike)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#replace(java.lang.String, js.RegExpLike, js.StringLike)"><CODE>StringLikes.replace(String, RegExpLike, StringLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="replace(js.RegExpLike, js.core.JsFunction)"><!-- --></A><H3>
replace</H3>
<PRE>
public final java.lang.String <B>replace</B>(<A HREF="../../js/RegExpLike.html" title="interface in js">RegExpLike</A>&nbsp;regexp,
                                      <A HREF="../../js/core/JsFunction.html" title="class in js.core">JsFunction</A>&lt;java.lang.String&gt;&nbsp;lambda)</PRE>
<DL>
<DD><p>Performs a search-and-replace operation on the current string.</p>
 <p>This invocation searches the current string for one or more substrings that 
 match <tt>regexp</tt> and replaces them with the replacement string generated by 
 <tt>lambda</tt>.</p>
 <p>If <tt>regexp</tt> has the global "g" attribute specified, this invocation 
 replaces all matching substrings. Otherwise, it replaces only the first matching 
 substring.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#replace(js.RegExpLike, js.core.JsFunction)">replace</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regexp</CODE> - The RegExp object that specifies the pattern to be replaced<DD><CODE>lambda</CODE> - A function that is invoked to generate the replacement text
<DT><B>Returns:</B><DD>A new string, with the first match, or all matches, of <tt>regexp</tt> 
 replaced with the replacement.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#replace(js.RegExpLike, java.lang.String)"><CODE>replace(RegExpLike, String)</CODE></A>, 
<A HREF="../../js/core/JsString.html#replace(js.RegExpLike, js.StringLike)"><CODE>replace(RegExpLike, StringLike)</CODE></A>, 
<A HREF="../../js/core/JsString.html#match(js.RegExpLike)"><CODE>match(RegExpLike)</CODE></A>, 
<A HREF="../../js/core/JsString.html#search(js.RegExpLike)"><CODE>search(RegExpLike)</CODE></A>, 
<A HREF="../../js/Js.html#re(java.lang.String)"><CODE>Js.re(String)</CODE></A>, 
<A HREF="../../js/Js.html#re(java.lang.String, java.lang.String)"><CODE>Js.re(String, String)</CODE></A>, 
<A HREF="../../js/RegExpLike.html#exec(java.lang.Object)"><CODE>RegExpLike.exec(Object)</CODE></A>, 
<A HREF="../../js/RegExpLike.html#test(java.lang.Object)"><CODE>RegExpLike.test(Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#replace(js.StringLike, js.RegExpLike, js.core.JsFunction)"><CODE>StringLikes.replace(StringLike, RegExpLike, JsFunction)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#replace(java.lang.String, js.RegExpLike, js.core.JsFunction)"><CODE>StringLikes.replace(String, RegExpLike, JsFunction)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="search(js.RegExpLike)"><!-- --></A><H3>
search</H3>
<PRE>
public final java.lang.Integer <B>search</B>(<A HREF="../../js/RegExpLike.html" title="interface in js">RegExpLike</A>&nbsp;regexp)</PRE>
<DL>
<DD><p>Looks for a substring matching <tt>regexp</tt> within the current string 
 and returns the position of the first character of the matching substring, 
 or -1 if no match was found.</p>
 <p>This invocation does not do global matches; it ignores the "g" flag of 
 <tt>regexp</tt>. It also ignores the <tt>lastIndex</tt> property 
 (see <A HREF="../../js/RegExpLike.html#lastIndex()"><CODE>RegExpLike.lastIndex()</CODE></A> and <A HREF="../../js/RegExpLike.html#lastIndex(java.lang.Integer)"><CODE>RegExpLike.lastIndex(Integer)</CODE></A>) of 
 <tt>regexp</tt> and always searches from the beginning of the string, which 
 means that it always returns the position of the first match in the string.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#search(js.RegExpLike)">search</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>regexp</CODE> - A RegExp object that specifies the pattern to be searched for in the current string.
<DT><B>Returns:</B><DD>The position of the start of the first substring of the current string 
 that matches <tt>regexp</tt>, or -1 if no match is found.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#replace(js.RegExpLike, java.lang.String)"><CODE>replace(RegExpLike, String)</CODE></A>, 
<A HREF="../../js/core/JsString.html#replace(js.RegExpLike, js.StringLike)"><CODE>replace(RegExpLike, StringLike)</CODE></A>, 
<A HREF="../../js/core/JsString.html#replace(js.RegExpLike, js.core.JsFunction)"><CODE>replace(RegExpLike, JsFunction)</CODE></A>, 
<A HREF="../../js/core/JsString.html#match(js.RegExpLike)"><CODE>match(RegExpLike)</CODE></A>, 
<A HREF="../../js/Js.html#re(java.lang.String)"><CODE>Js.re(String)</CODE></A>, 
<A HREF="../../js/Js.html#re(java.lang.String, java.lang.String)"><CODE>Js.re(String, String)</CODE></A>, 
<A HREF="../../js/RegExpLike.html#exec(java.lang.Object)"><CODE>RegExpLike.exec(Object)</CODE></A>, 
<A HREF="../../js/RegExpLike.html#test(java.lang.Object)"><CODE>RegExpLike.test(Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#search(js.StringLike, js.RegExpLike)"><CODE>StringLikes.search(StringLike, RegExpLike)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#search(java.lang.String, js.RegExpLike)"><CODE>StringLikes.search(String, RegExpLike)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="slice(java.lang.Object)"><!-- --></A><H3>
slice</H3>
<PRE>
public final java.lang.String <B>slice</B>(java.lang.Object&nbsp;begin)</PRE>
<DL>
<DD><p>Returns a string containing a slice, or substring, of the current string without 
 modify it.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#slice(java.lang.Object)">slice</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>begin</CODE> - The string index where the slice is to begin. If negative, this argument 
 specifies a position measured from the end of the string. That is, -1 indicates the 
 last character, -2 indicates the second from last character, and so on.
<DT><B>Returns:</B><DD>A new string that contains all the characters of string from and including 
 <tt>begin</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#slice(java.lang.Object, java.lang.Object)"><CODE>slice(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object)"><CODE>substr(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object, java.lang.Object)"><CODE>substr(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object)"><CODE>substring(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object, java.lang.Object)"><CODE>substring(Object, Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#slice(java.lang.Object)"><CODE>ArrayLike.slice(Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#slice(java.lang.Object, java.lang.Object)"><CODE>ArrayLike.slice(Object, Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#slice(js.Vars)"><CODE>ArrayLike.slice(Vars)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#slice(js.StringLike, java.lang.Object)"><CODE>StringLikes.slice(StringLike, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#slice(java.lang.String, java.lang.Object)"><CODE>StringLikes.slice(String, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="slice(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
slice</H3>
<PRE>
public final java.lang.String <B>slice</B>(java.lang.Object&nbsp;begin,
                                    java.lang.Object&nbsp;end)</PRE>
<DL>
<DD><p>Returns a string containing a slice, or substring, of the current string without 
 modify it.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#slice(java.lang.Object, java.lang.Object)">slice</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>begin</CODE> - The string index where the slice is to begin. If negative, this argument 
 specifies a position measured from the end of the string. That is, -1 indicates the 
 last character, -2 indicates the second from last character, and so on.<DD><CODE>end</CODE> - The string index immediately after the end of the slice. If undefined, 
 the slice includes all characters from <tt>begin</tt> to the end of the string. 
 If this argument is negative, it specifies a position measured from the end of the 
 string.
<DT><B>Returns:</B><DD>A new string that contains all the characters of string from and including 
 <tt>begin</tt>, and up to but not including <tt>end</tt>.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#slice(java.lang.Object, java.lang.Object)"><CODE>slice(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object)"><CODE>substr(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object, java.lang.Object)"><CODE>substr(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object)"><CODE>substring(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object, java.lang.Object)"><CODE>substring(Object, Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#slice(java.lang.Object)"><CODE>ArrayLike.slice(Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#slice(java.lang.Object, java.lang.Object)"><CODE>ArrayLike.slice(Object, Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#slice(js.Vars)"><CODE>ArrayLike.slice(Vars)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#slice(js.StringLike, java.lang.Object, java.lang.Object)"><CODE>StringLikes.slice(StringLike, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#slice(java.lang.String, java.lang.Object, java.lang.Object)"><CODE>StringLikes.slice(String, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="split(java.lang.Object)"><!-- --></A><H3>
split</H3>
<PRE>
public final <A HREF="../../js/core/JsArray.html" title="class in js.core">JsArray</A> <B>split</B>(java.lang.Object&nbsp;separator)</PRE>
<DL>
<DD><p>Creates and returns an array of substrings of the current string. These 
 substrings are created by searching the string from start to end for text that 
 matches <tt>separator</tt> and breaking the string before and after that 
 matching text. The <tt>separator</tt> text is not included in any of the 
 returned substrings, except as noted at the end of this section. Note that if the 
 <tt>separator</tt> matches the beginning of the string, the first element of 
 the returned array will be an empty string, the text that appears before the 
 <tt>separator</tt>. Similarly, if the <tt>separator</tt> matches the end of 
 the string, the last element of the array will be the empty string.</p>
 <p>If <tt>separator</tt> is undefined, the current string is not split at all, 
 and the returned array contains only a single, unbroken string element. If 
 <tt>separator</tt> is the empty string or a regular expression that matches 
 the empty string, the string is broken between each character, and the returned 
 array has the same length as the string does. Note that this is a special case 
 because the empty strings before the first character and after the last character 
 are not matched.</p>
 <p>As noted earlier, the substrings in the array returned by this invocation do not 
 contain the delimiting text <tt>separator</tt> used to split the string. However, 
 if <tt>separator</tt> is a regular expression that contains parenthesized 
 subexpressions, the substrings that match those parenthesized subexpressions 
 (but not the text that matches the regular expression as a whole) are included in 
 the returned array.</p>
 <p>Note that this method is the inverse of the <A HREF="../../js/ArrayLike.html#join()"><CODE>ArrayLike.join()</CODE></A> or 
 <A HREF="../../js/ArrayLike.html#join(java.lang.Object)"><CODE>ArrayLike.join(Object)</CODE></A> method.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#split(java.lang.Object)">split</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>separator</CODE> - The string or regular expression at which the current string splits.
<DT><B>Returns:</B><DD>An array of strings, created by splitting string into substrings at the 
 boundaries specified by <tt>separator</tt>. The substrings in the returned 
 array do not include <tt>separator</tt> itself, except in the case noted in the 
 above description.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#split(java.lang.Object, java.lang.Object)"><CODE>split(Object, Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#join()"><CODE>ArrayLike.join()</CODE></A>, 
<A HREF="../../js/ArrayLike.html#join(java.lang.Object)"><CODE>ArrayLike.join(Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#split(js.StringLike, java.lang.Object)"><CODE>StringLikes.split(StringLike, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#split(java.lang.String, java.lang.Object)"><CODE>StringLikes.split(String, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="split(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
split</H3>
<PRE>
public final <A HREF="../../js/core/JsArray.html" title="class in js.core">JsArray</A> <B>split</B>(java.lang.Object&nbsp;separator,
                           java.lang.Object&nbsp;limit)</PRE>
<DL>
<DD><p>Creates and returns an array of as many as <tt>limit</tt> substrings of the 
 current string. These substrings are created by searching the string from start to 
 end for text that matches <tt>separator</tt> and breaking the string before and 
 after that matching text. The <tt>separator</tt> text is not included in any of 
 the returned substrings, except as noted at the end of this section. Note that if 
 the <tt>separator</tt> matches the beginning of the string, the first element 
 of the returned array will be an empty string, the text that appears before the 
 <tt>separator</tt>. Similarly, if the <tt>separator</tt> matches the end of 
 the string, the last element of the array (assuming no conflicting <tt>limit</tt>) 
 will be the empty string.</p>
 <p>If <tt>separator</tt> is undefined, the current string is not split at all, 
 and the returned array contains only a single, unbroken string element. If 
 <tt>separator</tt> is the empty string or a regular expression that matches 
 the empty string, the string is broken between each character, and the returned 
 array has the same length as the string does, assuming no smaller <tt>limit</tt> 
 is specified. Note that this is a special case because the empty strings before 
 the first character and after the last character are not matched.</p>
 <p>As noted earlier, the substrings in the array returned by this invocation do not 
 contain the delimiting text <tt>separator</tt> used to split the string. However, 
 if <tt>separator</tt> is a regular expression that contains parenthesized 
 subexpressions, the substrings that match those parenthesized subexpressions 
 (but not the text that matches the regular expression as a whole) are included in 
 the returned array.</p>
 <p>Note that this method is the inverse of the <A HREF="../../js/ArrayLike.html#join()"><CODE>ArrayLike.join()</CODE></A> or 
 <A HREF="../../js/ArrayLike.html#join(java.lang.Object)"><CODE>ArrayLike.join(Object)</CODE></A> method.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#split(java.lang.Object, java.lang.Object)">split</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>separator</CODE> - The string or regular expression at which the current string splits.<DD><CODE>limit</CODE> - This optional integer specifies the maximum length of the returned 
 array. If defined, no more than this number of substrings will be returned. 
 If undefined, the entire string will be split, regardless of its length.
<DT><B>Returns:</B><DD>An array of strings, created by splitting string into substrings at the 
 boundaries specified by <tt>separator</tt>. The substrings in the returned 
 array do not include <tt>separator</tt> itself, except in the case noted in the 
 above description.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#split(java.lang.Object)"><CODE>split(Object)</CODE></A>, 
<A HREF="../../js/ArrayLike.html#join()"><CODE>ArrayLike.join()</CODE></A>, 
<A HREF="../../js/ArrayLike.html#join(java.lang.Object)"><CODE>ArrayLike.join(Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#split(js.StringLike, java.lang.Object, java.lang.Object)"><CODE>StringLikes.split(StringLike, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#split(java.lang.String, java.lang.Object, java.lang.Object)"><CODE>StringLikes.split(String, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="substr(java.lang.Object)"><!-- --></A><H3>
substr</H3>
<PRE>
public final java.lang.String <B>substr</B>(java.lang.Object&nbsp;start)</PRE>
<DL>
<DD><p>Extracts and returns a substring of the current string without modifying it.</p>
 <p>Note that this method has not been standardized by ECMAScript and is therefore 
 deprecated</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#substr(java.lang.Object)">substr</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>start</CODE> - The start position of the substring. If this argument is negative, it 
 specifies a position measured from the end of the string: -1 specifies the last character, 
 -2 specifies the second-to-last character, and so on.
<DT><B>Returns:</B><DD>A copy of the portion of the current string starting at and including the character 
 specified by <tt>start</tt> to the end of the string.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#substr(java.lang.Object)"><CODE>substr(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#slice(java.lang.Object)"><CODE>slice(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#slice(java.lang.Object, java.lang.Object)"><CODE>slice(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object)"><CODE>substring(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object, java.lang.Object)"><CODE>substring(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#substr(js.StringLike, java.lang.Object)"><CODE>StringLikes.substr(StringLike, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#substr(java.lang.String, java.lang.Object)"><CODE>StringLikes.substr(String, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="substr(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
substr</H3>
<PRE>
public final java.lang.String <B>substr</B>(java.lang.Object&nbsp;start,
                                     java.lang.Object&nbsp;length)</PRE>
<DL>
<DD><p>Extracts and returns a substring of the current string without modifying it.</p>
 <p>Note this method specifies the desired substring with a character position and a 
 <tt>length</tt>. This provides a useful alternative to 
 <A HREF="../../js/StringLike.html#substring(java.lang.Object, java.lang.Object)"><CODE>StringLike.substring(Object, Object)</CODE></A>, which specify a substring with two 
 character positions. Note, however, that this method has not been standardized by 
 ECMAScript and is therefore deprecated</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#substr(java.lang.Object, java.lang.Object)">substr</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>start</CODE> - The start position of the substring. If this argument is negative, it 
 specifies a position measured from the end of the string: -1 specifies the last character, 
 -2 specifies the second-to-last character, and so on.<DD><CODE>length</CODE> - The number of characters in the substring. If this argument is undefined, 
 the returned substring includes all characters from the starting position to the end of 
 the string.
<DT><B>Returns:</B><DD>A copy of the portion of the current string starting at and including the character 
 specified by <tt>start</tt> and continuing for <tt>length</tt> characters, 
 or to the end of the string if <tt>length</tt> is undefined.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#substr(java.lang.Object)"><CODE>substr(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#slice(java.lang.Object)"><CODE>slice(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#slice(java.lang.Object, java.lang.Object)"><CODE>slice(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object)"><CODE>substring(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substring(java.lang.Object, java.lang.Object)"><CODE>substring(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#substr(js.StringLike, java.lang.Object, java.lang.Object)"><CODE>StringLikes.substr(StringLike, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#substr(java.lang.String, java.lang.Object, java.lang.Object)"><CODE>StringLikes.substr(String, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="substring(java.lang.Object)"><!-- --></A><H3>
substring</H3>
<PRE>
public final java.lang.String <B>substring</B>(java.lang.Object&nbsp;from)</PRE>
<DL>
<DD><p>Returns a substring of the current string consisting of the characters from 
 position <tt>from</tt> to the end of the string. The character at position 
 <tt>from</tt> is included.</p>
 <p>It is important to remember that the character at position <tt>from</tt> is 
 included in the substring.</p>
 <p>Note that <A HREF="../../js/StringLike.html#slice(java.lang.Object)"><CODE>StringLike.slice(Object)</CODE></A> and the nonstandard 
 <A HREF="../../js/StringLike.html#substr(java.lang.Object)"><CODE>StringLike.substr(Object)</CODE></A> can also extract substrings from a string. 
 Unlike those methods, this method does not accept negative arguments.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#substring(java.lang.Object)">substring</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>from</CODE> - A nonnegative integer that specifies the position within the current 
 string of the first character of the desired substring.
<DT><B>Returns:</B><DD>A substring of the current string containing characters copied from 
 position <tt>from</tt> to the end of the current string.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#substring(java.lang.Object, java.lang.Object)"><CODE>substring(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#charAt(java.lang.Object)"><CODE>charAt(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object)"><CODE>indexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object, java.lang.Object)"><CODE>indexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object)"><CODE>lastIndexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object, java.lang.Object)"><CODE>lastIndexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#slice(java.lang.Object)"><CODE>slice(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#slice(java.lang.Object, java.lang.Object)"><CODE>slice(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object)"><CODE>substr(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object, java.lang.Object)"><CODE>substr(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#substring(js.StringLike, java.lang.Object)"><CODE>StringLikes.substring(StringLike, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#substring(java.lang.String, java.lang.Object)"><CODE>StringLikes.substring(String, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="substring(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
substring</H3>
<PRE>
public final java.lang.String <B>substring</B>(java.lang.Object&nbsp;from,
                                        java.lang.Object&nbsp;to)</PRE>
<DL>
<DD><p>Returns a substring of the current string consisting of the characters between 
 positions <tt>from</tt> and <tt>to</tt>. The character at position <tt>from</tt> 
 is included, but the character at position <tt>to</tt> is not included.</p>
 <p>If <tt>from</tt> equals <tt>to</tt>, this method returns an empty 
 (length 0) string. If <tt>from</tt> is greater than <tt>to</tt>, this method 
 first swaps the two arguments and then returns the substring between them.</p>
 <p>It is important to remember that the character at position <tt>from</tt> is 
 included in the substring but that the character at position <tt>to</tt> is 
 not included in the substring. While this may seem arbitrary or counter-intuitive, 
 a notable feature of this system is that the length of the returned substring is 
 always equal to <tt>to - from</tt>.</p>
 <p>Note that <A HREF="../../js/StringLike.html#slice(java.lang.Object, java.lang.Object)"><CODE>StringLike.slice(Object, Object)</CODE></A> and the nonstandard 
 <A HREF="../../js/StringLike.html#substr(java.lang.Object, java.lang.Object)"><CODE>StringLike.substr(Object, Object)</CODE></A> can also extract substrings from a string. 
 Unlike those methods, this method does not accept negative arguments.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#substring(java.lang.Object, java.lang.Object)">substring</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>from</CODE> - A nonnegative integer that specifies the position within the current 
 string of the first character of the desired substring.<DD><CODE>to</CODE> - A nonnegative optional integer that is one greater than the position of 
 the last character of the desired substring. If this argument is undefined, the 
 returned substring runs to the end of the string.
<DT><B>Returns:</B><DD>A new string, of length <tt>to - from</tt>, which contains a substring 
 of the current string. The new string contains characters copied from positions 
 <tt>from</tt> to <tt>to</tt> - 1 of the string.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#substring(java.lang.Object)"><CODE>substring(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#charAt(java.lang.Object)"><CODE>charAt(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object)"><CODE>indexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#indexOf(java.lang.Object, java.lang.Object)"><CODE>indexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object)"><CODE>lastIndexOf(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#lastIndexOf(java.lang.Object, java.lang.Object)"><CODE>lastIndexOf(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#slice(java.lang.Object)"><CODE>slice(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#slice(java.lang.Object, java.lang.Object)"><CODE>slice(Object, Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object)"><CODE>substr(Object)</CODE></A>, 
<A HREF="../../js/core/JsString.html#substr(java.lang.Object, java.lang.Object)"><CODE>substr(Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#substring(js.StringLike, java.lang.Object, java.lang.Object)"><CODE>StringLikes.substring(StringLike, Object, Object)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#substring(java.lang.String, java.lang.Object, java.lang.Object)"><CODE>StringLikes.substring(String, Object, Object)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toLowerCase()"><!-- --></A><H3>
toLowerCase</H3>
<PRE>
public final java.lang.String <B>toLowerCase</B>()</PRE>
<DL>
<DD><p>Returns a copy of string, with each upper-case letter converted to its lower-case 
 equivalent, if it has one.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#toLowerCase()">toLowerCase</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A copy of string, with each upper-case letter converted to its lower-case 
 equivalent, if it has one.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#toLocaleLowerCase()"><CODE>toLocaleLowerCase()</CODE></A>, 
<A HREF="../../js/core/JsString.html#toLocaleUpperCase()"><CODE>toLocaleUpperCase()</CODE></A>, 
<A HREF="../../js/core/JsString.html#toUpperCase()"><CODE>toUpperCase()</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#toLowerCase(js.StringLike)"><CODE>StringLikes.toLowerCase(StringLike)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#toLowerCase(java.lang.String)"><CODE>StringLikes.toLowerCase(String)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toUpperCase()"><!-- --></A><H3>
toUpperCase</H3>
<PRE>
public final java.lang.String <B>toUpperCase</B>()</PRE>
<DL>
<DD><p>Returns a copy of string, with each lower-case letter converted to its upper-case 
 equivalent, if it has one.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#toUpperCase()">toUpperCase</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A copy of string, with each lower-case letter converted to its upper-case 
 equivalent, if it has one.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#toLocaleLowerCase()"><CODE>toLocaleLowerCase()</CODE></A>, 
<A HREF="../../js/core/JsString.html#toLocaleUpperCase()"><CODE>toLocaleUpperCase()</CODE></A>, 
<A HREF="../../js/core/JsString.html#toLowerCase()"><CODE>toLowerCase()</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#toUpperCase(js.StringLike)"><CODE>StringLikes.toUpperCase(StringLike)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#toUpperCase(java.lang.String)"><CODE>StringLikes.toUpperCase(String)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toLocaleLowerCase()"><!-- --></A><H3>
toLocaleLowerCase</H3>
<PRE>
public final java.lang.String <B>toLocaleLowerCase</B>()</PRE>
<DL>
<DD><p>Returns a copy of the current string, converted to lower-case letters in a 
 locale-specific way. Only a few languages, such as Turkish, have locale-specific 
 case mappings, so this method usually returns the same value as 
 <A HREF="../../js/core/JsString.html#toLowerCase()"><CODE>toLowerCase()</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#toLocaleLowerCase()">toLocaleLowerCase</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A copy of the current string, converted to lower-case letters in a 
 locale-specific way.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#toLocaleUpperCase()"><CODE>toLocaleUpperCase()</CODE></A>, 
<A HREF="../../js/core/JsString.html#toLowerCase()"><CODE>toLowerCase()</CODE></A>, 
<A HREF="../../js/core/JsString.html#toUpperCase()"><CODE>toUpperCase()</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#toLocaleLowerCase(js.StringLike)"><CODE>StringLikes.toLocaleLowerCase(StringLike)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#toLocaleLowerCase(java.lang.String)"><CODE>StringLikes.toLocaleLowerCase(String)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toLocaleUpperCase()"><!-- --></A><H3>
toLocaleUpperCase</H3>
<PRE>
public final java.lang.String <B>toLocaleUpperCase</B>()</PRE>
<DL>
<DD><p>Returns a copy of the current string, converted to upper-case letters in a 
 locale-specific way. Only a few languages, such as Turkish, have locale-specific 
 case mappings, so this method usually returns the same value as 
 <A HREF="../../js/core/JsString.html#toUpperCase()"><CODE>toUpperCase()</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#toLocaleUpperCase()">toLocaleUpperCase</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A copy of the current string, converted to upper-case letters in a 
 locale-specific way.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsString.html#toLocaleLowerCase()"><CODE>toLocaleLowerCase()</CODE></A>, 
<A HREF="../../js/core/JsString.html#toLowerCase()"><CODE>toLowerCase()</CODE></A>, 
<A HREF="../../js/core/JsString.html#toUpperCase()"><CODE>toUpperCase()</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#toLocaleUpperCase(js.StringLike)"><CODE>StringLikes.toLocaleUpperCase(StringLike)</CODE></A>, 
<A HREF="../../jsx/core/StringLikes.html#toLocaleUpperCase(java.lang.String)"><CODE>StringLikes.toLocaleUpperCase(String)</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="valueOf()"><!-- --></A><H3>
valueOf</H3>
<PRE>
public java.lang.String <B>valueOf</B>()</PRE>
<DL>
<DD><p>Returns the primitive value associated with the current instance, if there is one. 
 This invocation returns the same thing as <A HREF="../../js/core/JsObject.html#toString()"><CODE>JsObject.toString()</CODE></A>.</p>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../js/StringLike.html#valueOf()">valueOf</A></CODE> in interface <CODE><A HREF="../../js/StringLike.html" title="interface in js">StringLike</A></CODE><DT><B>Overrides:</B><DD><CODE><A HREF="../../js/Var.html#valueOf()">valueOf</A></CODE> in class <CODE><A HREF="../../js/Var.html" title="class in js">Var</A>&lt;<A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The primitive string value associated with the current instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../js/core/JsObject.html#toString()"><CODE>JsObject.toString()</CODE></A><DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must convert the interface invocation of this method directly 
 into a JavaScript invocation on its current string instance without changing the 
 method name, but expanding variable arguments, if any, into comma-separated values.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="in(java.lang.Object)"><!-- --></A><H3>
in</H3>
<PRE>
public boolean <B>in</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks if the current string instance is the name of a property of the second 
 operand, resembling the <tt>in</tt> operator in JavaScript.</p>
 <p>This operation converts the current string instance to a string and expects 
 the second operand be an object (or array).</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any object or array.
<DT><B>Returns:</B><DD><tt>true</tt> if the current string instance is the name of a property of 
 the second operand; <tt>false</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p in other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="instanceOf(java.lang.Object)"><!-- --></A><H3>
instanceOf</H3>
<PRE>
public final boolean <B>instanceOf</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks if the current string instance is an instance of the second operand, 
 resembling the <tt>instanceof</tt> operator in JavaScript.</p>
 <p>This operation expects the first operand be an object and the second be a class 
 of objects. In JavaScript, classes of objects are defined by the constructor function 
 that initializes them.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A constructor function.
<DT><B>Returns:</B><DD><tt>true</tt> if the current string instance is an instance of the second 
 operand; <tt>false</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p instanceof other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="add(java.lang.Object)"><!-- --></A><H3>
add</H3>
<PRE>
public final java.lang.String <B>add</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Adds the current string instance to a numeric operand or concatenates it with 
 a string operand, resembling the addition operator in JavaScript.</p>
 <p>If one value is a string, the other is converted to a string, and the two 
 strings are then concatenated. Object operands are converted to numbers or strings 
 that can be added or concatenated. The conversion is performed by <A HREF="../../js/Js.html#valueOf(java.lang.Object)"><CODE>Js.valueOf(Object)</CODE></A>  
 method and/or the <A HREF="../../js/Js.html#toString(java.lang.Object)"><CODE>Js.toString(Object)</CODE></A> method on the object.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The sum or concatenation of the values.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p + other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="be()"><!-- --></A><H3>
be</H3>
<PRE>
public final boolean <B>be</B>()</PRE>
<DL>
<DD><p>Logically evaluates the current string instance.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The logical value of the current string instance.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must ignore the instance invocation of this method, that is, 
 replacing it with its current primitive instance.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="not()"><!-- --></A><H3>
not</H3>
<PRE>
public final boolean <B>not</B>()</PRE>
<DL>
<DD><p>Inverts the boolean value of the current string instance, resembling the 
 logical NOT operator in JavaScript.</p>
 <p>This operation converts the current string instance to a boolean value using 
 the following rules if necessary before inverting the converted value.</p>
 <ul>
 <li>If a number is used where a boolean value is expected, the number is converted 
 to <tt>true</tt> unless the number is 0 or NaN, which are converted to <tt>false</tt>.</li>
 <li>If a string is used where a boolean value is expected, it is converted to <tt>true</tt> 
 except for the empty string, which is converted to <tt>false</tt>.</li>
 <li><tt>null</tt> and the undefined value convert to <tt>false</tt>, and any 
 non-null object, array, or function converts to <tt>true</tt>.
 </ul>
 <p>You can convert any value <tt>x</tt> to its equivalent boolean value by applying 
 this operation twice: <tt>Js.not(Js.not(x))</tt></p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical NOT operator of the 
 Java language like this:
 <pre>!Js.be(var)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The inverted boolean value.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>!p</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="eq(java.lang.Object)"><!-- --></A><H3>
eq</H3>
<PRE>
public final boolean <B>eq</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are equal according to the 
 equality operation:
 <ul>
 <li>If the two values have the same type, test them for identity. If the values are 
 identical, they are equal; if they are not identical, they are not equal.</li>
 <li>If the two values do not have the same type, they may still be equal. Use the 
 following rules and type conversions to check for equality:</li>
 <ul>
 <li>If one value is null and the other is undefined, they are equal.</li>
 <li>If one value is a number and the other is a string, convert the string to a 
 number and try the comparison again, using the converted value.</li>
 <li>If either value is <tt>true</tt>, convert it to 1 and try the comparison 
 again. If either value is <tt>false</tt>, convert it to 0 and try the comparison 
 again.</li>
 <li>If one value is an object and the other is a number or string, convert the 
 object to a primitive and try the comparison again. An object is converted to a 
 primitive value by either its <tt>toString()</tt> method or its <tt>valueOf()</tt> 
 method. The built-in classes of core JavaScript attempt <tt>valueOf()</tt> 
 conversion before <tt>toString()</tt> conversion, except for the Date class, 
 which performs <tt>toString()</tt> conversion. Objects that are not part of core 
 JavaScript may convert themselves to primitive values in an implementation-defined 
 way.</li>
 <li>Any other combinations of values are not equal.</li>
 </ul>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand equals the second; <tt>false</tt>, 
 otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p == other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="eqs(java.lang.Object)"><!-- --></A><H3>
eqs</H3>
<PRE>
public final boolean <B>eqs</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are identical according to the identity operation:
 <ul>
 <li>If the two values have different types, they are not identical.</li>
 <li>If both values are numbers and have the same value, they are identical, unless 
 either or both values are <tt>NaN</tt>, in which case they are not identical. 
 The <tt>NaN</tt> value is never identical to any other value, including itself! 
 To check whether a value is <tt>NaN</tt>, use the global <A HREF="../../js/Js.html#isNaN(java.lang.Object)"><CODE>Js.isNaN(Object)</CODE></A> 
 function.</li>
 <li>If both values are strings and contain exactly the same characters in the same 
 positions, they are identical. If the strings differ in length or content, they are 
 not identical. Note that in some cases, the Unicode standard allows more than one 
 way to encode the same string. For efficiency, however, JavaScript's string 
 comparison compares strictly on a character-by-character basis, and it assumes that 
 all strings have been converted to a "normalized form" before they are compared. 
 See the <A HREF="../../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> for another way to compare strings.</li>
 <li>If both values are the boolean value <tt>true</tt> or both are the boolean 
 value <tt>false</tt>, they are identical.</li>
 <li>If both values refer to the same object, array, or function, they are identical. 
 If they refer to different objects (or arrays or functions) they are not identical, 
 even if both objects have identical properties or both arrays have identical elements.</li>
 <li>If both values are null or both values are undefined, they are identical.</li>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>true</tt> if the first operand is identical to the second; 
 <tt>false</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p === other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="neq(java.lang.Object)"><!-- --></A><H3>
neq</H3>
<PRE>
public final boolean <B>neq</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are not "equal" using a more relaxed definition of 
 sameness that allows type conversions, resembling the equality operator in 
 JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are equal according to the 
 equality operation:
 <ul>
 <li>If the two values have the same type, test them for identity. If the values are 
 identical, they are equal; if they are not identical, they are not equal.</li>
 <li>If the two values do not have the same type, they may still be equal. Use the 
 following rules and type conversions to check for equality:</li>
 <ul>
 <li>If one value is null and the other is undefined, they are equal.</li>
 <li>If one value is a number and the other is a string, convert the string to a 
 number and try the comparison again, using the converted value.</li>
 <li>If either value is <tt>true</tt>, convert it to 1 and try the comparison 
 again. If either value is <tt>false</tt>, convert it to 0 and try the comparison 
 again.</li>
 <li>If one value is an object and the other is a number or string, convert the 
 object to a primitive and try the comparison again. An object is converted to a 
 primitive value by either its <tt>toString()</tt> method or its <tt>valueOf()</tt> 
 method. The built-in classes of core JavaScript attempt <tt>valueOf()</tt> 
 conversion before <tt>toString()</tt> conversion, except for the Date class, 
 which performs <tt>toString()</tt> conversion. Objects that are not part of core 
 JavaScript may convert themselves to primitive values in an implementation-defined 
 way.</li>
 <li>Any other combinations of values are not equal.</li>
 </ul>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>false</tt> if the first operand equals the second; <tt>true</tt>, 
 otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p != other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="neqs(java.lang.Object)"><!-- --></A><H3>
neqs</H3>
<PRE>
public final boolean <B>neqs</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Checks whether the two operands are not "identical" using a strict definition of 
 sameness, resembling the identity operator in JavaScript.</p>
 <p>The equality and identity operations check whether two values are the same, using 
 two different definitions of sameness. Both operations accept operands of any type, 
 and both return <tt>true</tt> if their operands are the same and <tt>false</tt> 
 if they are different. The identity operation checks whether its two operands are 
 "identical" using a strict definition of sameness. The equality operation checks 
 whether its two operands are "equal" using a more relaxed definition of sameness 
 that allows type conversions.</p>
 <p>The identity operation is standardized by ECMAScript v3 and implemented in 
 JavaScript 1.3 and later. Be sure you understand the differences between the 
 assignment, equality, and identity operations, and be careful to use the correct one 
 when coding! Although it is tempting to call all three operations "equals," it may 
 help to reduce confusion if you read "gets or is assigned" for assignment operation, 
 "is equal to" for equality operation, and "is identical to" for identity operation.</p>
 <p>In JavaScript, numbers, strings, and boolean values are compared by value. In this 
 case, two separate values are involved, and the equality and identity operations 
 check that these two values are identical. This means that two variables are equal 
 or identical only if they contain the same value. For example, two strings are equal 
 only if they each contain exactly the same characters.</p>
 <p>On the other hand, objects, arrays, and functions are compared by reference. This 
 means that two variables are equal only if they refer to the same object. Two 
 separate arrays are never equal or identical, even if they contain equal or identical 
 elements. Two variables that contain references to objects, arrays, or functions are 
 equal only if they refer to the same object, array, or function. If you want to test 
 that two distinct objects contain the same properties or that two distinct arrays 
 contain the same elements, you'll have to check the properties or elements individually 
 for equality or identity. And, if any of the properties or elements are themselves 
 objects or arrays, you'll have to decide how deep you want the comparison to go.</p>
 <p>The following rules determine whether two values are identical according to the identity operation:
 <ul>
 <li>If the two values have different types, they are not identical.</li>
 <li>If both values are numbers and have the same value, they are identical, unless 
 either or both values are <tt>NaN</tt>, in which case they are not identical. 
 The <tt>NaN</tt> value is never identical to any other value, including itself! 
 To check whether a value is <tt>NaN</tt>, use the global <A HREF="../../js/Js.html#isNaN(java.lang.Object)"><CODE>Js.isNaN(Object)</CODE></A> 
 function.</li>
 <li>If both values are strings and contain exactly the same characters in the same 
 positions, they are identical. If the strings differ in length or content, they are 
 not identical. Note that in some cases, the Unicode standard allows more than one 
 way to encode the same string. For efficiency, however, JavaScript's string 
 comparison compares strictly on a character-by-character basis, and it assumes that 
 all strings have been converted to a "normalized form" before they are compared. 
 See the <A HREF="../../js/StringLike.html#localeCompare(java.lang.Object)"><CODE>StringLike.localeCompare(Object)</CODE></A> for another way to compare strings.</li>
 <li>If both values are the boolean value <tt>true</tt> or both are the boolean 
 value <tt>false</tt>, they are identical.</li>
 <li>If both values refer to the same object, array, or function, they are identical. 
 If they refer to different objects (or arrays or functions) they are not identical, 
 even if both objects have identical properties or both arrays have identical elements.</li>
 <li>If both values are null or both values are undefined, they are identical.</li>
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - Any value or object.
<DT><B>Returns:</B><DD><tt>false</tt> if the first operand is identical to the second; 
 <tt>true</tt>, otherwise;<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p !== other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.Object)"><!-- --></A><H3>
and</H3>
<PRE>
public final java.lang.Object <B>and</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(java.lang.String)"><!-- --></A><H3>
and</H3>
<PRE>
public final java.lang.String <B>and</B>(java.lang.String&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Value)"><!-- --></A><H3>
and</H3>
<PRE>
public final java.lang.String <B>and</B>(<A HREF="../../js/Value.html" title="class in js">Value</A>&lt;java.lang.String&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.Var)"><!-- --></A><H3>
and</H3>
<PRE>
public final <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A> <B>and</B>(<A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="and(js.core.JsString)"><!-- --></A><H3>
and</H3>
<PRE>
public final <A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A> <B>and</B>(<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical AND operation, resembling that of JavaScript, performs the Boolean AND 
 operation on the two values: it returns <tt>true</tt> if and only if both its first 
 operand and its second operand are <tt>true</tt>. If one or both of these operands 
 is <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, depending on the value of the left-side expression, the operator 
 may or may not evaluate the right-side expression. The actual behavior of the operator 
 is somewhat more complicated. It starts by evaluating its first operand, the expression 
 on its left. If the value of this expression can be converted to <tt>false</tt> 
 (for example, if the left operand evaluates to <tt>null</tt>, 0, "", or undefined), 
 the operator returns the value of the left-side expression. Otherwise, it evaluates 
 its second operand, the expression on its right, and returns the value of that 
 expression. In JavaScript 1.0 and JavaScript 1.1, if the left-side expression 
 evaluates to <tt>false</tt>, the && operator returns <tt>false</tt> rather than 
 returning the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Sometimes, this operation probably does not do what the programmers intended. 
 To avoid problems, do not use expressions with side effects (assignments, increments, 
 decrements, and function calls) for the second operand unless you are quite sure 
 you know exactly what you are doing.</p>
 <p>Despite the fairly confusing way that this operation actually works, it is 
 easiest, and perfectly safe, to think of it as merely a Boolean algebra operator. 
 Although it does not actually return a boolean value, the value it returns can always 
 be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical AND operator of the 
 Java language like this:
 <pre>Js.be(var) && Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical AND of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p && other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.Object)"><!-- --></A><H3>
or</H3>
<PRE>
public final java.lang.Object <B>or</B>(java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../../js/core/JsString.html#and(java.lang.Object)"><CODE>and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(java.lang.String)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A> <B>or</B>(java.lang.String&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../../js/core/JsString.html#and(java.lang.Object)"><CODE>and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Value)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A> <B>or</B>(<A HREF="../../js/Value.html" title="class in js">Value</A>&lt;java.lang.String&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../../js/core/JsString.html#and(java.lang.Object)"><CODE>and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.Var)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A> <B>or</B>(<A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../../js/core/JsString.html#and(java.lang.Object)"><CODE>and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="or(js.core.JsString)"><!-- --></A><H3>
or</H3>
<PRE>
public final <A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A> <B>or</B>(<A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</PRE>
<DL>
<DD><p>Logical OR operation, resembling that of JavaScript, performs the Boolean OR 
 operation on the two values: it returns <tt>true</tt> if either the first operand or 
 the second operand is <tt>true</tt>, or if both are <tt>true</tt>. If both operands 
 are <tt>false</tt>, it returns <tt>false</tt>.</p>
 <p>In JavaScript, although the || operator is most often used simply as a Boolean OR 
 operator, it, like the && operator, has more complex behavior. It starts by evaluating 
 its first operand, the expression on its left. If the value of this expression can 
 be converted to <tt>true</tt>, it returns the unconverted value of the left-side 
 expression. Otherwise, it evaluates its second operand, the expression on its right, 
 and returns the value of that expression. In JavaScript 1.0 and JavaScript 1.1, if the 
 left-side expression can be converted to <tt>true</tt>, the operator returns <tt>true</tt> 
 and doesn't return the unconverted value of the left-side expression.</p>
 <p>To make the second operand really late-evaluated or not evaluated in JS Simulation 
 mode, resembling what happens in JavaScript, you may have to extend <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> 
 anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>As with the <A HREF="../../js/core/JsString.html#and(java.lang.Object)"><CODE>and(Object)</CODE></A> operation, you should avoid right-side 
 operands that include side effects, unless you purposely want to use the fact that 
 the right-side expression may not be evaluated in JavaScript.</p>
 <p>Even when this operation is used with operands that are not boolean values, it 
 can still be considered a Boolean OR operator because its return value, whatever the 
 type, can be converted to a boolean value.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the logical OR operator of the 
 Java language like this:
 <pre>Js.be(var) || Js.be(other)</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The logical OR of the two operands.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>p || other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
cond</H3>
<PRE>
public final java.lang.Object <B>cond</B>(java.lang.Object&nbsp;test,
                                   java.lang.Object&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, js.Var)"><!-- --></A><H3>
cond</H3>
<PRE>
public final <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A> <B>cond</B>(java.lang.Object&nbsp;test,
                           <A HREF="../../js/Var.html" title="class in js">Var</A>&lt;? extends <A HREF="../../js/core/JsObject.html" title="class in js.core">JsObject</A>&gt;&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cond(java.lang.Object, js.core.JsString)"><!-- --></A><H3>
cond</H3>
<PRE>
public final <A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A> <B>cond</B>(java.lang.Object&nbsp;test,
                           <A HREF="../../js/core/JsString.html" title="class in js.core">JsString</A>&nbsp;other)</PRE>
<DL>
<DD><p>Conditional operation, resembling the ternary operator of JavaScript, returns the 
 second operand if the first operand evaluates to <tt>true</tt>; Returns the third 
 operand, otherwise.</p>
 <p>The first operand of the conditional operation must be (or be convertible to) a 
 boolean value. Usually this is the result of a comparison operation. The second and 
 third operands may have any value. The value returned by the conditional operation 
 depends on the boolean value of the first operand. If that operand is <tt>true</tt>, 
 the value of the conditional expression is the value of the second operand. If the 
 first operand is <tt>false</tt>, the value of the conditional expression is the 
 value of the third operand.</p>
 <p>To make the second and third operands really late-evaluated or not evaluated in 
 JS Simulation mode, resembling what happens in JavaScript, you may have to extend 
 <A HREF="../../js/Var.html" title="class in js"><CODE>Var</CODE></A> anonymously, returning the actual expression in the method overriding 
 <A HREF="../../js/Var.html#var()"><CODE>Var.var()</CODE></A>.</p>
 <p>Note that, this method is probably useful in emulation codes just for perfect 
 re-compilations. However, in most cases you can use the conditional operator of the 
 Java language like this:
 <pre>Js.be(test) ? var : other</pre>
 which is definitely late-evaluated but not necessarily re-compiled into an expected 
 JavaScript expression since the Java compilers generally used are free to compile 
 the expression into any byte codes they think efficient, making it too hard for the 
 re-compilers to reconvert the byte codes to an expression in JavaScript.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - A value or object.
<DT><B>Returns:</B><DD>The second operand if the first operand evaluates to <tt>true</tt>; Otherwise, 
 the third operand.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>test ? p : other</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="eval()"><!-- --></A><H3>
eval</H3>
<PRE>
public final java.lang.Object <B>eval</B>()</PRE>
<DL>
<DD><p>Evaluates the current primitive string instance as JavaScript code and 
 returns the result.</p>
 <p>In JavaScript, <tt>eval()</tt> is a global method that evaluates a string of 
 JavaScript code in the current lexical scope. If the code contains an expression, 
 eval evaluates the expression and returns its value. If the code contains a 
 JavaScript statement or statements, it executes those statements and returns the 
 value, if any, returned by the last statement. If the code does not return any 
 value, <tt>eval()</tt> returns undefined. Finally, if code throws an exception, 
 <tt>eval()</tt> passes that exception on to the caller.</p>
 <p>The global function <tt>eval()</tt> provides a very powerful capability to 
 the JavaScript language, but its use is infrequent in real-world programs. 
 Obvious uses are to write programs that act as recursive JavaScript interpreters 
 and to write programs that dynamically generate and evaluate JavaScript code.</p>
 <p>Most JavaScript functions and methods that expect string arguments accept 
 arguments of other types as well and simply convert those argument values to 
 strings before proceeding. <tt>eval()</tt> does not behave like this. If the 
 code argument is not a primitive string, it is simply returned unchanged. Be 
 careful, therefore, that you do not inadvertently pass a String object to 
 <tt>eval()</tt> when you intended to pass a primitive string value.</p>
 <p>For purposes of implementation efficiency, the ECMAScript v3 standard places 
 an unusual restriction on the use of <tt>eval()</tt>. An ECMAScript implementation 
 is allowed to throw an <tt>EvalError</tt> exception if you attempt to overwrite 
 the <tt>eval</tt> property or if you assign the <tt>eval()</tt> method to another 
 property and attempt to invoke it through that property.</p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The return value of the evaluated code, if any.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - JavaScript throws a <tt>SyntaxError</tt> if the current 
 primitive instance does not contain legal JavaScript, a <tt>EvalError</tt> if 
 the <tt>eval</tt> function was called illegally, through an identifier other 
 than "eval", or other JavaScript error generated by the code passed. See 
 <A HREF="../../js/Js.html#err(java.lang.Object)"><CODE>Js.err(Object)</CODE></A>, <A HREF="../../js/core/JsSyntaxError.html" title="class in js.core"><CODE>JsSyntaxError</CODE></A>, <A HREF="../../js/core/JsEvalError.html" title="class in js.core"><CODE>JsEvalError</CODE></A>, 
 and <A HREF="../../js/core/JsError.html" title="class in js.core"><CODE>JsError</CODE></A> for JS Simulation.<DT><B>Since:</B></DT>
  <DD>1.0</DD>
<DT><B>JavaScript:</B></DT>
  <DD>Re-compilers must replace the instance invocation of this method with the 
 JavaScript expression:
 <pre>eval(p)</pre>
 where <tt>p</tt> is the current string instance of the invocation of this method.</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JsString.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
JScripter(JS) Standard 1.0 API & Re-compilation Specification</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../js/core/JsRegExp.Members.html" title="class in js.core"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../js/core/JsString.Member.html" title="class in js.core"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?js/core/JsString.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="JsString.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright &#169; 2008-2011 J.J.Liu (www.jscripter.org). All Rights Reserved.</i>
</BODY>
</HTML>
